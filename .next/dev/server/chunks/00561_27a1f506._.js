module.exports = [
"[project]/align/node_modules/@panva/hkdf/dist/node/esm/runtime/fallback.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
;
const __TURBOPACK__default__export__ = (digest, ikm, salt, info, keylen)=>{
    const hashlen = parseInt(digest.substr(3), 10) >> 3 || 20;
    const prk = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["createHmac"])(digest, salt.byteLength ? salt : new Uint8Array(hashlen)).update(ikm).digest();
    const N = Math.ceil(keylen / hashlen);
    const T = new Uint8Array(hashlen * N + info.byteLength + 1);
    let prev = 0;
    let start = 0;
    for(let c = 1; c <= N; c++){
        T.set(info, start);
        T[start + info.byteLength] = c;
        T.set((0, __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["createHmac"])(digest, prk).update(T.subarray(prev, start + info.byteLength + 1)).digest(), start);
        prev = start;
        start += hashlen;
    }
    return T.slice(0, keylen);
};
}),
"[project]/align/node_modules/@panva/hkdf/dist/node/esm/runtime/hkdf.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$panva$2f$hkdf$2f$dist$2f$node$2f$esm$2f$runtime$2f$fallback$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/@panva/hkdf/dist/node/esm/runtime/fallback.js [app-route] (ecmascript)");
;
;
let hkdf;
if (typeof __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["hkdf"] === 'function' && !process.versions.electron) {
    hkdf = async (...args)=>new Promise((resolve, reject)=>{
            __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["hkdf"](...args, (err, arrayBuffer)=>{
                if (err) reject(err);
                else resolve(new Uint8Array(arrayBuffer));
            });
        });
}
const __TURBOPACK__default__export__ = async (digest, ikm, salt, info, keylen)=>(hkdf || __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$panva$2f$hkdf$2f$dist$2f$node$2f$esm$2f$runtime$2f$fallback$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(digest, ikm, salt, info, keylen);
}),
"[project]/align/node_modules/@panva/hkdf/dist/node/esm/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>hkdf,
    "hkdf",
    ()=>hkdf
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$panva$2f$hkdf$2f$dist$2f$node$2f$esm$2f$runtime$2f$hkdf$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/@panva/hkdf/dist/node/esm/runtime/hkdf.js [app-route] (ecmascript)");
;
function normalizeDigest(digest) {
    switch(digest){
        case 'sha256':
        case 'sha384':
        case 'sha512':
        case 'sha1':
            return digest;
        default:
            throw new TypeError('unsupported "digest" value');
    }
}
function normalizeUint8Array(input, label) {
    if (typeof input === 'string') return new TextEncoder().encode(input);
    if (!(input instanceof Uint8Array)) throw new TypeError(`"${label}"" must be an instance of Uint8Array or a string`);
    return input;
}
function normalizeIkm(input) {
    const ikm = normalizeUint8Array(input, 'ikm');
    if (!ikm.byteLength) throw new TypeError(`"ikm" must be at least one byte in length`);
    return ikm;
}
function normalizeInfo(input) {
    const info = normalizeUint8Array(input, 'info');
    if (info.byteLength > 1024) {
        throw TypeError('"info" must not contain more than 1024 bytes');
    }
    return info;
}
function normalizeKeylen(input, digest) {
    if (typeof input !== 'number' || !Number.isInteger(input) || input < 1) {
        throw new TypeError('"keylen" must be a positive integer');
    }
    const hashlen = parseInt(digest.substr(3), 10) >> 3 || 20;
    if (input > 255 * hashlen) {
        throw new TypeError('"keylen" too large');
    }
    return input;
}
async function hkdf(digest, ikm, salt, info, keylen) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$panva$2f$hkdf$2f$dist$2f$node$2f$esm$2f$runtime$2f$hkdf$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(normalizeDigest(digest), normalizeIkm(ikm), normalizeUint8Array(salt, 'salt'), normalizeInfo(info), normalizeKeylen(keylen, digest));
}
;
}),
"[project]/align/node_modules/preact/dist/preact.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Component",
    ()=>k,
    "Fragment",
    ()=>b,
    "cloneElement",
    ()=>E,
    "createContext",
    ()=>G,
    "createElement",
    ()=>_,
    "createRef",
    ()=>m,
    "h",
    ()=>_,
    "hydrate",
    ()=>D,
    "isValidElement",
    ()=>t,
    "options",
    ()=>l,
    "render",
    ()=>B,
    "toChildArray",
    ()=>H
]);
var n, l, u, t, i, o, r, f, e, c, s, a, h = {}, v = [], p = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, y = Array.isArray;
function d(n, l) {
    for(var u in l)n[u] = l[u];
    return n;
}
function w(n) {
    n && n.parentNode && n.parentNode.removeChild(n);
}
function _(l, u, t) {
    var i, o, r, f = {};
    for(r in u)"key" == r ? i = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];
    if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : t), "function" == typeof l && null != l.defaultProps) for(r in l.defaultProps)void 0 === f[r] && (f[r] = l.defaultProps[r]);
    return g(l, f, i, o, null);
}
function g(n, t, i, o, r) {
    var f = {
        type: n,
        props: t,
        key: i,
        ref: o,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        constructor: void 0,
        __v: null == r ? ++u : r,
        __i: -1,
        __u: 0
    };
    return null == r && null != l.vnode && l.vnode(f), f;
}
function m() {
    return {
        current: null
    };
}
function b(n) {
    return n.children;
}
function k(n, l) {
    this.props = n, this.context = l;
}
function x(n, l) {
    if (null == l) return n.__ ? x(n.__, n.__i + 1) : null;
    for(var u; l < n.__k.length; l++)if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
    return "function" == typeof n.type ? x(n) : null;
}
function C(n) {
    var l, u;
    if (null != (n = n.__) && null != n.__c) {
        for(n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++)if (null != (u = n.__k[l]) && null != u.__e) {
            n.__e = n.__c.base = u.__e;
            break;
        }
        return C(n);
    }
}
function S(n) {
    (!n.__d && (n.__d = !0) && i.push(n) && !M.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || r)(M);
}
function M() {
    var n, u, t, o, r, e, c, s;
    for(i.sort(f); n = i.shift();)n.__d && (u = i.length, o = void 0, e = (r = (t = n).__v).__e, c = [], s = [], t.__P && ((o = d({}, r)).__v = r.__v + 1, l.vnode && l.vnode(o), O(t.__P, o, r, t.__n, t.__P.namespaceURI, 32 & r.__u ? [
        e
    ] : null, c, null == e ? x(r) : e, !!(32 & r.__u), s), o.__v = r.__v, o.__.__k[o.__i] = o, j(c, o, s), o.__e != e && C(o)), i.length > u && i.sort(f));
    M.__r = 0;
}
function P(n, l, u, t, i, o, r, f, e, c, s) {
    var a, p, y, d, w, _ = t && t.__k || v, g = l.length;
    for(u.__d = e, $(u, l, _), e = u.__d, a = 0; a < g; a++)null != (y = u.__k[a]) && (p = -1 === y.__i ? h : _[y.__i] || h, y.__i = a, O(n, y, p, i, o, r, f, e, c, s), d = y.__e, y.ref && p.ref != y.ref && (p.ref && N(p.ref, null, y), s.push(y.ref, y.__c || d, y)), null == w && null != d && (w = d), 65536 & y.__u || p.__k === y.__k ? e = I(y, e, n) : "function" == typeof y.type && void 0 !== y.__d ? e = y.__d : d && (e = d.nextSibling), y.__d = void 0, y.__u &= -196609);
    u.__d = e, u.__e = w;
}
function $(n, l, u) {
    var t, i, o, r, f, e = l.length, c = u.length, s = c, a = 0;
    for(n.__k = [], t = 0; t < e; t++)null != (i = l[t]) && "boolean" != typeof i && "function" != typeof i ? (r = t + a, (i = n.__k[t] = "string" == typeof i || "number" == typeof i || "bigint" == typeof i || i.constructor == String ? g(null, i, null, null, null) : y(i) ? g(b, {
        children: i
    }, null, null, null) : void 0 === i.constructor && i.__b > 0 ? g(i.type, i.props, i.key, i.ref ? i.ref : null, i.__v) : i).__ = n, i.__b = n.__b + 1, o = null, -1 !== (f = i.__i = L(i, u, r, s)) && (s--, (o = u[f]) && (o.__u |= 131072)), null == o || null === o.__v ? (-1 == f && a--, "function" != typeof i.type && (i.__u |= 65536)) : f !== r && (f == r - 1 ? a-- : f == r + 1 ? a++ : (f > r ? a-- : a++, i.__u |= 65536))) : i = n.__k[t] = null;
    if (s) for(t = 0; t < c; t++)null != (o = u[t]) && 0 == (131072 & o.__u) && (o.__e == n.__d && (n.__d = x(o)), V(o, o));
}
function I(n, l, u) {
    var t, i;
    if ("function" == typeof n.type) {
        for(t = n.__k, i = 0; t && i < t.length; i++)t[i] && (t[i].__ = n, l = I(t[i], l, u));
        return l;
    }
    n.__e != l && (l && n.type && !u.contains(l) && (l = x(n)), u.insertBefore(n.__e, l || null), l = n.__e);
    do {
        l = l && l.nextSibling;
    }while (null != l && 8 === l.nodeType)
    return l;
}
function H(n, l) {
    return l = l || [], null == n || "boolean" == typeof n || (y(n) ? n.some(function(n) {
        H(n, l);
    }) : l.push(n)), l;
}
function L(n, l, u, t) {
    var i = n.key, o = n.type, r = u - 1, f = u + 1, e = l[u];
    if (null === e || e && i == e.key && o === e.type && 0 == (131072 & e.__u)) return u;
    if (t > (null != e && 0 == (131072 & e.__u) ? 1 : 0)) for(; r >= 0 || f < l.length;){
        if (r >= 0) {
            if ((e = l[r]) && 0 == (131072 & e.__u) && i == e.key && o === e.type) return r;
            r--;
        }
        if (f < l.length) {
            if ((e = l[f]) && 0 == (131072 & e.__u) && i == e.key && o === e.type) return f;
            f++;
        }
    }
    return -1;
}
function T(n, l, u) {
    "-" === l[0] ? n.setProperty(l, null == u ? "" : u) : n[l] = null == u ? "" : "number" != typeof u || p.test(l) ? u : u + "px";
}
function A(n, l, u, t, i) {
    var o;
    n: if ("style" === l) if ("string" == typeof u) n.style.cssText = u;
    else {
        if ("string" == typeof t && (n.style.cssText = t = ""), t) for(l in t)u && l in u || T(n.style, l, "");
        if (u) for(l in u)t && u[l] === t[l] || T(n.style, l, u[l]);
    }
    else if ("o" === l[0] && "n" === l[1]) o = l !== (l = l.replace(/(PointerCapture)$|Capture$/i, "$1")), l = l.toLowerCase() in n || "onFocusOut" === l || "onFocusIn" === l ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + o] = u, u ? t ? u.u = t.u : (u.u = e, n.addEventListener(l, o ? s : c, o)) : n.removeEventListener(l, o ? s : c, o);
    else {
        if ("http://www.w3.org/2000/svg" == i) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
        else if ("width" != l && "height" != l && "href" != l && "list" != l && "form" != l && "tabIndex" != l && "download" != l && "rowSpan" != l && "colSpan" != l && "role" != l && "popover" != l && l in n) try {
            n[l] = null == u ? "" : u;
            break n;
        } catch (n) {}
        "function" == typeof u || (null == u || !1 === u && "-" !== l[4] ? n.removeAttribute(l) : n.setAttribute(l, "popover" == l && 1 == u ? "" : u));
    }
}
function F(n) {
    return function(u) {
        if (this.l) {
            var t = this.l[u.type + n];
            if (null == u.t) u.t = e++;
            else if (u.t < t.u) return;
            return t(l.event ? l.event(u) : u);
        }
    };
}
function O(n, u, t, i, o, r, f, e, c, s) {
    var a, h, v, p, w, _, g, m, x, C, S, M, $, I, H, L, T = u.type;
    if (void 0 !== u.constructor) return null;
    128 & t.__u && (c = !!(32 & t.__u), r = [
        e = u.__e = t.__e
    ]), (a = l.__b) && a(u);
    n: if ("function" == typeof T) try {
        if (m = u.props, x = "prototype" in T && T.prototype.render, C = (a = T.contextType) && i[a.__c], S = a ? C ? C.props.value : a.__ : i, t.__c ? g = (h = u.__c = t.__c).__ = h.__E : (x ? u.__c = h = new T(m, S) : (u.__c = h = new k(m, S), h.constructor = T, h.render = q), C && C.sub(h), h.props = m, h.state || (h.state = {}), h.context = S, h.__n = i, v = h.__d = !0, h.__h = [], h._sb = []), x && null == h.__s && (h.__s = h.state), x && null != T.getDerivedStateFromProps && (h.__s == h.state && (h.__s = d({}, h.__s)), d(h.__s, T.getDerivedStateFromProps(m, h.__s))), p = h.props, w = h.state, h.__v = u, v) x && null == T.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), x && null != h.componentDidMount && h.__h.push(h.componentDidMount);
        else {
            if (x && null == T.getDerivedStateFromProps && m !== p && null != h.componentWillReceiveProps && h.componentWillReceiveProps(m, S), !h.__e && (null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(m, h.__s, S) || u.__v === t.__v)) {
                for(u.__v !== t.__v && (h.props = m, h.state = h.__s, h.__d = !1), u.__e = t.__e, u.__k = t.__k, u.__k.some(function(n) {
                    n && (n.__ = u);
                }), M = 0; M < h._sb.length; M++)h.__h.push(h._sb[M]);
                h._sb = [], h.__h.length && f.push(h);
                break n;
            }
            null != h.componentWillUpdate && h.componentWillUpdate(m, h.__s, S), x && null != h.componentDidUpdate && h.__h.push(function() {
                h.componentDidUpdate(p, w, _);
            });
        }
        if (h.context = S, h.props = m, h.__P = n, h.__e = !1, $ = l.__r, I = 0, x) {
            for(h.state = h.__s, h.__d = !1, $ && $(u), a = h.render(h.props, h.state, h.context), H = 0; H < h._sb.length; H++)h.__h.push(h._sb[H]);
            h._sb = [];
        } else do {
            h.__d = !1, $ && $(u), a = h.render(h.props, h.state, h.context), h.state = h.__s;
        }while (h.__d && ++I < 25)
        h.state = h.__s, null != h.getChildContext && (i = d(d({}, i), h.getChildContext())), x && !v && null != h.getSnapshotBeforeUpdate && (_ = h.getSnapshotBeforeUpdate(p, w)), P(n, y(L = null != a && a.type === b && null == a.key ? a.props.children : a) ? L : [
            L
        ], u, t, i, o, r, f, e, c, s), h.base = u.__e, u.__u &= -161, h.__h.length && f.push(h), g && (h.__E = h.__ = null);
    } catch (n) {
        if (u.__v = null, c || null != r) {
            for(u.__u |= c ? 160 : 128; e && 8 === e.nodeType && e.nextSibling;)e = e.nextSibling;
            r[r.indexOf(e)] = null, u.__e = e;
        } else u.__e = t.__e, u.__k = t.__k;
        l.__e(n, u, t);
    }
    else null == r && u.__v === t.__v ? (u.__k = t.__k, u.__e = t.__e) : u.__e = z(t.__e, u, t, i, o, r, f, c, s);
    (a = l.diffed) && a(u);
}
function j(n, u, t) {
    u.__d = void 0;
    for(var i = 0; i < t.length; i++)N(t[i], t[++i], t[++i]);
    l.__c && l.__c(u, n), n.some(function(u) {
        try {
            n = u.__h, u.__h = [], n.some(function(n) {
                n.call(u);
            });
        } catch (n) {
            l.__e(n, u.__v);
        }
    });
}
function z(u, t, i, o, r, f, e, c, s) {
    var a, v, p, d, _, g, m, b = i.props, k = t.props, C = t.type;
    if ("svg" === C ? r = "http://www.w3.org/2000/svg" : "math" === C ? r = "http://www.w3.org/1998/Math/MathML" : r || (r = "http://www.w3.org/1999/xhtml"), null != f) {
        for(a = 0; a < f.length; a++)if ((_ = f[a]) && "setAttribute" in _ == !!C && (C ? _.localName === C : 3 === _.nodeType)) {
            u = _, f[a] = null;
            break;
        }
    }
    if (null == u) {
        if (null === C) return document.createTextNode(k);
        u = document.createElementNS(r, C, k.is && k), c && (l.__m && l.__m(t, f), c = !1), f = null;
    }
    if (null === C) b === k || c && u.data === k || (u.data = k);
    else {
        if (f = f && n.call(u.childNodes), b = i.props || h, !c && null != f) for(b = {}, a = 0; a < u.attributes.length; a++)b[(_ = u.attributes[a]).name] = _.value;
        for(a in b)if (_ = b[a], "children" == a) ;
        else if ("dangerouslySetInnerHTML" == a) p = _;
        else if (!(a in k)) {
            if ("value" == a && "defaultValue" in k || "checked" == a && "defaultChecked" in k) continue;
            A(u, a, null, _, r);
        }
        for(a in k)_ = k[a], "children" == a ? d = _ : "dangerouslySetInnerHTML" == a ? v = _ : "value" == a ? g = _ : "checked" == a ? m = _ : c && "function" != typeof _ || b[a] === _ || A(u, a, _, b[a], r);
        if (v) c || p && (v.__html === p.__html || v.__html === u.innerHTML) || (u.innerHTML = v.__html), t.__k = [];
        else if (p && (u.innerHTML = ""), P(u, y(d) ? d : [
            d
        ], t, i, o, "foreignObject" === C ? "http://www.w3.org/1999/xhtml" : r, f, e, f ? f[0] : i.__k && x(i, 0), c, s), null != f) for(a = f.length; a--;)w(f[a]);
        c || (a = "value", "progress" === C && null == g ? u.removeAttribute("value") : void 0 !== g && (g !== u[a] || "progress" === C && !g || "option" === C && g !== b[a]) && A(u, a, g, b[a], r), a = "checked", void 0 !== m && m !== u[a] && A(u, a, m, b[a], r));
    }
    return u;
}
function N(n, u, t) {
    try {
        if ("function" == typeof n) {
            var i = "function" == typeof n.__u;
            i && n.__u(), i && null == u || (n.__u = n(u));
        } else n.current = u;
    } catch (n) {
        l.__e(n, t);
    }
}
function V(n, u, t) {
    var i, o;
    if (l.unmount && l.unmount(n), (i = n.ref) && (i.current && i.current !== n.__e || N(i, null, u)), null != (i = n.__c)) {
        if (i.componentWillUnmount) try {
            i.componentWillUnmount();
        } catch (n) {
            l.__e(n, u);
        }
        i.base = i.__P = null;
    }
    if (i = n.__k) for(o = 0; o < i.length; o++)i[o] && V(i[o], u, t || "function" != typeof n.type);
    t || w(n.__e), n.__c = n.__ = n.__e = n.__d = void 0;
}
function q(n, l, u) {
    return this.constructor(n, u);
}
function B(u, t, i) {
    var o, r, f, e;
    l.__ && l.__(u, t), r = (o = "function" == typeof i) ? null : i && i.__k || t.__k, f = [], e = [], O(t, u = (!o && i || t).__k = _(b, null, [
        u
    ]), r || h, h, t.namespaceURI, !o && i ? [
        i
    ] : r ? null : t.firstChild ? n.call(t.childNodes) : null, f, !o && i ? i : r ? r.__e : t.firstChild, o, e), j(f, u, e);
}
function D(n, l) {
    B(n, l, D);
}
function E(l, u, t) {
    var i, o, r, f, e = d({}, l.props);
    for(r in l.type && l.type.defaultProps && (f = l.type.defaultProps), u)"key" == r ? i = u[r] : "ref" == r ? o = u[r] : e[r] = void 0 === u[r] && void 0 !== f ? f[r] : u[r];
    return arguments.length > 2 && (e.children = arguments.length > 3 ? n.call(arguments, 2) : t), g(l.type, e, i || l.key, o || l.ref, null);
}
function G(n, l) {
    var u = {
        __c: l = "__cC" + a++,
        __: n,
        Consumer: function(n, l) {
            return n.children(l);
        },
        Provider: function(n) {
            var u, t;
            return this.getChildContext || (u = new Set, (t = {})[l] = this, this.getChildContext = function() {
                return t;
            }, this.componentWillUnmount = function() {
                u = null;
            }, this.shouldComponentUpdate = function(n) {
                this.props.value !== n.value && u.forEach(function(n) {
                    n.__e = !0, S(n);
                });
            }, this.sub = function(n) {
                u.add(n);
                var l = n.componentWillUnmount;
                n.componentWillUnmount = function() {
                    u && u.delete(n), l && l.call(n);
                };
            }), n.children;
        }
    };
    return u.Provider.__ = u.Consumer.contextType = u;
}
n = v.slice, l = {
    __e: function(n, l, u, t) {
        for(var i, o, r; l = l.__;)if ((i = l.__c) && !i.__) try {
            if ((o = i.constructor) && null != o.getDerivedStateFromError && (i.setState(o.getDerivedStateFromError(n)), r = i.__d), null != i.componentDidCatch && (i.componentDidCatch(n, t || {}), r = i.__d), r) return i.__E = i;
        } catch (l) {
            n = l;
        }
        throw n;
    }
}, u = 0, t = function(n) {
    return null != n && null == n.constructor;
}, k.prototype.setState = function(n, l) {
    var u;
    u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = d({}, this.state), "function" == typeof n && (n = n(d({}, u), this.props)), n && d(u, n), null != n && this.__v && (l && this._sb.push(l), S(this));
}, k.prototype.forceUpdate = function(n) {
    this.__v && (this.__e = !0, n && this.__h.push(n), S(this));
}, k.prototype.render = b, i = [], r = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f = function(n, l) {
    return n.__v.__b - l.__v.__b;
}, M.__r = 0, e = 0, c = F(!1), s = F(!0), a = 0;
;
 //# sourceMappingURL=preact.module.js.map
}),
"[project]/align/node_modules/preact/jsx-runtime/dist/jsxRuntime.mjs [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "jsx",
    ()=>u,
    "jsxAttr",
    ()=>p,
    "jsxDEV",
    ()=>u,
    "jsxEscape",
    ()=>_,
    "jsxTemplate",
    ()=>a,
    "jsxs",
    ()=>u
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/preact/dist/preact.mjs [app-route] (ecmascript)");
;
;
var t = /["&<]/;
function n(r) {
    if (0 === r.length || !1 === t.test(r)) return r;
    for(var e = 0, n = 0, o = "", f = ""; n < r.length; n++){
        switch(r.charCodeAt(n)){
            case 34:
                f = "&quot;";
                break;
            case 38:
                f = "&amp;";
                break;
            case 60:
                f = "&lt;";
                break;
            default:
                continue;
        }
        n !== e && (o += r.slice(e, n)), o += f, e = n + 1;
    }
    return n !== e && (o += r.slice(e, n)), o;
}
var o = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, f = 0, i = Array.isArray;
function u(e, t, n, o, i, u) {
    t || (t = {});
    var a, c, l = t;
    "ref" in t && (a = t.ref, delete t.ref);
    var p = {
        type: e,
        props: l,
        key: n,
        ref: a,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        constructor: void 0,
        __v: --f,
        __i: -1,
        __u: 0,
        __source: i,
        __self: u
    };
    if ("function" == typeof e && (a = e.defaultProps)) for(c in a)void 0 === l[c] && (l[c] = a[c]);
    return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].vnode && __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].vnode(p), p;
}
function a(r) {
    var t = u(__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Fragment"], {
        tpl: r,
        exprs: [].slice.call(arguments, 1)
    });
    return t.key = t.__v, t;
}
var c = {}, l = /[A-Z]/g;
function p(e, t) {
    if (__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].attr) {
        var f = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].attr(e, t);
        if ("string" == typeof f) return f;
    }
    if ("ref" === e || "key" === e) return "";
    if ("style" === e && "object" == typeof t) {
        var i = "";
        for(var u in t){
            var a = t[u];
            if (null != a && "" !== a) {
                var p = "-" == u[0] ? u : c[u] || (c[u] = u.replace(l, "-$&").toLowerCase()), _ = ";";
                "number" != typeof a || p.startsWith("--") || o.test(p) || (_ = "px;"), i = i + p + ":" + a + _;
            }
        }
        return e + '="' + i + '"';
    }
    return null == t || !1 === t || "function" == typeof t || "object" == typeof t ? "" : !0 === t ? e : e + '="' + n(t) + '"';
}
function _(r) {
    if (null == r || "boolean" == typeof r || "function" == typeof r) return null;
    if ("object" == typeof r) {
        if (void 0 === r.constructor) return r;
        if (i(r)) {
            for(var e = 0; e < r.length; e++)r[e] = _(r[e]);
            return r;
        }
    }
    return n("" + r);
}
;
 //# sourceMappingURL=jsxRuntime.module.js.map
}),
"[project]/align/node_modules/preact-render-to-string/dist/index.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "render",
    ()=>F,
    "renderToStaticMarkup",
    ()=>M,
    "renderToString",
    ()=>D,
    "renderToStringAsync",
    ()=>S
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/preact/dist/preact.mjs [app-route] (ecmascript)");
;
var r = /[\s\n\\/='"\0<>]/, o = /^(xlink|xmlns|xml)([A-Z])/, i = /^accessK|^auto[A-Z]|^cell|^ch|^col|cont|cross|dateT|encT|form[A-Z]|frame|hrefL|inputM|maxL|minL|noV|playsI|popoverT|readO|rowS|src[A-Z]|tabI|useM|item[A-Z]/, a = /^ac|^ali|arabic|basel|cap|clipPath$|clipRule$|color|dominant|enable|fill|flood|font|glyph[^R]|horiz|image|letter|lighting|marker[^WUH]|overline|panose|pointe|paint|rendering|shape|stop|strikethrough|stroke|text[^L]|transform|underline|unicode|units|^v[^i]|^w|^xH/, c = new Set([
    "draggable",
    "spellcheck"
]), s = /["&<]/;
function l(e) {
    if (0 === e.length || !1 === s.test(e)) return e;
    for(var t = 0, n = 0, r = "", o = ""; n < e.length; n++){
        switch(e.charCodeAt(n)){
            case 34:
                o = "&quot;";
                break;
            case 38:
                o = "&amp;";
                break;
            case 60:
                o = "&lt;";
                break;
            default:
                continue;
        }
        n !== t && (r += e.slice(t, n)), r += o, t = n + 1;
    }
    return n !== t && (r += e.slice(t, n)), r;
}
var u = {}, f = new Set([
    "animation-iteration-count",
    "border-image-outset",
    "border-image-slice",
    "border-image-width",
    "box-flex",
    "box-flex-group",
    "box-ordinal-group",
    "column-count",
    "fill-opacity",
    "flex",
    "flex-grow",
    "flex-negative",
    "flex-order",
    "flex-positive",
    "flex-shrink",
    "flood-opacity",
    "font-weight",
    "grid-column",
    "grid-row",
    "line-clamp",
    "line-height",
    "opacity",
    "order",
    "orphans",
    "stop-opacity",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-width",
    "tab-size",
    "widows",
    "z-index",
    "zoom"
]), p = /[A-Z]/g;
function h(e) {
    var t = "";
    for(var n in e){
        var r = e[n];
        if (null != r && "" !== r) {
            var o = "-" == n[0] ? n : u[n] || (u[n] = n.replace(p, "-$&").toLowerCase()), i = ";";
            "number" != typeof r || o.startsWith("--") || f.has(o) || (i = "px;"), t = t + o + ":" + r + i;
        }
    }
    return t || void 0;
}
function d() {
    this.__d = !0;
}
function _(e, t) {
    return {
        __v: e,
        context: t,
        props: e.props,
        setState: d,
        forceUpdate: d,
        __d: !0,
        __h: new Array(0)
    };
}
function v(e, t, n) {
    if (!e.s) {
        if (n instanceof m) {
            if (!n.s) return void (n.o = v.bind(null, e, t));
            1 & t && (t = n.s), n = n.v;
        }
        if (n && n.then) return void n.then(v.bind(null, e, t), v.bind(null, e, 2));
        e.s = t, e.v = n;
        const r = e.o;
        r && r(e);
    }
}
var m = /*#__PURE__*/ function() {
    function e() {}
    return e.prototype.then = function(t, n) {
        var r = new e, o = this.s;
        if (o) {
            var i = 1 & o ? t : n;
            if (i) {
                try {
                    v(r, 1, i(this.v));
                } catch (e) {
                    v(r, 2, e);
                }
                return r;
            }
            return this;
        }
        return this.o = function(e) {
            try {
                var o = e.v;
                1 & e.s ? v(r, 1, t ? t(o) : o) : n ? v(r, 1, n(o)) : v(r, 2, o);
            } catch (e) {
                v(r, 2, e);
            }
        }, r;
    }, e;
}();
function y(e) {
    return e instanceof m && 1 & e.s;
}
function g(e, t, n) {
    for(var r;;){
        var o = e();
        if (y(o) && (o = o.v), !o) return i;
        if (o.then) {
            r = 0;
            break;
        }
        var i = n();
        if (i && i.then) {
            if (!y(i)) {
                r = 1;
                break;
            }
            i = i.s;
        }
        if (t) {
            var a = t();
            if (a && a.then && !y(a)) {
                r = 2;
                break;
            }
        }
    }
    var c = new m, s = v.bind(null, c, 2);
    return (0 === r ? o.then(u) : 1 === r ? i.then(l) : a.then(f)).then(void 0, s), c;
    //TURBOPACK unreachable
    ;
    function l(r) {
        i = r;
        do {
            if (t && (a = t()) && a.then && !y(a)) return void a.then(f).then(void 0, s);
            if (!(o = e()) || y(o) && !o.v) return void v(c, 1, i);
            if (o.then) return void o.then(u).then(void 0, s);
            y(i = n()) && (i = i.v);
        }while (!i || !i.then)
        i.then(l).then(void 0, s);
    }
    function u(e) {
        e ? (i = n()) && i.then ? i.then(l).then(void 0, s) : l(i) : v(c, 1, i);
    }
    function f() {
        (o = e()) ? o.then ? o.then(u).then(void 0, s) : u(o) : v(c, 1, i);
    }
}
function b(e, t) {
    try {
        var n = e();
    } catch (e) {
        return t(!0, e);
    }
    return n && n.then ? n.then(t.bind(null, !1), t.bind(null, !0)) : t(!1, n);
}
var k, w, x, C, S = function(r, o) {
    try {
        var i = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].__s;
        __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].__s = !0, k = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].__b, w = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].diffed, x = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].__r, C = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].unmount;
        var a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["h"])(__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Fragment"], null);
        return a.__k = [
            r
        ], Promise.resolve(b(function() {
            return Promise.resolve(U(r, o || A, !1, void 0, a, !0, void 0)).then(function(e) {
                var t, n = function() {
                    if (E(e)) {
                        var n = function() {
                            var e = o.join(j);
                            return t = 1, e;
                        }, r = 0, o = e, i = g(function() {
                            return !!o.some(function(e) {
                                return e && "function" == typeof e.then;
                            }) && r++ < 25;
                        }, void 0, function() {
                            return Promise.resolve(Promise.all(o)).then(function(e) {
                                o = e.flat();
                            });
                        });
                        return i && i.then ? i.then(n) : n();
                    }
                }();
                return n && n.then ? n.then(function(n) {
                    return t ? n : e;
                }) : t ? n : e;
            });
        }, function(t, n) {
            if (__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].__c && __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].__c(r, L), __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].__s = i, L.length = 0, t) throw n;
            return n;
        }));
    } catch (e) {
        return Promise.reject(e);
    }
}, A = {}, L = [], E = Array.isArray, T = Object.assign, j = "";
function D(r, o, i) {
    var a = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].__s;
    __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].__s = !0, k = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].__b, w = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].diffed, x = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].__r, C = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].unmount;
    var c = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["h"])(__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Fragment"], null);
    c.__k = [
        r
    ];
    try {
        var s = U(r, o || A, !1, void 0, c, !1, i);
        return E(s) ? s.join(j) : s;
    } catch (e) {
        if (e.then) throw new Error('Use "renderToStringAsync" for suspenseful rendering.');
        throw e;
    } finally{
        __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].__c && __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].__c(r, L), __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].__s = a, L.length = 0;
    }
}
function P(e, t) {
    var n, r = e.type, o = !0;
    return e.__c ? (o = !1, (n = e.__c).state = n.__s) : n = new r(e.props, t), e.__c = n, n.__v = e, n.props = e.props, n.context = t, n.__d = !0, null == n.state && (n.state = A), null == n.__s && (n.__s = n.state), r.getDerivedStateFromProps ? n.state = T({}, n.state, r.getDerivedStateFromProps(n.props, n.state)) : o && n.componentWillMount ? (n.componentWillMount(), n.state = n.__s !== n.state ? n.__s : n.state) : !o && n.componentWillUpdate && n.componentWillUpdate(), x && x(e), n.render(n.props, n.state, t);
}
function U(t, s, u, f, p, d, v) {
    if (null == t || !0 === t || !1 === t || t === j) return j;
    var m = typeof t;
    if ("object" != m) return "function" == m ? j : "string" == m ? l(t) : t + j;
    if (E(t)) {
        var y, g = j;
        p.__k = t;
        for(var b = 0; b < t.length; b++){
            var S = t[b];
            if (null != S && "boolean" != typeof S) {
                var L, D = U(S, s, u, f, p, d, v);
                "string" == typeof D ? g += D : (y || (y = []), g && y.push(g), g = j, E(D) ? (L = y).push.apply(L, D) : y.push(D));
            }
        }
        return y ? (g && y.push(g), y) : g;
    }
    if (void 0 !== t.constructor) return j;
    t.__ = p, k && k(t);
    var F = t.type, M = t.props;
    if ("function" == typeof F) {
        var W, $, z, H = s;
        if (F === __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Fragment"]) {
            if ("tpl" in M) {
                for(var N = j, q = 0; q < M.tpl.length; q++)if (N += M.tpl[q], M.exprs && q < M.exprs.length) {
                    var B = M.exprs[q];
                    if (null == B) continue;
                    "object" != typeof B || void 0 !== B.constructor && !E(B) ? N += B : N += U(B, s, u, f, t, d, v);
                }
                return N;
            }
            if ("UNSTABLE_comment" in M) return "\x3c!--" + l(M.UNSTABLE_comment) + "--\x3e";
            $ = M.children;
        } else {
            if (null != (W = F.contextType)) {
                var I = s[W.__c];
                H = I ? I.props.value : W.__;
            }
            var O = F.prototype && "function" == typeof F.prototype.render;
            if (O) $ = P(t, H), z = t.__c;
            else {
                t.__c = z = _(t, H);
                for(var R = 0; z.__d && R++ < 25;)z.__d = !1, x && x(t), $ = F.call(z, M, H);
                z.__d = !0;
            }
            if (null != z.getChildContext && (s = T({}, s, z.getChildContext())), O && __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].errorBoundaries && (F.getDerivedStateFromError || z.componentDidCatch)) {
                $ = null != $ && $.type === __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Fragment"] && null == $.key && null == $.props.tpl ? $.props.children : $;
                try {
                    return U($, s, u, f, t, d, v);
                } catch (e) {
                    return F.getDerivedStateFromError && (z.__s = F.getDerivedStateFromError(e)), z.componentDidCatch && z.componentDidCatch(e, A), z.__d ? ($ = P(t, s), null != (z = t.__c).getChildContext && (s = T({}, s, z.getChildContext())), U($ = null != $ && $.type === __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Fragment"] && null == $.key && null == $.props.tpl ? $.props.children : $, s, u, f, t, d, v)) : j;
                } finally{
                    w && w(t), t.__ = null, C && C(t);
                }
            }
        }
        $ = null != $ && $.type === __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Fragment"] && null == $.key && null == $.props.tpl ? $.props.children : $;
        try {
            var V = U($, s, u, f, t, d, v);
            return w && w(t), t.__ = null, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].unmount && __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].unmount(t), V;
        } catch (n) {
            if (!d && v && v.onError) {
                var K = v.onError(n, t, function(e) {
                    return U(e, s, u, f, t, d, v);
                });
                if (void 0 !== K) return K;
                var G = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$preact$2f$dist$2f$preact$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["options"].__e;
                return G && G(n, t), j;
            }
            if (!d) throw n;
            if (!n || "function" != typeof n.then) throw n;
            return n.then(function e() {
                try {
                    return U($, s, u, f, t, d, v);
                } catch (n) {
                    if (!n || "function" != typeof n.then) throw n;
                    return n.then(function() {
                        return U($, s, u, f, t, d, v);
                    }, e);
                }
            });
        }
    }
    var J, Q = "<" + F, X = j;
    for(var Y in M){
        var ee = M[Y];
        if ("function" != typeof ee || "class" === Y || "className" === Y) {
            switch(Y){
                case "children":
                    J = ee;
                    continue;
                case "key":
                case "ref":
                case "__self":
                case "__source":
                    continue;
                case "htmlFor":
                    if ("for" in M) continue;
                    Y = "for";
                    break;
                case "className":
                    if ("class" in M) continue;
                    Y = "class";
                    break;
                case "defaultChecked":
                    Y = "checked";
                    break;
                case "defaultSelected":
                    Y = "selected";
                    break;
                case "defaultValue":
                case "value":
                    switch(Y = "value", F){
                        case "textarea":
                            J = ee;
                            continue;
                        case "select":
                            f = ee;
                            continue;
                        case "option":
                            f != ee || "selected" in M || (Q += " selected");
                    }
                    break;
                case "dangerouslySetInnerHTML":
                    X = ee && ee.__html;
                    continue;
                case "style":
                    "object" == typeof ee && (ee = h(ee));
                    break;
                case "acceptCharset":
                    Y = "accept-charset";
                    break;
                case "httpEquiv":
                    Y = "http-equiv";
                    break;
                default:
                    if (o.test(Y)) Y = Y.replace(o, "$1:$2").toLowerCase();
                    else {
                        if (r.test(Y)) continue;
                        "-" !== Y[4] && !c.has(Y) || null == ee ? u ? a.test(Y) && (Y = "panose1" === Y ? "panose-1" : Y.replace(/([A-Z])/g, "-$1").toLowerCase()) : i.test(Y) && (Y = Y.toLowerCase()) : ee += j;
                    }
            }
            null != ee && !1 !== ee && (Q = !0 === ee || ee === j ? Q + " " + Y : Q + " " + Y + '="' + ("string" == typeof ee ? l(ee) : ee + j) + '"');
        }
    }
    if (r.test(F)) throw new Error(F + " is not a valid HTML tag name in " + Q + ">");
    if (X || ("string" == typeof J ? X = l(J) : null != J && !1 !== J && !0 !== J && (X = U(J, s, "svg" === F || "foreignObject" !== F && u, f, t, d, v))), w && w(t), t.__ = null, C && C(t), !X && Z.has(F)) return Q + "/>";
    var te = "</" + F + ">", ne = Q + ">";
    return E(X) ? [
        ne
    ].concat(X, [
        te
    ]) : "string" != typeof X ? [
        ne,
        X,
        te
    ] : ne + X + te;
}
var Z = new Set([
    "area",
    "base",
    "br",
    "col",
    "command",
    "embed",
    "hr",
    "img",
    "input",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
]), F = D, M = D;
const __TURBOPACK__default__export__ = D;
;
 //# sourceMappingURL=index.module.js.map
}),
"[project]/align/node_modules/oauth4webapi/build/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AUTHORIZATION_RESPONSE_ERROR",
    ()=>AUTHORIZATION_RESPONSE_ERROR,
    "AuthorizationResponseError",
    ()=>AuthorizationResponseError,
    "ClientSecretBasic",
    ()=>ClientSecretBasic,
    "ClientSecretJwt",
    ()=>ClientSecretJwt,
    "ClientSecretPost",
    ()=>ClientSecretPost,
    "DPoP",
    ()=>DPoP,
    "HTTP_REQUEST_FORBIDDEN",
    ()=>HTTP_REQUEST_FORBIDDEN,
    "INVALID_REQUEST",
    ()=>INVALID_REQUEST,
    "INVALID_RESPONSE",
    ()=>INVALID_RESPONSE,
    "INVALID_SERVER_METADATA",
    ()=>INVALID_SERVER_METADATA,
    "JSON_ATTRIBUTE_COMPARISON",
    ()=>JSON_ATTRIBUTE_COMPARISON,
    "JWT_CLAIM_COMPARISON",
    ()=>JWT_CLAIM_COMPARISON,
    "JWT_TIMESTAMP_CHECK",
    ()=>JWT_TIMESTAMP_CHECK,
    "JWT_USERINFO_EXPECTED",
    ()=>JWT_USERINFO_EXPECTED,
    "KEY_SELECTION",
    ()=>KEY_SELECTION,
    "MISSING_SERVER_METADATA",
    ()=>MISSING_SERVER_METADATA,
    "None",
    ()=>None,
    "OperationProcessingError",
    ()=>OperationProcessingError,
    "PARSE_ERROR",
    ()=>PARSE_ERROR,
    "PrivateKeyJwt",
    ()=>PrivateKeyJwt,
    "REQUEST_PROTOCOL_FORBIDDEN",
    ()=>REQUEST_PROTOCOL_FORBIDDEN,
    "RESPONSE_BODY_ERROR",
    ()=>RESPONSE_BODY_ERROR,
    "RESPONSE_IS_NOT_CONFORM",
    ()=>RESPONSE_IS_NOT_CONFORM,
    "RESPONSE_IS_NOT_JSON",
    ()=>RESPONSE_IS_NOT_JSON,
    "ResponseBodyError",
    ()=>ResponseBodyError,
    "TlsClientAuth",
    ()=>TlsClientAuth,
    "UNSUPPORTED_OPERATION",
    ()=>UNSUPPORTED_OPERATION,
    "UnsupportedOperationError",
    ()=>UnsupportedOperationError,
    "WWWAuthenticateChallengeError",
    ()=>WWWAuthenticateChallengeError,
    "WWW_AUTHENTICATE_CHALLENGE",
    ()=>WWW_AUTHENTICATE_CHALLENGE,
    "_expectedIssuer",
    ()=>_expectedIssuer,
    "_nodiscoverycheck",
    ()=>_nodiscoverycheck,
    "_nopkce",
    ()=>_nopkce,
    "allowInsecureRequests",
    ()=>allowInsecureRequests,
    "authorizationCodeGrantRequest",
    ()=>authorizationCodeGrantRequest,
    "backchannelAuthenticationGrantRequest",
    ()=>backchannelAuthenticationGrantRequest,
    "backchannelAuthenticationRequest",
    ()=>backchannelAuthenticationRequest,
    "calculatePKCECodeChallenge",
    ()=>calculatePKCECodeChallenge,
    "checkProtocol",
    ()=>checkProtocol,
    "clientCredentialsGrantRequest",
    ()=>clientCredentialsGrantRequest,
    "clockSkew",
    ()=>clockSkew,
    "clockTolerance",
    ()=>clockTolerance,
    "customFetch",
    ()=>customFetch,
    "deviceAuthorizationRequest",
    ()=>deviceAuthorizationRequest,
    "deviceCodeGrantRequest",
    ()=>deviceCodeGrantRequest,
    "discoveryRequest",
    ()=>discoveryRequest,
    "dynamicClientRegistrationRequest",
    ()=>dynamicClientRegistrationRequest,
    "expectNoNonce",
    ()=>expectNoNonce,
    "expectNoState",
    ()=>expectNoState,
    "formPostResponse",
    ()=>formPostResponse,
    "generateKeyPair",
    ()=>generateKeyPair,
    "generateRandomCodeVerifier",
    ()=>generateRandomCodeVerifier,
    "generateRandomNonce",
    ()=>generateRandomNonce,
    "generateRandomState",
    ()=>generateRandomState,
    "genericTokenEndpointRequest",
    ()=>genericTokenEndpointRequest,
    "getContentType",
    ()=>getContentType,
    "getValidatedIdTokenClaims",
    ()=>getValidatedIdTokenClaims,
    "introspectionRequest",
    ()=>introspectionRequest,
    "isDPoPNonceError",
    ()=>isDPoPNonceError,
    "issueRequestObject",
    ()=>issueRequestObject,
    "jweDecrypt",
    ()=>jweDecrypt,
    "jwksCache",
    ()=>jwksCache,
    "modifyAssertion",
    ()=>modifyAssertion,
    "nopkce",
    ()=>nopkce,
    "processAuthorizationCodeResponse",
    ()=>processAuthorizationCodeResponse,
    "processBackchannelAuthenticationGrantResponse",
    ()=>processBackchannelAuthenticationGrantResponse,
    "processBackchannelAuthenticationResponse",
    ()=>processBackchannelAuthenticationResponse,
    "processClientCredentialsResponse",
    ()=>processClientCredentialsResponse,
    "processDeviceAuthorizationResponse",
    ()=>processDeviceAuthorizationResponse,
    "processDeviceCodeResponse",
    ()=>processDeviceCodeResponse,
    "processDiscoveryResponse",
    ()=>processDiscoveryResponse,
    "processDynamicClientRegistrationResponse",
    ()=>processDynamicClientRegistrationResponse,
    "processGenericTokenEndpointResponse",
    ()=>processGenericTokenEndpointResponse,
    "processIntrospectionResponse",
    ()=>processIntrospectionResponse,
    "processPushedAuthorizationResponse",
    ()=>processPushedAuthorizationResponse,
    "processRefreshTokenResponse",
    ()=>processRefreshTokenResponse,
    "processResourceDiscoveryResponse",
    ()=>processResourceDiscoveryResponse,
    "processRevocationResponse",
    ()=>processRevocationResponse,
    "processUserInfoResponse",
    ()=>processUserInfoResponse,
    "protectedResourceRequest",
    ()=>protectedResourceRequest,
    "pushedAuthorizationRequest",
    ()=>pushedAuthorizationRequest,
    "refreshTokenGrantRequest",
    ()=>refreshTokenGrantRequest,
    "resolveEndpoint",
    ()=>resolveEndpoint,
    "resourceDiscoveryRequest",
    ()=>resourceDiscoveryRequest,
    "revocationRequest",
    ()=>revocationRequest,
    "skipAuthTimeCheck",
    ()=>skipAuthTimeCheck,
    "skipStateCheck",
    ()=>skipStateCheck,
    "skipSubjectCheck",
    ()=>skipSubjectCheck,
    "userInfoRequest",
    ()=>userInfoRequest,
    "validateApplicationLevelSignature",
    ()=>validateApplicationLevelSignature,
    "validateAuthResponse",
    ()=>validateAuthResponse,
    "validateCodeIdTokenResponse",
    ()=>validateCodeIdTokenResponse,
    "validateDetachedSignatureResponse",
    ()=>validateDetachedSignatureResponse,
    "validateJwtAccessToken",
    ()=>validateJwtAccessToken,
    "validateJwtAuthResponse",
    ()=>validateJwtAuthResponse
]);
let USER_AGENT;
if (typeof navigator === 'undefined' || !navigator.userAgent?.startsWith?.('Mozilla/5.0 ')) {
    const NAME = 'oauth4webapi';
    const VERSION = 'v3.8.3';
    USER_AGENT = `${NAME}/${VERSION}`;
}
function looseInstanceOf(input, expected) {
    if (input == null) {
        return false;
    }
    try {
        return input instanceof expected || Object.getPrototypeOf(input)[Symbol.toStringTag] === expected.prototype[Symbol.toStringTag];
    } catch  {
        return false;
    }
}
const ERR_INVALID_ARG_VALUE = 'ERR_INVALID_ARG_VALUE';
const ERR_INVALID_ARG_TYPE = 'ERR_INVALID_ARG_TYPE';
function CodedTypeError(message, code, cause) {
    const err = new TypeError(message, {
        cause
    });
    Object.assign(err, {
        code
    });
    return err;
}
const allowInsecureRequests = Symbol();
const clockSkew = Symbol();
const clockTolerance = Symbol();
const customFetch = Symbol();
const modifyAssertion = Symbol();
const jweDecrypt = Symbol();
const jwksCache = Symbol();
const encoder = new TextEncoder();
const decoder = new TextDecoder();
function buf(input) {
    if (typeof input === 'string') {
        return encoder.encode(input);
    }
    return decoder.decode(input);
}
let encodeBase64Url;
if (Uint8Array.prototype.toBase64) {
    encodeBase64Url = (input)=>{
        if (input instanceof ArrayBuffer) {
            input = new Uint8Array(input);
        }
        return input.toBase64({
            alphabet: 'base64url',
            omitPadding: true
        });
    };
} else {
    const CHUNK_SIZE = 0x8000;
    encodeBase64Url = (input)=>{
        if (input instanceof ArrayBuffer) {
            input = new Uint8Array(input);
        }
        const arr = [];
        for(let i = 0; i < input.byteLength; i += CHUNK_SIZE){
            arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));
        }
        return btoa(arr.join('')).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
    };
}
let decodeBase64Url;
if (Uint8Array.fromBase64) {
    decodeBase64Url = (input)=>{
        try {
            return Uint8Array.fromBase64(input, {
                alphabet: 'base64url'
            });
        } catch (cause) {
            throw CodedTypeError('The input to be decoded is not correctly encoded.', ERR_INVALID_ARG_VALUE, cause);
        }
    };
} else {
    decodeBase64Url = (input)=>{
        try {
            const binary = atob(input.replace(/-/g, '+').replace(/_/g, '/').replace(/\s/g, ''));
            const bytes = new Uint8Array(binary.length);
            for(let i = 0; i < binary.length; i++){
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes;
        } catch (cause) {
            throw CodedTypeError('The input to be decoded is not correctly encoded.', ERR_INVALID_ARG_VALUE, cause);
        }
    };
}
function b64u(input) {
    if (typeof input === 'string') {
        return decodeBase64Url(input);
    }
    return encodeBase64Url(input);
}
class UnsupportedOperationError extends Error {
    code;
    constructor(message, options){
        super(message, options);
        this.name = this.constructor.name;
        this.code = UNSUPPORTED_OPERATION;
        Error.captureStackTrace?.(this, this.constructor);
    }
}
class OperationProcessingError extends Error {
    code;
    constructor(message, options){
        super(message, options);
        this.name = this.constructor.name;
        if (options?.code) {
            this.code = options?.code;
        }
        Error.captureStackTrace?.(this, this.constructor);
    }
}
function OPE(message, code, cause) {
    return new OperationProcessingError(message, {
        code,
        cause
    });
}
async function calculateJwkThumbprint(jwk) {
    let components;
    switch(jwk.kty){
        case 'EC':
            components = {
                crv: jwk.crv,
                kty: jwk.kty,
                x: jwk.x,
                y: jwk.y
            };
            break;
        case 'OKP':
            components = {
                crv: jwk.crv,
                kty: jwk.kty,
                x: jwk.x
            };
            break;
        case 'AKP':
            components = {
                alg: jwk.alg,
                kty: jwk.kty,
                pub: jwk.pub
            };
            break;
        case 'RSA':
            components = {
                e: jwk.e,
                kty: jwk.kty,
                n: jwk.n
            };
            break;
        default:
            throw new UnsupportedOperationError('unsupported JWK key type', {
                cause: jwk
            });
    }
    return b64u(await crypto.subtle.digest('SHA-256', buf(JSON.stringify(components))));
}
function assertCryptoKey(key, it) {
    if (!(key instanceof CryptoKey)) {
        throw CodedTypeError(`${it} must be a CryptoKey`, ERR_INVALID_ARG_TYPE);
    }
}
function assertPrivateKey(key, it) {
    assertCryptoKey(key, it);
    if (key.type !== 'private') {
        throw CodedTypeError(`${it} must be a private CryptoKey`, ERR_INVALID_ARG_VALUE);
    }
}
function assertPublicKey(key, it) {
    assertCryptoKey(key, it);
    if (key.type !== 'public') {
        throw CodedTypeError(`${it} must be a public CryptoKey`, ERR_INVALID_ARG_VALUE);
    }
}
function normalizeTyp(value) {
    return value.toLowerCase().replace(/^application\//, '');
}
function isJsonObject(input) {
    if (input === null || typeof input !== 'object' || Array.isArray(input)) {
        return false;
    }
    return true;
}
function prepareHeaders(input) {
    if (looseInstanceOf(input, Headers)) {
        input = Object.fromEntries(input.entries());
    }
    const headers = new Headers(input ?? {});
    if (USER_AGENT && !headers.has('user-agent')) {
        headers.set('user-agent', USER_AGENT);
    }
    if (headers.has('authorization')) {
        throw CodedTypeError('"options.headers" must not include the "authorization" header name', ERR_INVALID_ARG_VALUE);
    }
    return headers;
}
function signal(url, value) {
    if (value !== undefined) {
        if (typeof value === 'function') {
            value = value(url.href);
        }
        if (!(value instanceof AbortSignal)) {
            throw CodedTypeError('"options.signal" must return or be an instance of AbortSignal', ERR_INVALID_ARG_TYPE);
        }
        return value;
    }
    return undefined;
}
function replaceDoubleSlash(pathname) {
    if (pathname.includes('//')) {
        return pathname.replace('//', '/');
    }
    return pathname;
}
function prependWellKnown(url, wellKnown, allowTerminatingSlash = false) {
    if (url.pathname === '/') {
        url.pathname = wellKnown;
    } else {
        url.pathname = replaceDoubleSlash(`${wellKnown}/${allowTerminatingSlash ? url.pathname : url.pathname.replace(/(\/)$/, '')}`);
    }
    return url;
}
function appendWellKnown(url, wellKnown) {
    url.pathname = replaceDoubleSlash(`${url.pathname}/${wellKnown}`);
    return url;
}
async function performDiscovery(input, urlName, transform, options) {
    if (!(input instanceof URL)) {
        throw CodedTypeError(`"${urlName}" must be an instance of URL`, ERR_INVALID_ARG_TYPE);
    }
    checkProtocol(input, options?.[allowInsecureRequests] !== true);
    const url = transform(new URL(input.href));
    const headers = prepareHeaders(options?.headers);
    headers.set('accept', 'application/json');
    return (options?.[customFetch] || fetch)(url.href, {
        body: undefined,
        headers: Object.fromEntries(headers.entries()),
        method: 'GET',
        redirect: 'manual',
        signal: signal(url, options?.signal)
    });
}
async function discoveryRequest(issuerIdentifier, options) {
    return performDiscovery(issuerIdentifier, 'issuerIdentifier', (url)=>{
        switch(options?.algorithm){
            case undefined:
            case 'oidc':
                appendWellKnown(url, '.well-known/openid-configuration');
                break;
            case 'oauth2':
                prependWellKnown(url, '.well-known/oauth-authorization-server');
                break;
            default:
                throw CodedTypeError('"options.algorithm" must be "oidc" (default), or "oauth2"', ERR_INVALID_ARG_VALUE);
        }
        return url;
    }, options);
}
function assertNumber(input, allow0, it, code, cause) {
    try {
        if (typeof input !== 'number' || !Number.isFinite(input)) {
            throw CodedTypeError(`${it} must be a number`, ERR_INVALID_ARG_TYPE, cause);
        }
        if (input > 0) return;
        if (allow0) {
            if (input !== 0) {
                throw CodedTypeError(`${it} must be a non-negative number`, ERR_INVALID_ARG_VALUE, cause);
            }
            return;
        }
        throw CodedTypeError(`${it} must be a positive number`, ERR_INVALID_ARG_VALUE, cause);
    } catch (err) {
        if (code) {
            throw OPE(err.message, code, cause);
        }
        throw err;
    }
}
function assertString(input, it, code, cause) {
    try {
        if (typeof input !== 'string') {
            throw CodedTypeError(`${it} must be a string`, ERR_INVALID_ARG_TYPE, cause);
        }
        if (input.length === 0) {
            throw CodedTypeError(`${it} must not be empty`, ERR_INVALID_ARG_VALUE, cause);
        }
    } catch (err) {
        if (code) {
            throw OPE(err.message, code, cause);
        }
        throw err;
    }
}
async function processDiscoveryResponse(expectedIssuerIdentifier, response) {
    const expected = expectedIssuerIdentifier;
    if (!(expected instanceof URL) && expected !== _nodiscoverycheck) {
        throw CodedTypeError('"expectedIssuerIdentifier" must be an instance of URL', ERR_INVALID_ARG_TYPE);
    }
    if (!looseInstanceOf(response, Response)) {
        throw CodedTypeError('"response" must be an instance of Response', ERR_INVALID_ARG_TYPE);
    }
    if (response.status !== 200) {
        throw OPE('"response" is not a conform Authorization Server Metadata response (unexpected HTTP status code)', RESPONSE_IS_NOT_CONFORM, response);
    }
    assertReadableResponse(response);
    const json = await getResponseJsonBody(response);
    assertString(json.issuer, '"response" body "issuer" property', INVALID_RESPONSE, {
        body: json
    });
    if (expected !== _nodiscoverycheck && new URL(json.issuer).href !== expected.href) {
        throw OPE('"response" body "issuer" property does not match the expected value', JSON_ATTRIBUTE_COMPARISON, {
            expected: expected.href,
            body: json,
            attribute: 'issuer'
        });
    }
    return json;
}
function assertApplicationJson(response) {
    assertContentType(response, 'application/json');
}
function notJson(response, ...types) {
    let msg = '"response" content-type must be ';
    if (types.length > 2) {
        const last = types.pop();
        msg += `${types.join(', ')}, or ${last}`;
    } else if (types.length === 2) {
        msg += `${types[0]} or ${types[1]}`;
    } else {
        msg += types[0];
    }
    return OPE(msg, RESPONSE_IS_NOT_JSON, response);
}
function assertContentTypes(response, ...types) {
    if (!types.includes(getContentType(response))) {
        throw notJson(response, ...types);
    }
}
function assertContentType(response, contentType) {
    if (getContentType(response) !== contentType) {
        throw notJson(response, contentType);
    }
}
function randomBytes() {
    return b64u(crypto.getRandomValues(new Uint8Array(32)));
}
function generateRandomCodeVerifier() {
    return randomBytes();
}
function generateRandomState() {
    return randomBytes();
}
function generateRandomNonce() {
    return randomBytes();
}
async function calculatePKCECodeChallenge(codeVerifier) {
    assertString(codeVerifier, 'codeVerifier');
    return b64u(await crypto.subtle.digest('SHA-256', buf(codeVerifier)));
}
function getKeyAndKid(input) {
    if (input instanceof CryptoKey) {
        return {
            key: input
        };
    }
    if (!(input?.key instanceof CryptoKey)) {
        return {};
    }
    if (input.kid !== undefined) {
        assertString(input.kid, '"kid"');
    }
    return {
        key: input.key,
        kid: input.kid
    };
}
function psAlg(key) {
    switch(key.algorithm.hash.name){
        case 'SHA-256':
            return 'PS256';
        case 'SHA-384':
            return 'PS384';
        case 'SHA-512':
            return 'PS512';
        default:
            throw new UnsupportedOperationError('unsupported RsaHashedKeyAlgorithm hash name', {
                cause: key
            });
    }
}
function rsAlg(key) {
    switch(key.algorithm.hash.name){
        case 'SHA-256':
            return 'RS256';
        case 'SHA-384':
            return 'RS384';
        case 'SHA-512':
            return 'RS512';
        default:
            throw new UnsupportedOperationError('unsupported RsaHashedKeyAlgorithm hash name', {
                cause: key
            });
    }
}
function esAlg(key) {
    switch(key.algorithm.namedCurve){
        case 'P-256':
            return 'ES256';
        case 'P-384':
            return 'ES384';
        case 'P-521':
            return 'ES512';
        default:
            throw new UnsupportedOperationError('unsupported EcKeyAlgorithm namedCurve', {
                cause: key
            });
    }
}
function keyToJws(key) {
    switch(key.algorithm.name){
        case 'RSA-PSS':
            return psAlg(key);
        case 'RSASSA-PKCS1-v1_5':
            return rsAlg(key);
        case 'ECDSA':
            return esAlg(key);
        case 'Ed25519':
        case 'ML-DSA-44':
        case 'ML-DSA-65':
        case 'ML-DSA-87':
            return key.algorithm.name;
        case 'EdDSA':
            return 'Ed25519';
        default:
            throw new UnsupportedOperationError('unsupported CryptoKey algorithm name', {
                cause: key
            });
    }
}
function getClockSkew(client) {
    const skew = client?.[clockSkew];
    return typeof skew === 'number' && Number.isFinite(skew) ? skew : 0;
}
function getClockTolerance(client) {
    const tolerance = client?.[clockTolerance];
    return typeof tolerance === 'number' && Number.isFinite(tolerance) && Math.sign(tolerance) !== -1 ? tolerance : 30;
}
function epochTime() {
    return Math.floor(Date.now() / 1000);
}
function assertAs(as) {
    if (typeof as !== 'object' || as === null) {
        throw CodedTypeError('"as" must be an object', ERR_INVALID_ARG_TYPE);
    }
    assertString(as.issuer, '"as.issuer"');
}
function assertClient(client) {
    if (typeof client !== 'object' || client === null) {
        throw CodedTypeError('"client" must be an object', ERR_INVALID_ARG_TYPE);
    }
    assertString(client.client_id, '"client.client_id"');
}
function formUrlEncode(token) {
    return encodeURIComponent(token).replace(/(?:[-_.!~*'()]|%20)/g, (substring)=>{
        switch(substring){
            case '-':
            case '_':
            case '.':
            case '!':
            case '~':
            case '*':
            case "'":
            case '(':
            case ')':
                return `%${substring.charCodeAt(0).toString(16).toUpperCase()}`;
            case '%20':
                return '+';
            default:
                throw new Error();
        }
    });
}
function ClientSecretPost(clientSecret) {
    assertString(clientSecret, '"clientSecret"');
    return (_as, client, body, _headers)=>{
        body.set('client_id', client.client_id);
        body.set('client_secret', clientSecret);
    };
}
function ClientSecretBasic(clientSecret) {
    assertString(clientSecret, '"clientSecret"');
    return (_as, client, _body, headers)=>{
        const username = formUrlEncode(client.client_id);
        const password = formUrlEncode(clientSecret);
        const credentials = btoa(`${username}:${password}`);
        headers.set('authorization', `Basic ${credentials}`);
    };
}
function clientAssertionPayload(as, client) {
    const now = epochTime() + getClockSkew(client);
    return {
        jti: randomBytes(),
        aud: as.issuer,
        exp: now + 60,
        iat: now,
        nbf: now,
        iss: client.client_id,
        sub: client.client_id
    };
}
function PrivateKeyJwt(clientPrivateKey, options) {
    const { key, kid } = getKeyAndKid(clientPrivateKey);
    assertPrivateKey(key, '"clientPrivateKey.key"');
    return async (as, client, body, _headers)=>{
        const header = {
            alg: keyToJws(key),
            kid
        };
        const payload = clientAssertionPayload(as, client);
        options?.[modifyAssertion]?.(header, payload);
        body.set('client_id', client.client_id);
        body.set('client_assertion_type', 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer');
        body.set('client_assertion', await signJwt(header, payload, key));
    };
}
function ClientSecretJwt(clientSecret, options) {
    assertString(clientSecret, '"clientSecret"');
    const modify = options?.[modifyAssertion];
    let key;
    return async (as, client, body, _headers)=>{
        key ||= await crypto.subtle.importKey('raw', buf(clientSecret), {
            hash: 'SHA-256',
            name: 'HMAC'
        }, false, [
            'sign'
        ]);
        const header = {
            alg: 'HS256'
        };
        const payload = clientAssertionPayload(as, client);
        modify?.(header, payload);
        const data = `${b64u(buf(JSON.stringify(header)))}.${b64u(buf(JSON.stringify(payload)))}`;
        const hmac = await crypto.subtle.sign(key.algorithm, key, buf(data));
        body.set('client_id', client.client_id);
        body.set('client_assertion_type', 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer');
        body.set('client_assertion', `${data}.${b64u(new Uint8Array(hmac))}`);
    };
}
function None() {
    return (_as, client, body, _headers)=>{
        body.set('client_id', client.client_id);
    };
}
function TlsClientAuth() {
    return None();
}
async function signJwt(header, payload, key) {
    if (!key.usages.includes('sign')) {
        throw CodedTypeError('CryptoKey instances used for signing assertions must include "sign" in their "usages"', ERR_INVALID_ARG_VALUE);
    }
    const input = `${b64u(buf(JSON.stringify(header)))}.${b64u(buf(JSON.stringify(payload)))}`;
    const signature = b64u(await crypto.subtle.sign(keyToSubtle(key), key, buf(input)));
    return `${input}.${signature}`;
}
async function issueRequestObject(as, client, parameters, privateKey, options) {
    assertAs(as);
    assertClient(client);
    parameters = new URLSearchParams(parameters);
    const { key, kid } = getKeyAndKid(privateKey);
    assertPrivateKey(key, '"privateKey.key"');
    parameters.set('client_id', client.client_id);
    const now = epochTime() + getClockSkew(client);
    const claims = {
        ...Object.fromEntries(parameters.entries()),
        jti: randomBytes(),
        aud: as.issuer,
        exp: now + 60,
        iat: now,
        nbf: now,
        iss: client.client_id
    };
    let resource;
    if (parameters.has('resource') && (resource = parameters.getAll('resource')) && resource.length > 1) {
        claims.resource = resource;
    }
    {
        let value = parameters.get('max_age');
        if (value !== null) {
            claims.max_age = parseInt(value, 10);
            assertNumber(claims.max_age, true, '"max_age" parameter');
        }
    }
    {
        let value = parameters.get('claims');
        if (value !== null) {
            try {
                claims.claims = JSON.parse(value);
            } catch (cause) {
                throw OPE('failed to parse the "claims" parameter as JSON', PARSE_ERROR, cause);
            }
            if (!isJsonObject(claims.claims)) {
                throw CodedTypeError('"claims" parameter must be a JSON with a top level object', ERR_INVALID_ARG_VALUE);
            }
        }
    }
    {
        let value = parameters.get('authorization_details');
        if (value !== null) {
            try {
                claims.authorization_details = JSON.parse(value);
            } catch (cause) {
                throw OPE('failed to parse the "authorization_details" parameter as JSON', PARSE_ERROR, cause);
            }
            if (!Array.isArray(claims.authorization_details)) {
                throw CodedTypeError('"authorization_details" parameter must be a JSON with a top level array', ERR_INVALID_ARG_VALUE);
            }
        }
    }
    const header = {
        alg: keyToJws(key),
        typ: 'oauth-authz-req+jwt',
        kid
    };
    options?.[modifyAssertion]?.(header, claims);
    return signJwt(header, claims, key);
}
let jwkCache;
async function getSetPublicJwkCache(key, alg) {
    const { kty, e, n, x, y, crv, pub } = await crypto.subtle.exportKey('jwk', key);
    const jwk = {
        kty,
        e,
        n,
        x,
        y,
        crv,
        pub
    };
    if (kty === 'AKP') jwk.alg = alg;
    jwkCache.set(key, jwk);
    return jwk;
}
async function publicJwk(key, alg) {
    jwkCache ||= new WeakMap();
    return jwkCache.get(key) || getSetPublicJwkCache(key, alg);
}
const URLParse = URL.parse ? (url, base)=>URL.parse(url, base) : (url, base)=>{
    try {
        return new URL(url, base);
    } catch  {
        return null;
    }
};
function checkProtocol(url, enforceHttps) {
    if (enforceHttps && url.protocol !== 'https:') {
        throw OPE('only requests to HTTPS are allowed', HTTP_REQUEST_FORBIDDEN, url);
    }
    if (url.protocol !== 'https:' && url.protocol !== 'http:') {
        throw OPE('only HTTP and HTTPS requests are allowed', REQUEST_PROTOCOL_FORBIDDEN, url);
    }
}
function validateEndpoint(value, endpoint, useMtlsAlias, enforceHttps) {
    let url;
    if (typeof value !== 'string' || !(url = URLParse(value))) {
        throw OPE(`authorization server metadata does not contain a valid ${useMtlsAlias ? `"as.mtls_endpoint_aliases.${endpoint}"` : `"as.${endpoint}"`}`, value === undefined ? MISSING_SERVER_METADATA : INVALID_SERVER_METADATA, {
            attribute: useMtlsAlias ? `mtls_endpoint_aliases.${endpoint}` : endpoint
        });
    }
    checkProtocol(url, enforceHttps);
    return url;
}
function resolveEndpoint(as, endpoint, useMtlsAlias, enforceHttps) {
    if (useMtlsAlias && as.mtls_endpoint_aliases && endpoint in as.mtls_endpoint_aliases) {
        return validateEndpoint(as.mtls_endpoint_aliases[endpoint], endpoint, useMtlsAlias, enforceHttps);
    }
    return validateEndpoint(as[endpoint], endpoint, useMtlsAlias, enforceHttps);
}
async function pushedAuthorizationRequest(as, client, clientAuthentication, parameters, options) {
    assertAs(as);
    assertClient(client);
    const url = resolveEndpoint(as, 'pushed_authorization_request_endpoint', client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);
    const body = new URLSearchParams(parameters);
    body.set('client_id', client.client_id);
    const headers = prepareHeaders(options?.headers);
    headers.set('accept', 'application/json');
    if (options?.DPoP !== undefined) {
        assertDPoP(options.DPoP);
        await options.DPoP.addProof(url, headers, 'POST');
    }
    const response = await authenticatedRequest(as, client, clientAuthentication, url, body, headers, options);
    options?.DPoP?.cacheNonce(response, url);
    return response;
}
class DPoPHandler {
    #header;
    #privateKey;
    #publicKey;
    #clockSkew;
    #modifyAssertion;
    #map;
    #jkt;
    constructor(client, keyPair, options){
        assertPrivateKey(keyPair?.privateKey, '"DPoP.privateKey"');
        assertPublicKey(keyPair?.publicKey, '"DPoP.publicKey"');
        if (!keyPair.publicKey.extractable) {
            throw CodedTypeError('"DPoP.publicKey.extractable" must be true', ERR_INVALID_ARG_VALUE);
        }
        this.#modifyAssertion = options?.[modifyAssertion];
        this.#clockSkew = getClockSkew(client);
        this.#privateKey = keyPair.privateKey;
        this.#publicKey = keyPair.publicKey;
        branded.add(this);
    }
    #get(key) {
        this.#map ||= new Map();
        let item = this.#map.get(key);
        if (item) {
            this.#map.delete(key);
            this.#map.set(key, item);
        }
        return item;
    }
    #set(key, val) {
        this.#map ||= new Map();
        this.#map.delete(key);
        if (this.#map.size === 100) {
            this.#map.delete(this.#map.keys().next().value);
        }
        this.#map.set(key, val);
    }
    async calculateThumbprint() {
        if (!this.#jkt) {
            const jwk = await crypto.subtle.exportKey('jwk', this.#publicKey);
            this.#jkt ||= await calculateJwkThumbprint(jwk);
        }
        return this.#jkt;
    }
    async addProof(url, headers, htm, accessToken) {
        const alg = keyToJws(this.#privateKey);
        this.#header ||= {
            alg,
            typ: 'dpop+jwt',
            jwk: await publicJwk(this.#publicKey, alg)
        };
        const nonce = this.#get(url.origin);
        const now = epochTime() + this.#clockSkew;
        const payload = {
            iat: now,
            jti: randomBytes(),
            htm,
            nonce,
            htu: `${url.origin}${url.pathname}`,
            ath: accessToken ? b64u(await crypto.subtle.digest('SHA-256', buf(accessToken))) : undefined
        };
        this.#modifyAssertion?.(this.#header, payload);
        headers.set('dpop', await signJwt(this.#header, payload, this.#privateKey));
    }
    cacheNonce(response, url) {
        try {
            const nonce = response.headers.get('dpop-nonce');
            if (nonce) {
                this.#set(url.origin, nonce);
            }
        } catch  {}
    }
}
function isDPoPNonceError(err) {
    if (err instanceof WWWAuthenticateChallengeError) {
        const { 0: challenge, length } = err.cause;
        return length === 1 && challenge.scheme === 'dpop' && challenge.parameters.error === 'use_dpop_nonce';
    }
    if (err instanceof ResponseBodyError) {
        return err.error === 'use_dpop_nonce';
    }
    return false;
}
function DPoP(client, keyPair, options) {
    return new DPoPHandler(client, keyPair, options);
}
class ResponseBodyError extends Error {
    cause;
    code;
    error;
    status;
    error_description;
    response;
    constructor(message, options){
        super(message, options);
        this.name = this.constructor.name;
        this.code = RESPONSE_BODY_ERROR;
        this.cause = options.cause;
        this.error = options.cause.error;
        this.status = options.response.status;
        this.error_description = options.cause.error_description;
        Object.defineProperty(this, 'response', {
            enumerable: false,
            value: options.response
        });
        Error.captureStackTrace?.(this, this.constructor);
    }
}
class AuthorizationResponseError extends Error {
    cause;
    code;
    error;
    error_description;
    constructor(message, options){
        super(message, options);
        this.name = this.constructor.name;
        this.code = AUTHORIZATION_RESPONSE_ERROR;
        this.cause = options.cause;
        this.error = options.cause.get('error');
        this.error_description = options.cause.get('error_description') ?? undefined;
        Error.captureStackTrace?.(this, this.constructor);
    }
}
class WWWAuthenticateChallengeError extends Error {
    cause;
    code;
    response;
    status;
    constructor(message, options){
        super(message, options);
        this.name = this.constructor.name;
        this.code = WWW_AUTHENTICATE_CHALLENGE;
        this.cause = options.cause;
        this.status = options.response.status;
        this.response = options.response;
        Object.defineProperty(this, 'response', {
            enumerable: false
        });
        Error.captureStackTrace?.(this, this.constructor);
    }
}
const tokenMatch = "[a-zA-Z0-9!#$%&\\'\\*\\+\\-\\.\\^_`\\|~]+";
const token68Match = '[a-zA-Z0-9\\-\\._\\~\\+\\/]+={0,2}';
const quotedMatch = '"((?:[^"\\\\]|\\\\[\\s\\S])*)"';
const quotedParamMatcher = '(' + tokenMatch + ')\\s*=\\s*' + quotedMatch;
const paramMatcher = '(' + tokenMatch + ')\\s*=\\s*(' + tokenMatch + ')';
const schemeRE = new RegExp('^[,\\s]*(' + tokenMatch + ')');
const quotedParamRE = new RegExp('^[,\\s]*' + quotedParamMatcher + '[,\\s]*(.*)');
const unquotedParamRE = new RegExp('^[,\\s]*' + paramMatcher + '[,\\s]*(.*)');
const token68ParamRE = new RegExp('^(' + token68Match + ')(?:$|[,\\s])(.*)');
function parseWwwAuthenticateChallenges(response) {
    if (!looseInstanceOf(response, Response)) {
        throw CodedTypeError('"response" must be an instance of Response', ERR_INVALID_ARG_TYPE);
    }
    const header = response.headers.get('www-authenticate');
    if (header === null) {
        return undefined;
    }
    const challenges = [];
    let rest = header;
    while(rest){
        let match = rest.match(schemeRE);
        const scheme = match?.['1'].toLowerCase();
        if (!scheme) {
            return undefined;
        }
        const afterScheme = rest.substring(match[0].length);
        if (afterScheme && !afterScheme.match(/^[\s,]/)) {
            return undefined;
        }
        const spaceMatch = afterScheme.match(/^\s+(.*)$/);
        const hasParameters = !!spaceMatch;
        rest = spaceMatch ? spaceMatch[1] : undefined;
        const parameters = {};
        let token68;
        if (hasParameters) {
            while(rest){
                let key;
                let value;
                if (match = rest.match(quotedParamRE)) {
                    ;
                    [, key, value, rest] = match;
                    if (value.includes('\\')) {
                        try {
                            value = JSON.parse(`"${value}"`);
                        } catch  {}
                    }
                    parameters[key.toLowerCase()] = value;
                    continue;
                }
                if (match = rest.match(unquotedParamRE)) {
                    ;
                    [, key, value, rest] = match;
                    parameters[key.toLowerCase()] = value;
                    continue;
                }
                if (match = rest.match(token68ParamRE)) {
                    if (Object.keys(parameters).length) {
                        break;
                    }
                    ;
                    [, token68, rest] = match;
                    break;
                }
                return undefined;
            }
        } else {
            rest = afterScheme || undefined;
        }
        const challenge = {
            scheme,
            parameters
        };
        if (token68) {
            challenge.token68 = token68;
        }
        challenges.push(challenge);
    }
    if (!challenges.length) {
        return undefined;
    }
    return challenges;
}
async function processPushedAuthorizationResponse(as, client, response) {
    assertAs(as);
    assertClient(client);
    if (!looseInstanceOf(response, Response)) {
        throw CodedTypeError('"response" must be an instance of Response', ERR_INVALID_ARG_TYPE);
    }
    await checkOAuthBodyError(response, 201, 'Pushed Authorization Request Endpoint');
    assertReadableResponse(response);
    const json = await getResponseJsonBody(response);
    assertString(json.request_uri, '"response" body "request_uri" property', INVALID_RESPONSE, {
        body: json
    });
    let expiresIn = typeof json.expires_in !== 'number' ? parseFloat(json.expires_in) : json.expires_in;
    assertNumber(expiresIn, true, '"response" body "expires_in" property', INVALID_RESPONSE, {
        body: json
    });
    json.expires_in = expiresIn;
    return json;
}
async function parseOAuthResponseErrorBody(response) {
    if (response.status > 399 && response.status < 500) {
        assertReadableResponse(response);
        assertApplicationJson(response);
        try {
            const json = await response.clone().json();
            if (isJsonObject(json) && typeof json.error === 'string' && json.error.length) {
                return json;
            }
        } catch  {}
    }
    return undefined;
}
async function checkOAuthBodyError(response, expected, label) {
    if (response.status !== expected) {
        checkAuthenticationChallenges(response);
        let err;
        if (err = await parseOAuthResponseErrorBody(response)) {
            await response.body?.cancel();
            throw new ResponseBodyError('server responded with an error in the response body', {
                cause: err,
                response
            });
        }
        throw OPE(`"response" is not a conform ${label} response (unexpected HTTP status code)`, RESPONSE_IS_NOT_CONFORM, response);
    }
}
function assertDPoP(option) {
    if (!branded.has(option)) {
        throw CodedTypeError('"options.DPoP" is not a valid DPoPHandle', ERR_INVALID_ARG_VALUE);
    }
}
async function resourceRequest(accessToken, method, url, headers, body, options) {
    assertString(accessToken, '"accessToken"');
    if (!(url instanceof URL)) {
        throw CodedTypeError('"url" must be an instance of URL', ERR_INVALID_ARG_TYPE);
    }
    checkProtocol(url, options?.[allowInsecureRequests] !== true);
    headers = prepareHeaders(headers);
    if (options?.DPoP) {
        assertDPoP(options.DPoP);
        await options.DPoP.addProof(url, headers, method.toUpperCase(), accessToken);
    }
    headers.set('authorization', `${headers.has('dpop') ? 'DPoP' : 'Bearer'} ${accessToken}`);
    const response = await (options?.[customFetch] || fetch)(url.href, {
        body,
        headers: Object.fromEntries(headers.entries()),
        method,
        redirect: 'manual',
        signal: signal(url, options?.signal)
    });
    options?.DPoP?.cacheNonce(response, url);
    return response;
}
async function protectedResourceRequest(accessToken, method, url, headers, body, options) {
    const response = await resourceRequest(accessToken, method, url, headers, body, options);
    checkAuthenticationChallenges(response);
    return response;
}
async function userInfoRequest(as, client, accessToken, options) {
    assertAs(as);
    assertClient(client);
    const url = resolveEndpoint(as, 'userinfo_endpoint', client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);
    const headers = prepareHeaders(options?.headers);
    if (client.userinfo_signed_response_alg) {
        headers.set('accept', 'application/jwt');
    } else {
        headers.set('accept', 'application/json');
        headers.append('accept', 'application/jwt');
    }
    return resourceRequest(accessToken, 'GET', url, headers, null, {
        ...options,
        [clockSkew]: getClockSkew(client)
    });
}
let jwksMap;
function setJwksCache(as, jwks, uat, cache) {
    jwksMap ||= new WeakMap();
    jwksMap.set(as, {
        jwks,
        uat,
        get age () {
            return epochTime() - this.uat;
        }
    });
    if (cache) {
        Object.assign(cache, {
            jwks: structuredClone(jwks),
            uat
        });
    }
}
function isFreshJwksCache(input) {
    if (typeof input !== 'object' || input === null) {
        return false;
    }
    if (!('uat' in input) || typeof input.uat !== 'number' || epochTime() - input.uat >= 300) {
        return false;
    }
    if (!('jwks' in input) || !isJsonObject(input.jwks) || !Array.isArray(input.jwks.keys) || !Array.prototype.every.call(input.jwks.keys, isJsonObject)) {
        return false;
    }
    return true;
}
function clearJwksCache(as, cache) {
    jwksMap?.delete(as);
    delete cache?.jwks;
    delete cache?.uat;
}
async function getPublicSigKeyFromIssuerJwksUri(as, options, header) {
    const { alg, kid } = header;
    checkSupportedJwsAlg(header);
    if (!jwksMap?.has(as) && isFreshJwksCache(options?.[jwksCache])) {
        setJwksCache(as, options?.[jwksCache].jwks, options?.[jwksCache].uat);
    }
    let jwks;
    let age;
    if (jwksMap?.has(as)) {
        ;
        ({ jwks, age } = jwksMap.get(as));
        if (age >= 300) {
            clearJwksCache(as, options?.[jwksCache]);
            return getPublicSigKeyFromIssuerJwksUri(as, options, header);
        }
    } else {
        jwks = await jwksRequest(as, options).then(processJwksResponse);
        age = 0;
        setJwksCache(as, jwks, epochTime(), options?.[jwksCache]);
    }
    let kty;
    switch(alg.slice(0, 2)){
        case 'RS':
        case 'PS':
            kty = 'RSA';
            break;
        case 'ES':
            kty = 'EC';
            break;
        case 'Ed':
            kty = 'OKP';
            break;
        case 'ML':
            kty = 'AKP';
            break;
        default:
            throw new UnsupportedOperationError('unsupported JWS algorithm', {
                cause: {
                    alg
                }
            });
    }
    const candidates = jwks.keys.filter((jwk)=>{
        if (jwk.kty !== kty) {
            return false;
        }
        if (kid !== undefined && kid !== jwk.kid) {
            return false;
        }
        if (jwk.alg !== undefined && alg !== jwk.alg) {
            return false;
        }
        if (jwk.use !== undefined && jwk.use !== 'sig') {
            return false;
        }
        if (jwk.key_ops?.includes('verify') === false) {
            return false;
        }
        switch(true){
            case alg === 'ES256' && jwk.crv !== 'P-256':
            case alg === 'ES384' && jwk.crv !== 'P-384':
            case alg === 'ES512' && jwk.crv !== 'P-521':
            case alg === 'Ed25519' && jwk.crv !== 'Ed25519':
            case alg === 'EdDSA' && jwk.crv !== 'Ed25519':
                return false;
        }
        return true;
    });
    const { 0: jwk, length } = candidates;
    if (!length) {
        if (age >= 60) {
            clearJwksCache(as, options?.[jwksCache]);
            return getPublicSigKeyFromIssuerJwksUri(as, options, header);
        }
        throw OPE('error when selecting a JWT verification key, no applicable keys found', KEY_SELECTION, {
            header,
            candidates,
            jwks_uri: new URL(as.jwks_uri)
        });
    }
    if (length !== 1) {
        throw OPE('error when selecting a JWT verification key, multiple applicable keys found, a "kid" JWT Header Parameter is required', KEY_SELECTION, {
            header,
            candidates,
            jwks_uri: new URL(as.jwks_uri)
        });
    }
    return importJwk(alg, jwk);
}
const skipSubjectCheck = Symbol();
function getContentType(input) {
    return input.headers.get('content-type')?.split(';')[0];
}
async function processUserInfoResponse(as, client, expectedSubject, response, options) {
    assertAs(as);
    assertClient(client);
    if (!looseInstanceOf(response, Response)) {
        throw CodedTypeError('"response" must be an instance of Response', ERR_INVALID_ARG_TYPE);
    }
    checkAuthenticationChallenges(response);
    if (response.status !== 200) {
        throw OPE('"response" is not a conform UserInfo Endpoint response (unexpected HTTP status code)', RESPONSE_IS_NOT_CONFORM, response);
    }
    assertReadableResponse(response);
    let json;
    if (getContentType(response) === 'application/jwt') {
        const { claims, jwt } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.userinfo_signed_response_alg, as.userinfo_signing_alg_values_supported, undefined), getClockSkew(client), getClockTolerance(client), options?.[jweDecrypt]).then(validateOptionalAudience.bind(undefined, client.client_id)).then(validateOptionalIssuer.bind(undefined, as));
        jwtRefs.set(response, jwt);
        json = claims;
    } else {
        if (client.userinfo_signed_response_alg) {
            throw OPE('JWT UserInfo Response expected', JWT_USERINFO_EXPECTED, response);
        }
        json = await getResponseJsonBody(response);
    }
    assertString(json.sub, '"response" body "sub" property', INVALID_RESPONSE, {
        body: json
    });
    switch(expectedSubject){
        case skipSubjectCheck:
            break;
        default:
            assertString(expectedSubject, '"expectedSubject"');
            if (json.sub !== expectedSubject) {
                throw OPE('unexpected "response" body "sub" property value', JSON_ATTRIBUTE_COMPARISON, {
                    expected: expectedSubject,
                    body: json,
                    attribute: 'sub'
                });
            }
    }
    return json;
}
async function authenticatedRequest(as, client, clientAuthentication, url, body, headers, options) {
    await clientAuthentication(as, client, body, headers);
    headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
    return (options?.[customFetch] || fetch)(url.href, {
        body,
        headers: Object.fromEntries(headers.entries()),
        method: 'POST',
        redirect: 'manual',
        signal: signal(url, options?.signal)
    });
}
async function tokenEndpointRequest(as, client, clientAuthentication, grantType, parameters, options) {
    const url = resolveEndpoint(as, 'token_endpoint', client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);
    parameters.set('grant_type', grantType);
    const headers = prepareHeaders(options?.headers);
    headers.set('accept', 'application/json');
    if (options?.DPoP !== undefined) {
        assertDPoP(options.DPoP);
        await options.DPoP.addProof(url, headers, 'POST');
    }
    const response = await authenticatedRequest(as, client, clientAuthentication, url, parameters, headers, options);
    options?.DPoP?.cacheNonce(response, url);
    return response;
}
async function refreshTokenGrantRequest(as, client, clientAuthentication, refreshToken, options) {
    assertAs(as);
    assertClient(client);
    assertString(refreshToken, '"refreshToken"');
    const parameters = new URLSearchParams(options?.additionalParameters);
    parameters.set('refresh_token', refreshToken);
    return tokenEndpointRequest(as, client, clientAuthentication, 'refresh_token', parameters, options);
}
const idTokenClaims = new WeakMap();
const jwtRefs = new WeakMap();
function getValidatedIdTokenClaims(ref) {
    if (!ref.id_token) {
        return undefined;
    }
    const claims = idTokenClaims.get(ref);
    if (!claims) {
        throw CodedTypeError('"ref" was already garbage collected or did not resolve from the proper sources', ERR_INVALID_ARG_VALUE);
    }
    return claims;
}
async function validateApplicationLevelSignature(as, ref, options) {
    assertAs(as);
    if (!jwtRefs.has(ref)) {
        throw CodedTypeError('"ref" does not contain a processed JWT Response to verify the signature of', ERR_INVALID_ARG_VALUE);
    }
    const { 0: protectedHeader, 1: payload, 2: encodedSignature } = jwtRefs.get(ref).split('.');
    const header = JSON.parse(buf(b64u(protectedHeader)));
    if (header.alg.startsWith('HS')) {
        throw new UnsupportedOperationError('unsupported JWS algorithm', {
            cause: {
                alg: header.alg
            }
        });
    }
    let key;
    key = await getPublicSigKeyFromIssuerJwksUri(as, options, header);
    await validateJwsSignature(protectedHeader, payload, key, b64u(encodedSignature));
}
async function processGenericAccessTokenResponse(as, client, response, additionalRequiredIdTokenClaims, decryptFn, recognizedTokenTypes) {
    assertAs(as);
    assertClient(client);
    if (!looseInstanceOf(response, Response)) {
        throw CodedTypeError('"response" must be an instance of Response', ERR_INVALID_ARG_TYPE);
    }
    await checkOAuthBodyError(response, 200, 'Token Endpoint');
    assertReadableResponse(response);
    const json = await getResponseJsonBody(response);
    assertString(json.access_token, '"response" body "access_token" property', INVALID_RESPONSE, {
        body: json
    });
    assertString(json.token_type, '"response" body "token_type" property', INVALID_RESPONSE, {
        body: json
    });
    json.token_type = json.token_type.toLowerCase();
    if (json.expires_in !== undefined) {
        let expiresIn = typeof json.expires_in !== 'number' ? parseFloat(json.expires_in) : json.expires_in;
        assertNumber(expiresIn, true, '"response" body "expires_in" property', INVALID_RESPONSE, {
            body: json
        });
        json.expires_in = expiresIn;
    }
    if (json.refresh_token !== undefined) {
        assertString(json.refresh_token, '"response" body "refresh_token" property', INVALID_RESPONSE, {
            body: json
        });
    }
    if (json.scope !== undefined && typeof json.scope !== 'string') {
        throw OPE('"response" body "scope" property must be a string', INVALID_RESPONSE, {
            body: json
        });
    }
    if (json.id_token !== undefined) {
        assertString(json.id_token, '"response" body "id_token" property', INVALID_RESPONSE, {
            body: json
        });
        const requiredClaims = [
            'aud',
            'exp',
            'iat',
            'iss',
            'sub'
        ];
        if (client.require_auth_time === true) {
            requiredClaims.push('auth_time');
        }
        if (client.default_max_age !== undefined) {
            assertNumber(client.default_max_age, true, '"client.default_max_age"');
            requiredClaims.push('auth_time');
        }
        if (additionalRequiredIdTokenClaims?.length) {
            requiredClaims.push(...additionalRequiredIdTokenClaims);
        }
        const { claims, jwt } = await validateJwt(json.id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported, 'RS256'), getClockSkew(client), getClockTolerance(client), decryptFn).then(validatePresence.bind(undefined, requiredClaims)).then(validateIssuer.bind(undefined, as)).then(validateAudience.bind(undefined, client.client_id));
        if (Array.isArray(claims.aud) && claims.aud.length !== 1) {
            if (claims.azp === undefined) {
                throw OPE('ID Token "aud" (audience) claim includes additional untrusted audiences', JWT_CLAIM_COMPARISON, {
                    claims,
                    claim: 'aud'
                });
            }
            if (claims.azp !== client.client_id) {
                throw OPE('unexpected ID Token "azp" (authorized party) claim value', JWT_CLAIM_COMPARISON, {
                    expected: client.client_id,
                    claims,
                    claim: 'azp'
                });
            }
        }
        if (claims.auth_time !== undefined) {
            assertNumber(claims.auth_time, true, 'ID Token "auth_time" (authentication time)', INVALID_RESPONSE, {
                claims
            });
        }
        jwtRefs.set(response, jwt);
        idTokenClaims.set(json, claims);
    }
    if (recognizedTokenTypes?.[json.token_type] !== undefined) {
        recognizedTokenTypes[json.token_type](response, json);
    } else if (json.token_type !== 'dpop' && json.token_type !== 'bearer') {
        throw new UnsupportedOperationError('unsupported `token_type` value', {
            cause: {
                body: json
            }
        });
    }
    return json;
}
function checkAuthenticationChallenges(response) {
    let challenges;
    if (challenges = parseWwwAuthenticateChallenges(response)) {
        throw new WWWAuthenticateChallengeError('server responded with a challenge in the WWW-Authenticate HTTP Header', {
            cause: challenges,
            response
        });
    }
}
async function processRefreshTokenResponse(as, client, response, options) {
    return processGenericAccessTokenResponse(as, client, response, undefined, options?.[jweDecrypt], options?.recognizedTokenTypes);
}
function validateOptionalAudience(expected, result) {
    if (result.claims.aud !== undefined) {
        return validateAudience(expected, result);
    }
    return result;
}
function validateAudience(expected, result) {
    if (Array.isArray(result.claims.aud)) {
        if (!result.claims.aud.includes(expected)) {
            throw OPE('unexpected JWT "aud" (audience) claim value', JWT_CLAIM_COMPARISON, {
                expected,
                claims: result.claims,
                claim: 'aud'
            });
        }
    } else if (result.claims.aud !== expected) {
        throw OPE('unexpected JWT "aud" (audience) claim value', JWT_CLAIM_COMPARISON, {
            expected,
            claims: result.claims,
            claim: 'aud'
        });
    }
    return result;
}
function validateOptionalIssuer(as, result) {
    if (result.claims.iss !== undefined) {
        return validateIssuer(as, result);
    }
    return result;
}
function validateIssuer(as, result) {
    const expected = as[_expectedIssuer]?.(result) ?? as.issuer;
    if (result.claims.iss !== expected) {
        throw OPE('unexpected JWT "iss" (issuer) claim value', JWT_CLAIM_COMPARISON, {
            expected,
            claims: result.claims,
            claim: 'iss'
        });
    }
    return result;
}
const branded = new WeakSet();
function brand(searchParams) {
    branded.add(searchParams);
    return searchParams;
}
const nopkce = Symbol();
async function authorizationCodeGrantRequest(as, client, clientAuthentication, callbackParameters, redirectUri, codeVerifier, options) {
    assertAs(as);
    assertClient(client);
    if (!branded.has(callbackParameters)) {
        throw CodedTypeError('"callbackParameters" must be an instance of URLSearchParams obtained from "validateAuthResponse()", or "validateJwtAuthResponse()', ERR_INVALID_ARG_VALUE);
    }
    assertString(redirectUri, '"redirectUri"');
    const code = getURLSearchParameter(callbackParameters, 'code');
    if (!code) {
        throw OPE('no authorization code in "callbackParameters"', INVALID_RESPONSE);
    }
    const parameters = new URLSearchParams(options?.additionalParameters);
    parameters.set('redirect_uri', redirectUri);
    parameters.set('code', code);
    if (codeVerifier !== nopkce) {
        assertString(codeVerifier, '"codeVerifier"');
        parameters.set('code_verifier', codeVerifier);
    }
    return tokenEndpointRequest(as, client, clientAuthentication, 'authorization_code', parameters, options);
}
const jwtClaimNames = {
    aud: 'audience',
    c_hash: 'code hash',
    client_id: 'client id',
    exp: 'expiration time',
    iat: 'issued at',
    iss: 'issuer',
    jti: 'jwt id',
    nonce: 'nonce',
    s_hash: 'state hash',
    sub: 'subject',
    ath: 'access token hash',
    htm: 'http method',
    htu: 'http uri',
    cnf: 'confirmation',
    auth_time: 'authentication time'
};
function validatePresence(required, result) {
    for (const claim of required){
        if (result.claims[claim] === undefined) {
            throw OPE(`JWT "${claim}" (${jwtClaimNames[claim]}) claim missing`, INVALID_RESPONSE, {
                claims: result.claims
            });
        }
    }
    return result;
}
const expectNoNonce = Symbol();
const skipAuthTimeCheck = Symbol();
async function processAuthorizationCodeResponse(as, client, response, options) {
    if (typeof options?.expectedNonce === 'string' || typeof options?.maxAge === 'number' || options?.requireIdToken) {
        return processAuthorizationCodeOpenIDResponse(as, client, response, options.expectedNonce, options.maxAge, options[jweDecrypt], options.recognizedTokenTypes);
    }
    return processAuthorizationCodeOAuth2Response(as, client, response, options?.[jweDecrypt], options?.recognizedTokenTypes);
}
async function processAuthorizationCodeOpenIDResponse(as, client, response, expectedNonce, maxAge, decryptFn, recognizedTokenTypes) {
    const additionalRequiredClaims = [];
    switch(expectedNonce){
        case undefined:
            expectedNonce = expectNoNonce;
            break;
        case expectNoNonce:
            break;
        default:
            assertString(expectedNonce, '"expectedNonce" argument');
            additionalRequiredClaims.push('nonce');
    }
    maxAge ??= client.default_max_age;
    switch(maxAge){
        case undefined:
            maxAge = skipAuthTimeCheck;
            break;
        case skipAuthTimeCheck:
            break;
        default:
            assertNumber(maxAge, true, '"maxAge" argument');
            additionalRequiredClaims.push('auth_time');
    }
    const result = await processGenericAccessTokenResponse(as, client, response, additionalRequiredClaims, decryptFn, recognizedTokenTypes);
    assertString(result.id_token, '"response" body "id_token" property', INVALID_RESPONSE, {
        body: result
    });
    const claims = getValidatedIdTokenClaims(result);
    if (maxAge !== skipAuthTimeCheck) {
        const now = epochTime() + getClockSkew(client);
        const tolerance = getClockTolerance(client);
        if (claims.auth_time + maxAge < now - tolerance) {
            throw OPE('too much time has elapsed since the last End-User authentication', JWT_TIMESTAMP_CHECK, {
                claims,
                now,
                tolerance,
                claim: 'auth_time'
            });
        }
    }
    if (expectedNonce === expectNoNonce) {
        if (claims.nonce !== undefined) {
            throw OPE('unexpected ID Token "nonce" claim value', JWT_CLAIM_COMPARISON, {
                expected: undefined,
                claims,
                claim: 'nonce'
            });
        }
    } else if (claims.nonce !== expectedNonce) {
        throw OPE('unexpected ID Token "nonce" claim value', JWT_CLAIM_COMPARISON, {
            expected: expectedNonce,
            claims,
            claim: 'nonce'
        });
    }
    return result;
}
async function processAuthorizationCodeOAuth2Response(as, client, response, decryptFn, recognizedTokenTypes) {
    const result = await processGenericAccessTokenResponse(as, client, response, undefined, decryptFn, recognizedTokenTypes);
    const claims = getValidatedIdTokenClaims(result);
    if (claims) {
        if (client.default_max_age !== undefined) {
            assertNumber(client.default_max_age, true, '"client.default_max_age"');
            const now = epochTime() + getClockSkew(client);
            const tolerance = getClockTolerance(client);
            if (claims.auth_time + client.default_max_age < now - tolerance) {
                throw OPE('too much time has elapsed since the last End-User authentication', JWT_TIMESTAMP_CHECK, {
                    claims,
                    now,
                    tolerance,
                    claim: 'auth_time'
                });
            }
        }
        if (claims.nonce !== undefined) {
            throw OPE('unexpected ID Token "nonce" claim value', JWT_CLAIM_COMPARISON, {
                expected: undefined,
                claims,
                claim: 'nonce'
            });
        }
    }
    return result;
}
const WWW_AUTHENTICATE_CHALLENGE = 'OAUTH_WWW_AUTHENTICATE_CHALLENGE';
const RESPONSE_BODY_ERROR = 'OAUTH_RESPONSE_BODY_ERROR';
const UNSUPPORTED_OPERATION = 'OAUTH_UNSUPPORTED_OPERATION';
const AUTHORIZATION_RESPONSE_ERROR = 'OAUTH_AUTHORIZATION_RESPONSE_ERROR';
const JWT_USERINFO_EXPECTED = 'OAUTH_JWT_USERINFO_EXPECTED';
const PARSE_ERROR = 'OAUTH_PARSE_ERROR';
const INVALID_RESPONSE = 'OAUTH_INVALID_RESPONSE';
const INVALID_REQUEST = 'OAUTH_INVALID_REQUEST';
const RESPONSE_IS_NOT_JSON = 'OAUTH_RESPONSE_IS_NOT_JSON';
const RESPONSE_IS_NOT_CONFORM = 'OAUTH_RESPONSE_IS_NOT_CONFORM';
const HTTP_REQUEST_FORBIDDEN = 'OAUTH_HTTP_REQUEST_FORBIDDEN';
const REQUEST_PROTOCOL_FORBIDDEN = 'OAUTH_REQUEST_PROTOCOL_FORBIDDEN';
const JWT_TIMESTAMP_CHECK = 'OAUTH_JWT_TIMESTAMP_CHECK_FAILED';
const JWT_CLAIM_COMPARISON = 'OAUTH_JWT_CLAIM_COMPARISON_FAILED';
const JSON_ATTRIBUTE_COMPARISON = 'OAUTH_JSON_ATTRIBUTE_COMPARISON_FAILED';
const KEY_SELECTION = 'OAUTH_KEY_SELECTION_FAILED';
const MISSING_SERVER_METADATA = 'OAUTH_MISSING_SERVER_METADATA';
const INVALID_SERVER_METADATA = 'OAUTH_INVALID_SERVER_METADATA';
function checkJwtType(expected, result) {
    if (typeof result.header.typ !== 'string' || normalizeTyp(result.header.typ) !== expected) {
        throw OPE('unexpected JWT "typ" header parameter value', INVALID_RESPONSE, {
            header: result.header
        });
    }
    return result;
}
async function clientCredentialsGrantRequest(as, client, clientAuthentication, parameters, options) {
    assertAs(as);
    assertClient(client);
    return tokenEndpointRequest(as, client, clientAuthentication, 'client_credentials', new URLSearchParams(parameters), options);
}
async function genericTokenEndpointRequest(as, client, clientAuthentication, grantType, parameters, options) {
    assertAs(as);
    assertClient(client);
    assertString(grantType, '"grantType"');
    return tokenEndpointRequest(as, client, clientAuthentication, grantType, new URLSearchParams(parameters), options);
}
async function processGenericTokenEndpointResponse(as, client, response, options) {
    return processGenericAccessTokenResponse(as, client, response, undefined, options?.[jweDecrypt], options?.recognizedTokenTypes);
}
async function processClientCredentialsResponse(as, client, response, options) {
    return processGenericAccessTokenResponse(as, client, response, undefined, options?.[jweDecrypt], options?.recognizedTokenTypes);
}
async function revocationRequest(as, client, clientAuthentication, token, options) {
    assertAs(as);
    assertClient(client);
    assertString(token, '"token"');
    const url = resolveEndpoint(as, 'revocation_endpoint', client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);
    const body = new URLSearchParams(options?.additionalParameters);
    body.set('token', token);
    const headers = prepareHeaders(options?.headers);
    headers.delete('accept');
    return authenticatedRequest(as, client, clientAuthentication, url, body, headers, options);
}
async function processRevocationResponse(response) {
    if (!looseInstanceOf(response, Response)) {
        throw CodedTypeError('"response" must be an instance of Response', ERR_INVALID_ARG_TYPE);
    }
    await checkOAuthBodyError(response, 200, 'Revocation Endpoint');
    return undefined;
}
function assertReadableResponse(response) {
    if (response.bodyUsed) {
        throw CodedTypeError('"response" body has been used already', ERR_INVALID_ARG_VALUE);
    }
}
async function introspectionRequest(as, client, clientAuthentication, token, options) {
    assertAs(as);
    assertClient(client);
    assertString(token, '"token"');
    const url = resolveEndpoint(as, 'introspection_endpoint', client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);
    const body = new URLSearchParams(options?.additionalParameters);
    body.set('token', token);
    const headers = prepareHeaders(options?.headers);
    if (options?.requestJwtResponse ?? client.introspection_signed_response_alg) {
        headers.set('accept', 'application/token-introspection+jwt');
    } else {
        headers.set('accept', 'application/json');
    }
    return authenticatedRequest(as, client, clientAuthentication, url, body, headers, options);
}
async function processIntrospectionResponse(as, client, response, options) {
    assertAs(as);
    assertClient(client);
    if (!looseInstanceOf(response, Response)) {
        throw CodedTypeError('"response" must be an instance of Response', ERR_INVALID_ARG_TYPE);
    }
    await checkOAuthBodyError(response, 200, 'Introspection Endpoint');
    let json;
    if (getContentType(response) === 'application/token-introspection+jwt') {
        assertReadableResponse(response);
        const { claims, jwt } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.introspection_signed_response_alg, as.introspection_signing_alg_values_supported, 'RS256'), getClockSkew(client), getClockTolerance(client), options?.[jweDecrypt]).then(checkJwtType.bind(undefined, 'token-introspection+jwt')).then(validatePresence.bind(undefined, [
            'aud',
            'iat',
            'iss'
        ])).then(validateIssuer.bind(undefined, as)).then(validateAudience.bind(undefined, client.client_id));
        jwtRefs.set(response, jwt);
        if (!isJsonObject(claims.token_introspection)) {
            throw OPE('JWT "token_introspection" claim must be a JSON object', INVALID_RESPONSE, {
                claims
            });
        }
        json = claims.token_introspection;
    } else {
        assertReadableResponse(response);
        json = await getResponseJsonBody(response);
    }
    if (typeof json.active !== 'boolean') {
        throw OPE('"response" body "active" property must be a boolean', INVALID_RESPONSE, {
            body: json
        });
    }
    return json;
}
async function jwksRequest(as, options) {
    assertAs(as);
    const url = resolveEndpoint(as, 'jwks_uri', false, options?.[allowInsecureRequests] !== true);
    const headers = prepareHeaders(options?.headers);
    headers.set('accept', 'application/json');
    headers.append('accept', 'application/jwk-set+json');
    return (options?.[customFetch] || fetch)(url.href, {
        body: undefined,
        headers: Object.fromEntries(headers.entries()),
        method: 'GET',
        redirect: 'manual',
        signal: signal(url, options?.signal)
    });
}
async function processJwksResponse(response) {
    if (!looseInstanceOf(response, Response)) {
        throw CodedTypeError('"response" must be an instance of Response', ERR_INVALID_ARG_TYPE);
    }
    if (response.status !== 200) {
        throw OPE('"response" is not a conform JSON Web Key Set response (unexpected HTTP status code)', RESPONSE_IS_NOT_CONFORM, response);
    }
    assertReadableResponse(response);
    const json = await getResponseJsonBody(response, (response)=>assertContentTypes(response, 'application/json', 'application/jwk-set+json'));
    if (!Array.isArray(json.keys)) {
        throw OPE('"response" body "keys" property must be an array', INVALID_RESPONSE, {
            body: json
        });
    }
    if (!Array.prototype.every.call(json.keys, isJsonObject)) {
        throw OPE('"response" body "keys" property members must be JWK formatted objects', INVALID_RESPONSE, {
            body: json
        });
    }
    return json;
}
function supported(alg) {
    switch(alg){
        case 'PS256':
        case 'ES256':
        case 'RS256':
        case 'PS384':
        case 'ES384':
        case 'RS384':
        case 'PS512':
        case 'ES512':
        case 'RS512':
        case 'Ed25519':
        case 'EdDSA':
        case 'ML-DSA-44':
        case 'ML-DSA-65':
        case 'ML-DSA-87':
            return true;
        default:
            return false;
    }
}
function checkSupportedJwsAlg(header) {
    if (!supported(header.alg)) {
        throw new UnsupportedOperationError('unsupported JWS "alg" identifier', {
            cause: {
                alg: header.alg
            }
        });
    }
}
function checkRsaKeyAlgorithm(key) {
    const { algorithm } = key;
    if (typeof algorithm.modulusLength !== 'number' || algorithm.modulusLength < 2048) {
        throw new UnsupportedOperationError(`unsupported ${algorithm.name} modulusLength`, {
            cause: key
        });
    }
}
function ecdsaHashName(key) {
    const { algorithm } = key;
    switch(algorithm.namedCurve){
        case 'P-256':
            return 'SHA-256';
        case 'P-384':
            return 'SHA-384';
        case 'P-521':
            return 'SHA-512';
        default:
            throw new UnsupportedOperationError('unsupported ECDSA namedCurve', {
                cause: key
            });
    }
}
function keyToSubtle(key) {
    switch(key.algorithm.name){
        case 'ECDSA':
            return {
                name: key.algorithm.name,
                hash: ecdsaHashName(key)
            };
        case 'RSA-PSS':
            {
                checkRsaKeyAlgorithm(key);
                switch(key.algorithm.hash.name){
                    case 'SHA-256':
                    case 'SHA-384':
                    case 'SHA-512':
                        return {
                            name: key.algorithm.name,
                            saltLength: parseInt(key.algorithm.hash.name.slice(-3), 10) >> 3
                        };
                    default:
                        throw new UnsupportedOperationError('unsupported RSA-PSS hash name', {
                            cause: key
                        });
                }
            }
        case 'RSASSA-PKCS1-v1_5':
            checkRsaKeyAlgorithm(key);
            return key.algorithm.name;
        case 'ML-DSA-44':
        case 'ML-DSA-65':
        case 'ML-DSA-87':
        case 'Ed25519':
            return key.algorithm.name;
    }
    throw new UnsupportedOperationError('unsupported CryptoKey algorithm name', {
        cause: key
    });
}
async function validateJwsSignature(protectedHeader, payload, key, signature) {
    const data = buf(`${protectedHeader}.${payload}`);
    const algorithm = keyToSubtle(key);
    const verified = await crypto.subtle.verify(algorithm, key, signature, data);
    if (!verified) {
        throw OPE('JWT signature verification failed', INVALID_RESPONSE, {
            key,
            data,
            signature,
            algorithm
        });
    }
}
async function validateJwt(jws, checkAlg, clockSkew, clockTolerance, decryptJwt) {
    let { 0: protectedHeader, 1: payload, length } = jws.split('.');
    if (length === 5) {
        if (decryptJwt !== undefined) {
            jws = await decryptJwt(jws);
            ({ 0: protectedHeader, 1: payload, length } = jws.split('.'));
        } else {
            throw new UnsupportedOperationError('JWE decryption is not configured', {
                cause: jws
            });
        }
    }
    if (length !== 3) {
        throw OPE('Invalid JWT', INVALID_RESPONSE, jws);
    }
    let header;
    try {
        header = JSON.parse(buf(b64u(protectedHeader)));
    } catch (cause) {
        throw OPE('failed to parse JWT Header body as base64url encoded JSON', PARSE_ERROR, cause);
    }
    if (!isJsonObject(header)) {
        throw OPE('JWT Header must be a top level object', INVALID_RESPONSE, jws);
    }
    checkAlg(header);
    if (header.crit !== undefined) {
        throw new UnsupportedOperationError('no JWT "crit" header parameter extensions are supported', {
            cause: {
                header
            }
        });
    }
    let claims;
    try {
        claims = JSON.parse(buf(b64u(payload)));
    } catch (cause) {
        throw OPE('failed to parse JWT Payload body as base64url encoded JSON', PARSE_ERROR, cause);
    }
    if (!isJsonObject(claims)) {
        throw OPE('JWT Payload must be a top level object', INVALID_RESPONSE, jws);
    }
    const now = epochTime() + clockSkew;
    if (claims.exp !== undefined) {
        if (typeof claims.exp !== 'number') {
            throw OPE('unexpected JWT "exp" (expiration time) claim type', INVALID_RESPONSE, {
                claims
            });
        }
        if (claims.exp <= now - clockTolerance) {
            throw OPE('unexpected JWT "exp" (expiration time) claim value, expiration is past current timestamp', JWT_TIMESTAMP_CHECK, {
                claims,
                now,
                tolerance: clockTolerance,
                claim: 'exp'
            });
        }
    }
    if (claims.iat !== undefined) {
        if (typeof claims.iat !== 'number') {
            throw OPE('unexpected JWT "iat" (issued at) claim type', INVALID_RESPONSE, {
                claims
            });
        }
    }
    if (claims.iss !== undefined) {
        if (typeof claims.iss !== 'string') {
            throw OPE('unexpected JWT "iss" (issuer) claim type', INVALID_RESPONSE, {
                claims
            });
        }
    }
    if (claims.nbf !== undefined) {
        if (typeof claims.nbf !== 'number') {
            throw OPE('unexpected JWT "nbf" (not before) claim type', INVALID_RESPONSE, {
                claims
            });
        }
        if (claims.nbf > now + clockTolerance) {
            throw OPE('unexpected JWT "nbf" (not before) claim value', JWT_TIMESTAMP_CHECK, {
                claims,
                now,
                tolerance: clockTolerance,
                claim: 'nbf'
            });
        }
    }
    if (claims.aud !== undefined) {
        if (typeof claims.aud !== 'string' && !Array.isArray(claims.aud)) {
            throw OPE('unexpected JWT "aud" (audience) claim type', INVALID_RESPONSE, {
                claims
            });
        }
    }
    return {
        header,
        claims,
        jwt: jws
    };
}
async function validateJwtAuthResponse(as, client, parameters, expectedState, options) {
    assertAs(as);
    assertClient(client);
    if (parameters instanceof URL) {
        parameters = parameters.searchParams;
    }
    if (!(parameters instanceof URLSearchParams)) {
        throw CodedTypeError('"parameters" must be an instance of URLSearchParams, or URL', ERR_INVALID_ARG_TYPE);
    }
    const response = getURLSearchParameter(parameters, 'response');
    if (!response) {
        throw OPE('"parameters" does not contain a JARM response', INVALID_RESPONSE);
    }
    const { claims, header, jwt } = await validateJwt(response, checkSigningAlgorithm.bind(undefined, client.authorization_signed_response_alg, as.authorization_signing_alg_values_supported, 'RS256'), getClockSkew(client), getClockTolerance(client), options?.[jweDecrypt]).then(validatePresence.bind(undefined, [
        'aud',
        'exp',
        'iss'
    ])).then(validateIssuer.bind(undefined, as)).then(validateAudience.bind(undefined, client.client_id));
    const { 0: protectedHeader, 1: payload, 2: encodedSignature } = jwt.split('.');
    const signature = b64u(encodedSignature);
    const key = await getPublicSigKeyFromIssuerJwksUri(as, options, header);
    await validateJwsSignature(protectedHeader, payload, key, signature);
    const result = new URLSearchParams();
    for (const [key, value] of Object.entries(claims)){
        if (typeof value === 'string' && key !== 'aud') {
            result.set(key, value);
        }
    }
    return validateAuthResponse(as, client, result, expectedState);
}
async function idTokenHash(data, header, claimName) {
    let algorithm;
    switch(header.alg){
        case 'RS256':
        case 'PS256':
        case 'ES256':
            algorithm = 'SHA-256';
            break;
        case 'RS384':
        case 'PS384':
        case 'ES384':
            algorithm = 'SHA-384';
            break;
        case 'RS512':
        case 'PS512':
        case 'ES512':
        case 'Ed25519':
        case 'EdDSA':
            algorithm = 'SHA-512';
            break;
        case 'ML-DSA-44':
        case 'ML-DSA-65':
        case 'ML-DSA-87':
            algorithm = {
                name: 'cSHAKE256',
                length: 512
            };
            break;
        default:
            throw new UnsupportedOperationError(`unsupported JWS algorithm for ${claimName} calculation`, {
                cause: {
                    alg: header.alg
                }
            });
    }
    const digest = await crypto.subtle.digest(algorithm, buf(data));
    return b64u(digest.slice(0, digest.byteLength / 2));
}
async function idTokenHashMatches(data, actual, header, claimName) {
    const expected = await idTokenHash(data, header, claimName);
    return actual === expected;
}
async function validateDetachedSignatureResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options) {
    return validateHybridResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options, true);
}
async function validateCodeIdTokenResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options) {
    return validateHybridResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options, false);
}
async function consumeStream(request) {
    if (request.bodyUsed) {
        throw CodedTypeError('form_post Request instances must contain a readable body', ERR_INVALID_ARG_VALUE, {
            cause: request
        });
    }
    return request.text();
}
async function formPostResponse(request) {
    if (request.method !== 'POST') {
        throw CodedTypeError('form_post responses are expected to use the POST method', ERR_INVALID_ARG_VALUE, {
            cause: request
        });
    }
    if (getContentType(request) !== 'application/x-www-form-urlencoded') {
        throw CodedTypeError('form_post responses are expected to use the application/x-www-form-urlencoded content-type', ERR_INVALID_ARG_VALUE, {
            cause: request
        });
    }
    return consumeStream(request);
}
async function validateHybridResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options, fapi) {
    assertAs(as);
    assertClient(client);
    if (parameters instanceof URL) {
        if (!parameters.hash.length) {
            throw CodedTypeError('"parameters" as an instance of URL must contain a hash (fragment) with the Authorization Response parameters', ERR_INVALID_ARG_VALUE);
        }
        parameters = new URLSearchParams(parameters.hash.slice(1));
    } else if (looseInstanceOf(parameters, Request)) {
        parameters = new URLSearchParams(await formPostResponse(parameters));
    } else if (parameters instanceof URLSearchParams) {
        parameters = new URLSearchParams(parameters);
    } else {
        throw CodedTypeError('"parameters" must be an instance of URLSearchParams, URL, or Response', ERR_INVALID_ARG_TYPE);
    }
    const id_token = getURLSearchParameter(parameters, 'id_token');
    parameters.delete('id_token');
    switch(expectedState){
        case undefined:
        case expectNoState:
            break;
        default:
            assertString(expectedState, '"expectedState" argument');
    }
    const result = validateAuthResponse({
        ...as,
        authorization_response_iss_parameter_supported: false
    }, client, parameters, expectedState);
    if (!id_token) {
        throw OPE('"parameters" does not contain an ID Token', INVALID_RESPONSE);
    }
    const code = getURLSearchParameter(parameters, 'code');
    if (!code) {
        throw OPE('"parameters" does not contain an Authorization Code', INVALID_RESPONSE);
    }
    const requiredClaims = [
        'aud',
        'exp',
        'iat',
        'iss',
        'sub',
        'nonce',
        'c_hash'
    ];
    const state = parameters.get('state');
    if (fapi && (typeof expectedState === 'string' || state !== null)) {
        requiredClaims.push('s_hash');
    }
    if (maxAge !== undefined) {
        assertNumber(maxAge, true, '"maxAge" argument');
    } else if (client.default_max_age !== undefined) {
        assertNumber(client.default_max_age, true, '"client.default_max_age"');
    }
    maxAge ??= client.default_max_age ?? skipAuthTimeCheck;
    if (client.require_auth_time || maxAge !== skipAuthTimeCheck) {
        requiredClaims.push('auth_time');
    }
    const { claims, header, jwt } = await validateJwt(id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported, 'RS256'), getClockSkew(client), getClockTolerance(client), options?.[jweDecrypt]).then(validatePresence.bind(undefined, requiredClaims)).then(validateIssuer.bind(undefined, as)).then(validateAudience.bind(undefined, client.client_id));
    const clockSkew = getClockSkew(client);
    const now = epochTime() + clockSkew;
    if (claims.iat < now - 3600) {
        throw OPE('unexpected JWT "iat" (issued at) claim value, it is too far in the past', JWT_TIMESTAMP_CHECK, {
            now,
            claims,
            claim: 'iat'
        });
    }
    assertString(claims.c_hash, 'ID Token "c_hash" (code hash) claim value', INVALID_RESPONSE, {
        claims
    });
    if (claims.auth_time !== undefined) {
        assertNumber(claims.auth_time, true, 'ID Token "auth_time" (authentication time)', INVALID_RESPONSE, {
            claims
        });
    }
    if (maxAge !== skipAuthTimeCheck) {
        const now = epochTime() + getClockSkew(client);
        const tolerance = getClockTolerance(client);
        if (claims.auth_time + maxAge < now - tolerance) {
            throw OPE('too much time has elapsed since the last End-User authentication', JWT_TIMESTAMP_CHECK, {
                claims,
                now,
                tolerance,
                claim: 'auth_time'
            });
        }
    }
    assertString(expectedNonce, '"expectedNonce" argument');
    if (claims.nonce !== expectedNonce) {
        throw OPE('unexpected ID Token "nonce" claim value', JWT_CLAIM_COMPARISON, {
            expected: expectedNonce,
            claims,
            claim: 'nonce'
        });
    }
    if (Array.isArray(claims.aud) && claims.aud.length !== 1) {
        if (claims.azp === undefined) {
            throw OPE('ID Token "aud" (audience) claim includes additional untrusted audiences', JWT_CLAIM_COMPARISON, {
                claims,
                claim: 'aud'
            });
        }
        if (claims.azp !== client.client_id) {
            throw OPE('unexpected ID Token "azp" (authorized party) claim value', JWT_CLAIM_COMPARISON, {
                expected: client.client_id,
                claims,
                claim: 'azp'
            });
        }
    }
    const { 0: protectedHeader, 1: payload, 2: encodedSignature } = jwt.split('.');
    const signature = b64u(encodedSignature);
    const key = await getPublicSigKeyFromIssuerJwksUri(as, options, header);
    await validateJwsSignature(protectedHeader, payload, key, signature);
    if (await idTokenHashMatches(code, claims.c_hash, header, 'c_hash') !== true) {
        throw OPE('invalid ID Token "c_hash" (code hash) claim value', JWT_CLAIM_COMPARISON, {
            code,
            alg: header.alg,
            claim: 'c_hash',
            claims
        });
    }
    if (fapi && state !== null || claims.s_hash !== undefined) {
        assertString(claims.s_hash, 'ID Token "s_hash" (state hash) claim value', INVALID_RESPONSE, {
            claims
        });
        assertString(state, '"state" response parameter', INVALID_RESPONSE, {
            parameters
        });
        if (await idTokenHashMatches(state, claims.s_hash, header, 's_hash') !== true) {
            throw OPE('invalid ID Token "s_hash" (state hash) claim value', JWT_CLAIM_COMPARISON, {
                state,
                alg: header.alg,
                claim: 's_hash',
                claims
            });
        }
    }
    return result;
}
function checkSigningAlgorithm(client, issuer, fallback, header) {
    if (client !== undefined) {
        if (typeof client === 'string' ? header.alg !== client : !client.includes(header.alg)) {
            throw OPE('unexpected JWT "alg" header parameter', INVALID_RESPONSE, {
                header,
                expected: client,
                reason: 'client configuration'
            });
        }
        return;
    }
    if (Array.isArray(issuer)) {
        if (!issuer.includes(header.alg)) {
            throw OPE('unexpected JWT "alg" header parameter', INVALID_RESPONSE, {
                header,
                expected: issuer,
                reason: 'authorization server metadata'
            });
        }
        return;
    }
    if (fallback !== undefined) {
        if (typeof fallback === 'string' ? header.alg !== fallback : typeof fallback === 'function' ? !fallback(header.alg) : !fallback.includes(header.alg)) {
            throw OPE('unexpected JWT "alg" header parameter', INVALID_RESPONSE, {
                header,
                expected: fallback,
                reason: 'default value'
            });
        }
        return;
    }
    throw OPE('missing client or server configuration to verify used JWT "alg" header parameter', undefined, {
        client,
        issuer,
        fallback
    });
}
function getURLSearchParameter(parameters, name) {
    const { 0: value, length } = parameters.getAll(name);
    if (length > 1) {
        throw OPE(`"${name}" parameter must be provided only once`, INVALID_RESPONSE);
    }
    return value;
}
const skipStateCheck = Symbol();
const expectNoState = Symbol();
function validateAuthResponse(as, client, parameters, expectedState) {
    assertAs(as);
    assertClient(client);
    if (parameters instanceof URL) {
        parameters = parameters.searchParams;
    }
    if (!(parameters instanceof URLSearchParams)) {
        throw CodedTypeError('"parameters" must be an instance of URLSearchParams, or URL', ERR_INVALID_ARG_TYPE);
    }
    if (getURLSearchParameter(parameters, 'response')) {
        throw OPE('"parameters" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()', INVALID_RESPONSE, {
            parameters
        });
    }
    const iss = getURLSearchParameter(parameters, 'iss');
    const state = getURLSearchParameter(parameters, 'state');
    if (!iss && as.authorization_response_iss_parameter_supported) {
        throw OPE('response parameter "iss" (issuer) missing', INVALID_RESPONSE, {
            parameters
        });
    }
    if (iss && iss !== as.issuer) {
        throw OPE('unexpected "iss" (issuer) response parameter value', INVALID_RESPONSE, {
            expected: as.issuer,
            parameters
        });
    }
    switch(expectedState){
        case undefined:
        case expectNoState:
            if (state !== undefined) {
                throw OPE('unexpected "state" response parameter encountered', INVALID_RESPONSE, {
                    expected: undefined,
                    parameters
                });
            }
            break;
        case skipStateCheck:
            break;
        default:
            assertString(expectedState, '"expectedState" argument');
            if (state !== expectedState) {
                throw OPE(state === undefined ? 'response parameter "state" missing' : 'unexpected "state" response parameter value', INVALID_RESPONSE, {
                    expected: expectedState,
                    parameters
                });
            }
    }
    const error = getURLSearchParameter(parameters, 'error');
    if (error) {
        throw new AuthorizationResponseError('authorization response from the server is an error', {
            cause: parameters
        });
    }
    const id_token = getURLSearchParameter(parameters, 'id_token');
    const token = getURLSearchParameter(parameters, 'token');
    if (id_token !== undefined || token !== undefined) {
        throw new UnsupportedOperationError('implicit and hybrid flows are not supported');
    }
    return brand(new URLSearchParams(parameters));
}
function algToSubtle(alg) {
    switch(alg){
        case 'PS256':
        case 'PS384':
        case 'PS512':
            return {
                name: 'RSA-PSS',
                hash: `SHA-${alg.slice(-3)}`
            };
        case 'RS256':
        case 'RS384':
        case 'RS512':
            return {
                name: 'RSASSA-PKCS1-v1_5',
                hash: `SHA-${alg.slice(-3)}`
            };
        case 'ES256':
        case 'ES384':
            return {
                name: 'ECDSA',
                namedCurve: `P-${alg.slice(-3)}`
            };
        case 'ES512':
            return {
                name: 'ECDSA',
                namedCurve: 'P-521'
            };
        case 'EdDSA':
            return 'Ed25519';
        case 'Ed25519':
        case 'ML-DSA-44':
        case 'ML-DSA-65':
        case 'ML-DSA-87':
            return alg;
        default:
            throw new UnsupportedOperationError('unsupported JWS algorithm', {
                cause: {
                    alg
                }
            });
    }
}
async function importJwk(alg, jwk) {
    const { ext, key_ops, use, ...key } = jwk;
    return crypto.subtle.importKey('jwk', key, algToSubtle(alg), true, [
        'verify'
    ]);
}
async function deviceAuthorizationRequest(as, client, clientAuthentication, parameters, options) {
    assertAs(as);
    assertClient(client);
    const url = resolveEndpoint(as, 'device_authorization_endpoint', client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);
    const body = new URLSearchParams(parameters);
    body.set('client_id', client.client_id);
    const headers = prepareHeaders(options?.headers);
    headers.set('accept', 'application/json');
    return authenticatedRequest(as, client, clientAuthentication, url, body, headers, options);
}
async function processDeviceAuthorizationResponse(as, client, response) {
    assertAs(as);
    assertClient(client);
    if (!looseInstanceOf(response, Response)) {
        throw CodedTypeError('"response" must be an instance of Response', ERR_INVALID_ARG_TYPE);
    }
    await checkOAuthBodyError(response, 200, 'Device Authorization Endpoint');
    assertReadableResponse(response);
    const json = await getResponseJsonBody(response);
    assertString(json.device_code, '"response" body "device_code" property', INVALID_RESPONSE, {
        body: json
    });
    assertString(json.user_code, '"response" body "user_code" property', INVALID_RESPONSE, {
        body: json
    });
    assertString(json.verification_uri, '"response" body "verification_uri" property', INVALID_RESPONSE, {
        body: json
    });
    let expiresIn = typeof json.expires_in !== 'number' ? parseFloat(json.expires_in) : json.expires_in;
    assertNumber(expiresIn, true, '"response" body "expires_in" property', INVALID_RESPONSE, {
        body: json
    });
    json.expires_in = expiresIn;
    if (json.verification_uri_complete !== undefined) {
        assertString(json.verification_uri_complete, '"response" body "verification_uri_complete" property', INVALID_RESPONSE, {
            body: json
        });
    }
    if (json.interval !== undefined) {
        assertNumber(json.interval, false, '"response" body "interval" property', INVALID_RESPONSE, {
            body: json
        });
    }
    return json;
}
async function deviceCodeGrantRequest(as, client, clientAuthentication, deviceCode, options) {
    assertAs(as);
    assertClient(client);
    assertString(deviceCode, '"deviceCode"');
    const parameters = new URLSearchParams(options?.additionalParameters);
    parameters.set('device_code', deviceCode);
    return tokenEndpointRequest(as, client, clientAuthentication, 'urn:ietf:params:oauth:grant-type:device_code', parameters, options);
}
async function processDeviceCodeResponse(as, client, response, options) {
    return processGenericAccessTokenResponse(as, client, response, undefined, options?.[jweDecrypt], options?.recognizedTokenTypes);
}
async function generateKeyPair(alg, options) {
    assertString(alg, '"alg"');
    const algorithm = algToSubtle(alg);
    if (alg.startsWith('PS') || alg.startsWith('RS')) {
        Object.assign(algorithm, {
            modulusLength: options?.modulusLength ?? 2048,
            publicExponent: new Uint8Array([
                0x01,
                0x00,
                0x01
            ])
        });
    }
    return crypto.subtle.generateKey(algorithm, options?.extractable ?? false, [
        'sign',
        'verify'
    ]);
}
function normalizeHtu(htu) {
    const url = new URL(htu);
    url.search = '';
    url.hash = '';
    return url.href;
}
async function validateDPoP(request, accessToken, accessTokenClaims, options) {
    const headerValue = request.headers.get('dpop');
    if (headerValue === null) {
        throw OPE('operation indicated DPoP use but the request has no DPoP HTTP Header', INVALID_REQUEST, {
            headers: request.headers
        });
    }
    if (request.headers.get('authorization')?.toLowerCase().startsWith('dpop ') === false) {
        throw OPE(`operation indicated DPoP use but the request's Authorization HTTP Header scheme is not DPoP`, INVALID_REQUEST, {
            headers: request.headers
        });
    }
    if (typeof accessTokenClaims.cnf?.jkt !== 'string') {
        throw OPE('operation indicated DPoP use but the JWT Access Token has no jkt confirmation claim', INVALID_REQUEST, {
            claims: accessTokenClaims
        });
    }
    const clockSkew = getClockSkew(options);
    const proof = await validateJwt(headerValue, checkSigningAlgorithm.bind(undefined, options?.signingAlgorithms, undefined, supported), clockSkew, getClockTolerance(options), undefined).then(checkJwtType.bind(undefined, 'dpop+jwt')).then(validatePresence.bind(undefined, [
        'iat',
        'jti',
        'ath',
        'htm',
        'htu'
    ]));
    const now = epochTime() + clockSkew;
    const diff = Math.abs(now - proof.claims.iat);
    if (diff > 300) {
        throw OPE('DPoP Proof iat is not recent enough', JWT_TIMESTAMP_CHECK, {
            now,
            claims: proof.claims,
            claim: 'iat'
        });
    }
    if (proof.claims.htm !== request.method) {
        throw OPE('DPoP Proof htm mismatch', JWT_CLAIM_COMPARISON, {
            expected: request.method,
            claims: proof.claims,
            claim: 'htm'
        });
    }
    if (typeof proof.claims.htu !== 'string' || normalizeHtu(proof.claims.htu) !== normalizeHtu(request.url)) {
        throw OPE('DPoP Proof htu mismatch', JWT_CLAIM_COMPARISON, {
            expected: normalizeHtu(request.url),
            claims: proof.claims,
            claim: 'htu'
        });
    }
    {
        const expected = b64u(await crypto.subtle.digest('SHA-256', buf(accessToken)));
        if (proof.claims.ath !== expected) {
            throw OPE('DPoP Proof ath mismatch', JWT_CLAIM_COMPARISON, {
                expected,
                claims: proof.claims,
                claim: 'ath'
            });
        }
    }
    {
        const expected = await calculateJwkThumbprint(proof.header.jwk);
        if (accessTokenClaims.cnf.jkt !== expected) {
            throw OPE('JWT Access Token confirmation mismatch', JWT_CLAIM_COMPARISON, {
                expected,
                claims: accessTokenClaims,
                claim: 'cnf.jkt'
            });
        }
    }
    const { 0: protectedHeader, 1: payload, 2: encodedSignature } = headerValue.split('.');
    const signature = b64u(encodedSignature);
    const { jwk, alg } = proof.header;
    if (!jwk) {
        throw OPE('DPoP Proof is missing the jwk header parameter', INVALID_REQUEST, {
            header: proof.header
        });
    }
    const key = await importJwk(alg, jwk);
    if (key.type !== 'public') {
        throw OPE('DPoP Proof jwk header parameter must contain a public key', INVALID_REQUEST, {
            header: proof.header
        });
    }
    await validateJwsSignature(protectedHeader, payload, key, signature);
}
async function validateJwtAccessToken(as, request, expectedAudience, options) {
    assertAs(as);
    if (!looseInstanceOf(request, Request)) {
        throw CodedTypeError('"request" must be an instance of Request', ERR_INVALID_ARG_TYPE);
    }
    assertString(expectedAudience, '"expectedAudience"');
    const authorization = request.headers.get('authorization');
    if (authorization === null) {
        throw OPE('"request" is missing an Authorization HTTP Header', INVALID_REQUEST, {
            headers: request.headers
        });
    }
    let { 0: scheme, 1: accessToken, length } = authorization.split(' ');
    scheme = scheme.toLowerCase();
    switch(scheme){
        case 'dpop':
        case 'bearer':
            break;
        default:
            throw new UnsupportedOperationError('unsupported Authorization HTTP Header scheme', {
                cause: {
                    headers: request.headers
                }
            });
    }
    if (length !== 2) {
        throw OPE('invalid Authorization HTTP Header format', INVALID_REQUEST, {
            headers: request.headers
        });
    }
    const requiredClaims = [
        'iss',
        'exp',
        'aud',
        'sub',
        'iat',
        'jti',
        'client_id'
    ];
    if (options?.requireDPoP || scheme === 'dpop' || request.headers.has('dpop')) {
        requiredClaims.push('cnf');
    }
    const { claims, header } = await validateJwt(accessToken, checkSigningAlgorithm.bind(undefined, options?.signingAlgorithms, undefined, supported), getClockSkew(options), getClockTolerance(options), undefined).then(checkJwtType.bind(undefined, 'at+jwt')).then(validatePresence.bind(undefined, requiredClaims)).then(validateIssuer.bind(undefined, as)).then(validateAudience.bind(undefined, expectedAudience)).catch(reassignRSCode);
    for (const claim of [
        'client_id',
        'jti',
        'sub'
    ]){
        if (typeof claims[claim] !== 'string') {
            throw OPE(`unexpected JWT "${claim}" claim type`, INVALID_REQUEST, {
                claims
            });
        }
    }
    if ('cnf' in claims) {
        if (!isJsonObject(claims.cnf)) {
            throw OPE('unexpected JWT "cnf" (confirmation) claim value', INVALID_REQUEST, {
                claims
            });
        }
        const { 0: cnf, length } = Object.keys(claims.cnf);
        if (length) {
            if (length !== 1) {
                throw new UnsupportedOperationError('multiple confirmation claims are not supported', {
                    cause: {
                        claims
                    }
                });
            }
            if (cnf !== 'jkt') {
                throw new UnsupportedOperationError('unsupported JWT Confirmation method', {
                    cause: {
                        claims
                    }
                });
            }
        }
    }
    const { 0: protectedHeader, 1: payload, 2: encodedSignature } = accessToken.split('.');
    const signature = b64u(encodedSignature);
    const key = await getPublicSigKeyFromIssuerJwksUri(as, options, header);
    await validateJwsSignature(protectedHeader, payload, key, signature);
    if (options?.requireDPoP || scheme === 'dpop' || claims.cnf?.jkt !== undefined || request.headers.has('dpop')) {
        await validateDPoP(request, accessToken, claims, options).catch(reassignRSCode);
    }
    return claims;
}
function reassignRSCode(err) {
    if (err instanceof OperationProcessingError && err?.code === INVALID_REQUEST) {
        err.code = INVALID_RESPONSE;
    }
    throw err;
}
async function backchannelAuthenticationRequest(as, client, clientAuthentication, parameters, options) {
    assertAs(as);
    assertClient(client);
    const url = resolveEndpoint(as, 'backchannel_authentication_endpoint', client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);
    const body = new URLSearchParams(parameters);
    body.set('client_id', client.client_id);
    const headers = prepareHeaders(options?.headers);
    headers.set('accept', 'application/json');
    return authenticatedRequest(as, client, clientAuthentication, url, body, headers, options);
}
async function processBackchannelAuthenticationResponse(as, client, response) {
    assertAs(as);
    assertClient(client);
    if (!looseInstanceOf(response, Response)) {
        throw CodedTypeError('"response" must be an instance of Response', ERR_INVALID_ARG_TYPE);
    }
    await checkOAuthBodyError(response, 200, 'Backchannel Authentication Endpoint');
    assertReadableResponse(response);
    const json = await getResponseJsonBody(response);
    assertString(json.auth_req_id, '"response" body "auth_req_id" property', INVALID_RESPONSE, {
        body: json
    });
    let expiresIn = typeof json.expires_in !== 'number' ? parseFloat(json.expires_in) : json.expires_in;
    assertNumber(expiresIn, true, '"response" body "expires_in" property', INVALID_RESPONSE, {
        body: json
    });
    json.expires_in = expiresIn;
    if (json.interval !== undefined) {
        assertNumber(json.interval, false, '"response" body "interval" property', INVALID_RESPONSE, {
            body: json
        });
    }
    return json;
}
async function backchannelAuthenticationGrantRequest(as, client, clientAuthentication, authReqId, options) {
    assertAs(as);
    assertClient(client);
    assertString(authReqId, '"authReqId"');
    const parameters = new URLSearchParams(options?.additionalParameters);
    parameters.set('auth_req_id', authReqId);
    return tokenEndpointRequest(as, client, clientAuthentication, 'urn:openid:params:grant-type:ciba', parameters, options);
}
async function processBackchannelAuthenticationGrantResponse(as, client, response, options) {
    return processGenericAccessTokenResponse(as, client, response, undefined, options?.[jweDecrypt], options?.recognizedTokenTypes);
}
async function dynamicClientRegistrationRequest(as, metadata, options) {
    assertAs(as);
    const url = resolveEndpoint(as, 'registration_endpoint', metadata.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);
    const headers = prepareHeaders(options?.headers);
    headers.set('accept', 'application/json');
    headers.set('content-type', 'application/json');
    const method = 'POST';
    if (options?.DPoP) {
        assertDPoP(options.DPoP);
        await options.DPoP.addProof(url, headers, method, options.initialAccessToken);
    }
    if (options?.initialAccessToken) {
        headers.set('authorization', `${headers.has('dpop') ? 'DPoP' : 'Bearer'} ${options.initialAccessToken}`);
    }
    const response = await (options?.[customFetch] || fetch)(url.href, {
        body: JSON.stringify(metadata),
        headers: Object.fromEntries(headers.entries()),
        method,
        redirect: 'manual',
        signal: signal(url, options?.signal)
    });
    options?.DPoP?.cacheNonce(response, url);
    return response;
}
async function processDynamicClientRegistrationResponse(response) {
    if (!looseInstanceOf(response, Response)) {
        throw CodedTypeError('"response" must be an instance of Response', ERR_INVALID_ARG_TYPE);
    }
    await checkOAuthBodyError(response, 201, 'Dynamic Client Registration Endpoint');
    assertReadableResponse(response);
    const json = await getResponseJsonBody(response);
    assertString(json.client_id, '"response" body "client_id" property', INVALID_RESPONSE, {
        body: json
    });
    if (json.client_secret !== undefined) {
        assertString(json.client_secret, '"response" body "client_secret" property', INVALID_RESPONSE, {
            body: json
        });
    }
    if (json.client_secret) {
        assertNumber(json.client_secret_expires_at, true, '"response" body "client_secret_expires_at" property', INVALID_RESPONSE, {
            body: json
        });
    }
    return json;
}
async function resourceDiscoveryRequest(resourceIdentifier, options) {
    return performDiscovery(resourceIdentifier, 'resourceIdentifier', (url)=>{
        prependWellKnown(url, '.well-known/oauth-protected-resource', true);
        return url;
    }, options);
}
async function processResourceDiscoveryResponse(expectedResourceIdentifier, response) {
    const expected = expectedResourceIdentifier;
    if (!(expected instanceof URL) && expected !== _nodiscoverycheck) {
        throw CodedTypeError('"expectedResourceIdentifier" must be an instance of URL', ERR_INVALID_ARG_TYPE);
    }
    if (!looseInstanceOf(response, Response)) {
        throw CodedTypeError('"response" must be an instance of Response', ERR_INVALID_ARG_TYPE);
    }
    if (response.status !== 200) {
        throw OPE('"response" is not a conform Resource Server Metadata response (unexpected HTTP status code)', RESPONSE_IS_NOT_CONFORM, response);
    }
    assertReadableResponse(response);
    const json = await getResponseJsonBody(response);
    assertString(json.resource, '"response" body "resource" property', INVALID_RESPONSE, {
        body: json
    });
    if (expected !== _nodiscoverycheck && new URL(json.resource).href !== expected.href) {
        throw OPE('"response" body "resource" property does not match the expected value', JSON_ATTRIBUTE_COMPARISON, {
            expected: expected.href,
            body: json,
            attribute: 'resource'
        });
    }
    return json;
}
async function getResponseJsonBody(response, check = assertApplicationJson) {
    let json;
    try {
        json = await response.json();
    } catch (cause) {
        check(response);
        throw OPE('failed to parse "response" body as JSON', PARSE_ERROR, cause);
    }
    if (!isJsonObject(json)) {
        throw OPE('"response" body must be a top level object', INVALID_RESPONSE, {
            body: json
        });
    }
    return json;
}
const _nopkce = nopkce;
const _nodiscoverycheck = Symbol();
const _expectedIssuer = Symbol(); //# sourceMappingURL=index.js.map
}),
"[project]/align/node_modules/next-auth/lib/env.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "reqWithEnvURL",
    ()=>reqWithEnvURL,
    "setEnvDefaults",
    ()=>setEnvDefaults
]);
// @ts-expect-error Next.js does not yet correctly use the `package.json#exports` field
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/align/node_modules/@auth/core/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$lib$2f$utils$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/@auth/core/lib/utils/env.js [app-route] (ecmascript)");
;
;
function reqWithEnvURL(req) {
    const url = process.env.AUTH_URL ?? process.env.NEXTAUTH_URL;
    if (!url) return req;
    const { origin: envOrigin } = new URL(url);
    const { href, origin } = req.nextUrl;
    return new __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextRequest"](href.replace(origin, envOrigin), req);
}
function setEnvDefaults(config) {
    try {
        config.secret ?? (config.secret = process.env.AUTH_SECRET ?? process.env.NEXTAUTH_SECRET);
        const url = process.env.AUTH_URL ?? process.env.NEXTAUTH_URL;
        if (!url) return;
        const { pathname } = new URL(url);
        if (pathname === "/") return;
        config.basePath || (config.basePath = pathname);
    } catch  {
    // Catching and swallowing potential URL parsing errors, we'll fall
    // back to `/api/auth` below.
    } finally{
        config.basePath || (config.basePath = "/api/auth");
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$lib$2f$utils$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setEnvDefaults"])(process.env, config, true);
    }
}
}),
"[project]/align/node_modules/next-auth/lib/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "initAuth",
    ()=>initAuth
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/align/node_modules/@auth/core/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$lib$2f$utils$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/@auth/core/lib/utils/env.js [app-route] (ecmascript)");
// @ts-expect-error Next.js does not yet correctly use the `package.json#exports` field
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/next/headers.js [app-route] (ecmascript)");
// @ts-expect-error Next.js does not yet correctly use the `package.json#exports` field
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2d$auth$2f$lib$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/next-auth/lib/env.js [app-route] (ecmascript)");
;
;
;
;
async function getSession(headers, config) {
    const url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$lib$2f$utils$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createActionURL"])("session", // @ts-expect-error `x-forwarded-proto` is not nullable, next.js sets it by default
    headers.get("x-forwarded-proto"), headers, process.env, config);
    const request = new Request(url, {
        headers: {
            cookie: headers.get("cookie") ?? ""
        }
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Auth"])(request, {
        ...config,
        callbacks: {
            ...config.callbacks,
            // Since we are server-side, we don't need to filter out the session data
            // See https://authjs.dev/getting-started/migrating-to-v5#authenticating-server-side
            // TODO: Taint the session data to prevent accidental leakage to the client
            // https://react.dev/reference/react/experimental_taintObjectReference
            async session (...args) {
                const session = // If the user defined a custom session callback, use that instead
                await config.callbacks?.session?.(...args) ?? {
                    ...args[0].session,
                    expires: args[0].session.expires?.toISOString?.() ?? args[0].session.expires
                };
                const user = args[0].user ?? args[0].token;
                return {
                    user,
                    ...session
                };
            }
        }
    });
}
function isReqWrapper(arg) {
    return typeof arg === "function";
}
function initAuth(config, onLazyLoad // To set the default env vars
) {
    if (typeof config === "function") {
        return async (...args)=>{
            if (!args.length) {
                // React Server Components
                const _headers = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headers"])();
                const _config = await config(undefined); // Review: Should we pass headers() here instead?
                onLazyLoad?.(_config);
                return getSession(_headers, _config).then((r)=>r.json());
            }
            if (args[0] instanceof Request) {
                // middleware.ts inline
                // export { auth as default } from "auth"
                const req = args[0];
                const ev = args[1];
                const _config = await config(req);
                onLazyLoad?.(_config);
                // args[0] is supposed to be NextRequest but the instanceof check is failing.
                return handleAuth([
                    req,
                    ev
                ], _config);
            }
            if (isReqWrapper(args[0])) {
                // middleware.ts wrapper/route.ts
                // import { auth } from "auth"
                // export default auth((req) => { console.log(req.auth) }})
                const userMiddlewareOrRoute = args[0];
                return async (...args)=>{
                    const _config = await config(args[0]);
                    onLazyLoad?.(_config);
                    return handleAuth(args, _config, userMiddlewareOrRoute);
                };
            }
            // API Routes, getServerSideProps
            const request = "req" in args[0] ? args[0].req : args[0];
            const response = "res" in args[0] ? args[0].res : args[1];
            const _config = await config(request);
            onLazyLoad?.(_config);
            // @ts-expect-error -- request is NextRequest
            return getSession(new Headers(request.headers), _config).then(async (authResponse)=>{
                const auth = await authResponse.json();
                for (const cookie of authResponse.headers.getSetCookie())if ("headers" in response) response.headers.append("set-cookie", cookie);
                else response.appendHeader("set-cookie", cookie);
                return auth;
            });
        };
    }
    return (...args)=>{
        if (!args.length) {
            // React Server Components
            return Promise.resolve((0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headers"])()).then((h)=>getSession(h, config).then((r)=>r.json()));
        }
        if (args[0] instanceof Request) {
            // middleware.ts inline
            // export { auth as default } from "auth"
            const req = args[0];
            const ev = args[1];
            return handleAuth([
                req,
                ev
            ], config);
        }
        if (isReqWrapper(args[0])) {
            // middleware.ts wrapper/route.ts
            // import { auth } from "auth"
            // export default auth((req) => { console.log(req.auth) }})
            const userMiddlewareOrRoute = args[0];
            return async (...args)=>{
                return handleAuth(args, config, userMiddlewareOrRoute).then((res)=>{
                    return res;
                });
            };
        }
        // API Routes, getServerSideProps
        const request = "req" in args[0] ? args[0].req : args[0];
        const response = "res" in args[0] ? args[0].res : args[1];
        return getSession(// @ts-expect-error
        new Headers(request.headers), config).then(async (authResponse)=>{
            const auth = await authResponse.json();
            for (const cookie of authResponse.headers.getSetCookie())if ("headers" in response) response.headers.append("set-cookie", cookie);
            else response.appendHeader("set-cookie", cookie);
            return auth;
        });
    };
}
async function handleAuth(args, config, userMiddlewareOrRoute) {
    const request = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2d$auth$2f$lib$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["reqWithEnvURL"])(args[0]);
    const sessionResponse = await getSession(request.headers, config);
    const auth = await sessionResponse.json();
    let authorized = true;
    if (config.callbacks?.authorized) {
        authorized = await config.callbacks.authorized({
            request,
            auth
        });
    }
    let response = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].next?.();
    if (authorized instanceof Response) {
        // User returned a custom response, like redirecting to a page or 401, respect it
        response = authorized;
        const redirect = authorized.headers.get("Location");
        const { pathname } = request.nextUrl;
        // If the user is redirecting to the same NextAuth.js action path as the current request,
        // don't allow the redirect to prevent an infinite loop
        if (redirect && isSameAuthAction(pathname, new URL(redirect).pathname, config)) {
            authorized = true;
        }
    } else if (userMiddlewareOrRoute) {
        // Execute user's middleware/handler with the augmented request
        const augmentedReq = request;
        augmentedReq.auth = auth;
        response = await userMiddlewareOrRoute(augmentedReq, args[1]) ?? __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].next();
    } else if (!authorized) {
        const signInPage = config.pages?.signIn ?? `${config.basePath}/signin`;
        if (request.nextUrl.pathname !== signInPage) {
            // Redirect to signin page by default if not authorized
            const signInUrl = request.nextUrl.clone();
            signInUrl.pathname = signInPage;
            signInUrl.searchParams.set("callbackUrl", request.nextUrl.href);
            response = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].redirect(signInUrl);
        }
    }
    const finalResponse = new Response(response?.body, response);
    // Preserve cookies from the session response
    for (const cookie of sessionResponse.headers.getSetCookie())finalResponse.headers.append("set-cookie", cookie);
    return finalResponse;
}
function isSameAuthAction(requestPath, redirectPath, config) {
    const action = redirectPath.replace(`${requestPath}/`, "");
    const pages = Object.values(config.pages ?? {});
    return (actions.has(action) || pages.includes(redirectPath)) && redirectPath === requestPath;
}
const actions = new Set([
    "providers",
    "session",
    "csrf",
    "signin",
    "signout",
    "callback",
    "verify-request",
    "error"
]);
}),
"[project]/align/node_modules/next-auth/lib/actions.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "signIn",
    ()=>signIn,
    "signOut",
    ()=>signOut,
    "update",
    ()=>update
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/align/node_modules/@auth/core/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$lib$2f$symbols$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/@auth/core/lib/symbols.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$lib$2f$utils$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/@auth/core/lib/utils/env.js [app-route] (ecmascript)");
// @ts-expect-error Next.js does not yet correctly use the `package.json#exports` field
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/next/headers.js [app-route] (ecmascript)");
// @ts-expect-error Next.js does not yet correctly use the `package.json#exports` field
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2f$dist$2f$api$2f$navigation$2e$react$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/align/node_modules/next/dist/api/navigation.react-server.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$navigation$2e$react$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/next/dist/client/components/navigation.react-server.js [app-route] (ecmascript)");
;
;
;
async function signIn(provider, options = {}, authorizationParams, config) {
    const headers = new Headers(await (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headers"])());
    const { redirect: shouldRedirect = true, redirectTo, ...rest } = options instanceof FormData ? Object.fromEntries(options) : options;
    const callbackUrl = redirectTo?.toString() ?? headers.get("Referer") ?? "/";
    const signInURL = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$lib$2f$utils$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createActionURL"])("signin", // @ts-expect-error `x-forwarded-proto` is not nullable, next.js sets it by default
    headers.get("x-forwarded-proto"), headers, process.env, config);
    if (!provider) {
        signInURL.searchParams.append("callbackUrl", callbackUrl);
        if (shouldRedirect) (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$navigation$2e$react$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["redirect"])(signInURL.toString());
        return signInURL.toString();
    }
    let url = `${signInURL}/${provider}?${new URLSearchParams(authorizationParams)}`;
    let foundProvider = {};
    for (const providerConfig of config.providers){
        const { options, ...defaults } = typeof providerConfig === "function" ? providerConfig() : providerConfig;
        const id = options?.id ?? defaults.id;
        if (id === provider) {
            foundProvider = {
                id,
                type: options?.type ?? defaults.type
            };
            break;
        }
    }
    if (!foundProvider.id) {
        const url = `${signInURL}?${new URLSearchParams({
            callbackUrl
        })}`;
        if (shouldRedirect) (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$navigation$2e$react$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["redirect"])(url);
        return url;
    }
    if (foundProvider.type === "credentials") {
        url = url.replace("signin", "callback");
    }
    headers.set("Content-Type", "application/x-www-form-urlencoded");
    const body = new URLSearchParams({
        ...rest,
        callbackUrl
    });
    const req = new Request(url, {
        method: "POST",
        headers,
        body
    });
    const res = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Auth"])(req, {
        ...config,
        raw: __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$lib$2f$symbols$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["raw"],
        skipCSRFCheck: __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$lib$2f$symbols$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["skipCSRFCheck"]
    });
    const cookieJar = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cookies"])();
    for (const c of res?.cookies ?? [])cookieJar.set(c.name, c.value, c.options);
    const responseUrl = res instanceof Response ? res.headers.get("Location") : res.redirect;
    // NOTE: if for some unexpected reason the responseUrl is not set,
    // we redirect to the original url
    const redirectUrl = responseUrl ?? url;
    if (shouldRedirect) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$navigation$2e$react$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["redirect"])(redirectUrl);
    return redirectUrl;
}
async function signOut(options, config) {
    const headers = new Headers(await (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headers"])());
    headers.set("Content-Type", "application/x-www-form-urlencoded");
    const url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$lib$2f$utils$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createActionURL"])("signout", // @ts-expect-error `x-forwarded-proto` is not nullable, next.js sets it by default
    headers.get("x-forwarded-proto"), headers, process.env, config);
    const callbackUrl = options?.redirectTo ?? headers.get("Referer") ?? "/";
    const body = new URLSearchParams({
        callbackUrl
    });
    const req = new Request(url, {
        method: "POST",
        headers,
        body
    });
    const res = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Auth"])(req, {
        ...config,
        raw: __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$lib$2f$symbols$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["raw"],
        skipCSRFCheck: __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$lib$2f$symbols$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["skipCSRFCheck"]
    });
    const cookieJar = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cookies"])();
    for (const c of res?.cookies ?? [])cookieJar.set(c.name, c.value, c.options);
    if (options?.redirect ?? true) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$navigation$2e$react$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["redirect"])(res.redirect);
    return res;
}
async function update(data, config) {
    const headers = new Headers(await (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headers"])());
    headers.set("Content-Type", "application/json");
    const url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$lib$2f$utils$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createActionURL"])("session", // @ts-expect-error `x-forwarded-proto` is not nullable, next.js sets it by default
    headers.get("x-forwarded-proto"), headers, process.env, config);
    const body = JSON.stringify({
        data
    });
    const req = new Request(url, {
        method: "POST",
        headers,
        body
    });
    const res = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Auth"])(req, {
        ...config,
        raw: __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$lib$2f$symbols$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["raw"],
        skipCSRFCheck: __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$lib$2f$symbols$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["skipCSRFCheck"]
    });
    const cookieJar = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cookies"])();
    for (const c of res?.cookies ?? [])cookieJar.set(c.name, c.value, c.options);
    return res.body;
}
}),
"[project]/align/node_modules/next-auth/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>NextAuth
]);
/**
 * _If you are looking to migrate from v4, visit the [Upgrade Guide (v5)](https://authjs.dev/getting-started/migrating-to-v5)._
 *
 * ## Installation
 *
 * ```bash npm2yarn
 * npm install next-auth@beta
 * ```
 *
 * ## Environment variable inference
 *
 * `NEXTAUTH_URL` and `NEXTAUTH_SECRET` have been inferred since v4.
 *
 * Since NextAuth.js v5 can also automatically infer environment variables that are prefixed with `AUTH_`.
 *
 * For example `AUTH_GITHUB_ID` and `AUTH_GITHUB_SECRET` will be used as the `clientId` and `clientSecret` options for the GitHub provider.
 *
 * :::tip
 * The environment variable name inferring has the following format for OAuth providers: `AUTH_{PROVIDER}_{ID|SECRET}`.
 *
 * `PROVIDER` is the uppercase snake case version of the provider's id, followed by either `ID` or `SECRET` respectively.
 * :::
 *
 * `AUTH_SECRET` and `AUTH_URL` are also aliased for `NEXTAUTH_SECRET` and `NEXTAUTH_URL` for consistency.
 *
 * To add social login to your app, the configuration becomes:
 *
 * ```ts title="auth.ts"
 * import NextAuth from "next-auth"
 * import GitHub from "next-auth/providers/github"
 * export const { handlers, auth } = NextAuth({ providers: [ GitHub ] })
 * ```
 *
 * And the `.env.local` file:
 *
 * ```sh title=".env.local"
 * AUTH_GITHUB_ID=...
 * AUTH_GITHUB_SECRET=...
 * AUTH_SECRET=...
 * ```
 *
 * :::tip
 * In production, `AUTH_SECRET` is a required environment variable - if not set, NextAuth.js will throw an error. See [MissingSecretError](https://authjs.dev/reference/core/errors#missingsecret) for more details.
 * :::
 *
 * If you need to override the default values for a provider, you can still call it as a function `GitHub({...})` as before.
 *
 * ## Lazy initialization
 * You can also initialize NextAuth.js lazily (previously known as advanced intialization), which allows you to access the request context in the configuration in some cases, like Route Handlers, Middleware, API Routes or `getServerSideProps`.
 * The above example becomes:
 *
 * ```ts title="auth.ts"
 * import NextAuth from "next-auth"
 * import GitHub from "next-auth/providers/github"
 * export const { handlers, auth } = NextAuth(req => {
 *  if (req) {
 *   console.log(req) // do something with the request
 *  }
 *  return { providers: [ GitHub ] }
 * })
 * ```
 *
 * :::tip
 * This is useful if you want to customize the configuration based on the request, for example, to add a different provider in staging/dev environments.
 * :::
 *
 * @module next-auth
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/align/node_modules/@auth/core/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$lib$2f$symbols$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/@auth/core/lib/symbols.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2d$auth$2f$lib$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/next-auth/lib/env.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2d$auth$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/next-auth/lib/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2d$auth$2f$lib$2f$actions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/next-auth/lib/actions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/@auth/core/errors.js [app-route] (ecmascript)");
;
;
;
;
;
;
function NextAuth(config) {
    if (typeof config === "function") {
        const httpHandler = async (req)=>{
            const _config = await config(req);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2d$auth$2f$lib$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setEnvDefaults"])(_config);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Auth"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2d$auth$2f$lib$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["reqWithEnvURL"])(req), _config);
        };
        return {
            handlers: {
                GET: httpHandler,
                POST: httpHandler
            },
            // @ts-expect-error
            auth: (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2d$auth$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["initAuth"])(config, (c)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2d$auth$2f$lib$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setEnvDefaults"])(c)),
            signIn: async (provider, options, authorizationParams)=>{
                const _config = await config(undefined);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2d$auth$2f$lib$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setEnvDefaults"])(_config);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2d$auth$2f$lib$2f$actions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["signIn"])(provider, options, authorizationParams, _config);
            },
            signOut: async (options)=>{
                const _config = await config(undefined);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2d$auth$2f$lib$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setEnvDefaults"])(_config);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2d$auth$2f$lib$2f$actions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["signOut"])(options, _config);
            },
            unstable_update: async (data)=>{
                const _config = await config(undefined);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2d$auth$2f$lib$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setEnvDefaults"])(_config);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2d$auth$2f$lib$2f$actions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["update"])(data, _config);
            }
        };
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2d$auth$2f$lib$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setEnvDefaults"])(config);
    const httpHandler = (req)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Auth"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2d$auth$2f$lib$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["reqWithEnvURL"])(req), config);
    return {
        handlers: {
            GET: httpHandler,
            POST: httpHandler
        },
        // @ts-expect-error
        auth: (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2d$auth$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["initAuth"])(config),
        signIn: (provider, options, authorizationParams)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2d$auth$2f$lib$2f$actions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["signIn"])(provider, options, authorizationParams, config);
        },
        signOut: (options)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2d$auth$2f$lib$2f$actions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["signOut"])(options, config);
        },
        unstable_update: (data)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$next$2d$auth$2f$lib$2f$actions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["update"])(data, config);
        }
    };
}
}),
"[project]/align/node_modules/next-auth/providers/google.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$auth$2f$core$2f$providers$2f$google$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/@auth/core/providers/google.js [app-route] (ecmascript)");
;
;
}),
"[project]/align/node_modules/@auth/prisma-adapter/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PrismaAdapter",
    ()=>PrismaAdapter
]);
function PrismaAdapter(prisma) {
    const p = prisma;
    return {
        // We need to let Prisma generate the ID because our default UUID is incompatible with MongoDB
        createUser: ({ id, ...data })=>p.user.create(stripUndefined(data)),
        getUser: (id)=>p.user.findUnique({
                where: {
                    id
                }
            }),
        getUserByEmail: (email)=>p.user.findUnique({
                where: {
                    email
                }
            }),
        async getUserByAccount (provider_providerAccountId) {
            const account = await p.account.findUnique({
                where: {
                    provider_providerAccountId
                },
                include: {
                    user: true
                }
            });
            return account?.user ?? null;
        },
        updateUser: ({ id, ...data })=>p.user.update({
                where: {
                    id
                },
                ...stripUndefined(data)
            }),
        deleteUser: (id)=>p.user.delete({
                where: {
                    id
                }
            }),
        linkAccount: (data)=>p.account.create({
                data
            }),
        unlinkAccount: (provider_providerAccountId)=>p.account.delete({
                where: {
                    provider_providerAccountId
                }
            }),
        async getSessionAndUser (sessionToken) {
            const userAndSession = await p.session.findUnique({
                where: {
                    sessionToken
                },
                include: {
                    user: true
                }
            });
            if (!userAndSession) return null;
            const { user, ...session } = userAndSession;
            return {
                user,
                session
            };
        },
        createSession: (data)=>p.session.create(stripUndefined(data)),
        updateSession: (data)=>p.session.update({
                where: {
                    sessionToken: data.sessionToken
                },
                ...stripUndefined(data)
            }),
        deleteSession: (sessionToken)=>p.session.delete({
                where: {
                    sessionToken
                }
            }),
        async createVerificationToken (data) {
            const verificationToken = await p.verificationToken.create(stripUndefined(data));
            if ("id" in verificationToken && verificationToken.id) delete verificationToken.id;
            return verificationToken;
        },
        async useVerificationToken (identifier_token) {
            try {
                const verificationToken = await p.verificationToken.delete({
                    where: {
                        identifier_token
                    }
                });
                if ("id" in verificationToken && verificationToken.id) delete verificationToken.id;
                return verificationToken;
            } catch (error) {
                // If token already used/deleted, just return null
                // https://www.prisma.io/docs/reference/api-reference/error-reference#p2025
                if (error && typeof error === "object" && "code" in error && error.code === "P2025") return null;
                throw error;
            }
        },
        async getAccount (providerAccountId, provider) {
            return p.account.findFirst({
                where: {
                    providerAccountId,
                    provider
                }
            });
        },
        async createAuthenticator (data) {
            return p.authenticator.create(stripUndefined(data));
        },
        async getAuthenticator (credentialID) {
            return p.authenticator.findUnique({
                where: {
                    credentialID
                }
            });
        },
        async listAuthenticatorsByUserId (userId) {
            return p.authenticator.findMany({
                where: {
                    userId
                }
            });
        },
        async updateAuthenticatorCounter (credentialID, counter) {
            return p.authenticator.update({
                where: {
                    credentialID
                },
                data: {
                    counter
                }
            });
        }
    };
}
/** @see https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/null-and-undefined */ function stripUndefined(obj) {
    const data = {};
    for(const key in obj)if (obj[key] !== undefined) data[key] = obj[key];
    return {
        data
    };
}
}),
"[project]/align/node_modules/@prisma/driver-adapter-utils/node_modules/@prisma/debug/dist/index.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Debug",
    ()=>Debug,
    "clearLogs",
    ()=>clearLogs,
    "default",
    ()=>index_default,
    "getLogs",
    ()=>getLogs
]);
var __defProp = Object.defineProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
// ../../node_modules/.pnpm/kleur@4.1.5/node_modules/kleur/colors.mjs
var colors_exports = {};
__export(colors_exports, {
    $: ()=>$,
    bgBlack: ()=>bgBlack,
    bgBlue: ()=>bgBlue,
    bgCyan: ()=>bgCyan,
    bgGreen: ()=>bgGreen,
    bgMagenta: ()=>bgMagenta,
    bgRed: ()=>bgRed,
    bgWhite: ()=>bgWhite,
    bgYellow: ()=>bgYellow,
    black: ()=>black,
    blue: ()=>blue,
    bold: ()=>bold,
    cyan: ()=>cyan,
    dim: ()=>dim,
    gray: ()=>gray,
    green: ()=>green,
    grey: ()=>grey,
    hidden: ()=>hidden,
    inverse: ()=>inverse,
    italic: ()=>italic,
    magenta: ()=>magenta,
    red: ()=>red,
    reset: ()=>reset,
    strikethrough: ()=>strikethrough,
    underline: ()=>underline,
    white: ()=>white,
    yellow: ()=>yellow
});
var FORCE_COLOR;
var NODE_DISABLE_COLORS;
var NO_COLOR;
var TERM;
var isTTY = true;
if (typeof process !== "undefined") {
    ({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
    isTTY = process.stdout && process.stdout.isTTY;
}
var $ = {
    enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== "dumb" && (FORCE_COLOR != null && FORCE_COLOR !== "0" || isTTY)
};
function init(x, y) {
    let rgx = new RegExp(`\\x1b\\[${y}m`, "g");
    let open = `\x1B[${x}m`, close = `\x1B[${y}m`;
    return function(txt) {
        if (!$.enabled || txt == null) return txt;
        return open + (!!~("" + txt).indexOf(close) ? txt.replace(rgx, close + open) : txt) + close;
    };
}
var reset = init(0, 0);
var bold = init(1, 22);
var dim = init(2, 22);
var italic = init(3, 23);
var underline = init(4, 24);
var inverse = init(7, 27);
var hidden = init(8, 28);
var strikethrough = init(9, 29);
var black = init(30, 39);
var red = init(31, 39);
var green = init(32, 39);
var yellow = init(33, 39);
var blue = init(34, 39);
var magenta = init(35, 39);
var cyan = init(36, 39);
var white = init(37, 39);
var gray = init(90, 39);
var grey = init(90, 39);
var bgBlack = init(40, 49);
var bgRed = init(41, 49);
var bgGreen = init(42, 49);
var bgYellow = init(43, 49);
var bgBlue = init(44, 49);
var bgMagenta = init(45, 49);
var bgCyan = init(46, 49);
var bgWhite = init(47, 49);
// src/index.ts
var MAX_ARGS_HISTORY = 100;
var COLORS = [
    "green",
    "yellow",
    "blue",
    "magenta",
    "cyan",
    "red"
];
var argsHistory = [];
var lastTimestamp = Date.now();
var lastColor = 0;
var processEnv = typeof process !== "undefined" ? process.env : {};
globalThis.DEBUG ??= processEnv.DEBUG ?? "";
globalThis.DEBUG_COLORS ??= processEnv.DEBUG_COLORS ? processEnv.DEBUG_COLORS === "true" : true;
var topProps = {
    enable (namespace) {
        if (typeof namespace === "string") {
            globalThis.DEBUG = namespace;
        }
    },
    disable () {
        const prev = globalThis.DEBUG;
        globalThis.DEBUG = "";
        return prev;
    },
    // this is the core logic to check if logging should happen or not
    enabled (namespace) {
        const listenedNamespaces = globalThis.DEBUG.split(",").map((s)=>{
            return s.replace(/[.+?^${}()|[\]\\]/g, "\\$&");
        });
        const isListened = listenedNamespaces.some((listenedNamespace)=>{
            if (listenedNamespace === "" || listenedNamespace[0] === "-") return false;
            return namespace.match(RegExp(listenedNamespace.split("*").join(".*") + "$"));
        });
        const isExcluded = listenedNamespaces.some((listenedNamespace)=>{
            if (listenedNamespace === "" || listenedNamespace[0] !== "-") return false;
            return namespace.match(RegExp(listenedNamespace.slice(1).split("*").join(".*") + "$"));
        });
        return isListened && !isExcluded;
    },
    log: (...args)=>{
        const [namespace, format, ...rest] = args;
        const logWithFormatting = console.warn ?? console.log;
        logWithFormatting(`${namespace} ${format}`, ...rest);
    },
    formatters: {}
};
function debugCreate(namespace) {
    const instanceProps = {
        color: COLORS[lastColor++ % COLORS.length],
        enabled: topProps.enabled(namespace),
        namespace,
        log: topProps.log,
        extend: ()=>{}
    };
    const debugCall = (...args)=>{
        const { enabled, namespace: namespace2, color, log } = instanceProps;
        if (args.length !== 0) {
            argsHistory.push([
                namespace2,
                ...args
            ]);
        }
        if (argsHistory.length > MAX_ARGS_HISTORY) {
            argsHistory.shift();
        }
        if (topProps.enabled(namespace2) || enabled) {
            const stringArgs = args.map((arg)=>{
                if (typeof arg === "string") {
                    return arg;
                }
                return safeStringify(arg);
            });
            const ms = `+${Date.now() - lastTimestamp}ms`;
            lastTimestamp = Date.now();
            if (globalThis.DEBUG_COLORS) {
                log(colors_exports[color](bold(namespace2)), ...stringArgs, colors_exports[color](ms));
            } else {
                log(namespace2, ...stringArgs, ms);
            }
        }
    };
    return new Proxy(debugCall, {
        get: (_, prop)=>instanceProps[prop],
        set: (_, prop, value)=>instanceProps[prop] = value
    });
}
var Debug = new Proxy(debugCreate, {
    get: (_, prop)=>topProps[prop],
    set: (_, prop, value)=>topProps[prop] = value
});
function safeStringify(value, indent = 2) {
    const cache = /* @__PURE__ */ new Set();
    return JSON.stringify(value, (key, value2)=>{
        if (typeof value2 === "object" && value2 !== null) {
            if (cache.has(value2)) {
                return `[Circular *]`;
            }
            cache.add(value2);
        } else if (typeof value2 === "bigint") {
            return value2.toString();
        }
        return value2;
    }, indent);
}
function getLogs(numChars = 7500) {
    const logs = argsHistory.map(([namespace, ...args])=>{
        return `${namespace} ${args.map((arg)=>{
            if (typeof arg === "string") {
                return arg;
            } else {
                return JSON.stringify(arg);
            }
        }).join(" ")}`;
    }).join("\n");
    if (logs.length < numChars) {
        return logs;
    }
    return logs.slice(-numChars);
}
function clearLogs() {
    argsHistory.length = 0;
}
var index_default = Debug;
;
}),
"[project]/align/node_modules/@prisma/driver-adapter-utils/dist/index.mjs [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ColumnTypeEnum",
    ()=>ColumnTypeEnum,
    "DriverAdapterError",
    ()=>DriverAdapterError,
    "bindAdapter",
    ()=>bindAdapter,
    "bindMigrationAwareSqlAdapterFactory",
    ()=>bindMigrationAwareSqlAdapterFactory,
    "bindSqlAdapterFactory",
    ()=>bindSqlAdapterFactory,
    "err",
    ()=>err,
    "isDriverAdapterError",
    ()=>isDriverAdapterError,
    "mockAdapter",
    ()=>mockAdapter,
    "mockAdapterErrors",
    ()=>mockAdapterErrors,
    "mockAdapterFactory",
    ()=>mockAdapterFactory,
    "mockMigrationAwareAdapterFactory",
    ()=>mockMigrationAwareAdapterFactory,
    "ok",
    ()=>ok
]);
// src/debug.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$node_modules$2f40$prisma$2f$debug$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/@prisma/driver-adapter-utils/node_modules/@prisma/debug/dist/index.mjs [app-route] (ecmascript)");
;
// src/error.ts
var DriverAdapterError = class extends Error {
    name = "DriverAdapterError";
    cause;
    constructor(payload){
        super(typeof payload["message"] === "string" ? payload["message"] : payload.kind);
        this.cause = payload;
    }
};
function isDriverAdapterError(error) {
    return error["name"] === "DriverAdapterError" && typeof error["cause"] === "object";
}
// src/result.ts
function ok(value) {
    return {
        ok: true,
        value,
        map (fn) {
            return ok(fn(value));
        },
        flatMap (fn) {
            return fn(value);
        }
    };
}
function err(error) {
    return {
        ok: false,
        error,
        map () {
            return err(error);
        },
        flatMap () {
            return err(error);
        }
    };
}
// src/binder.ts
var debug = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$node_modules$2f40$prisma$2f$debug$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Debug"])("driver-adapter-utils");
var ErrorRegistryInternal = class {
    registeredErrors = [];
    consumeError(id) {
        return this.registeredErrors[id];
    }
    registerNewError(error) {
        let i = 0;
        while(this.registeredErrors[i] !== void 0){
            i++;
        }
        this.registeredErrors[i] = {
            error
        };
        return i;
    }
};
function copySymbolsFromSource(source, target) {
    const symbols = Object.getOwnPropertySymbols(source);
    const symbolObject = Object.fromEntries(symbols.map((symbol)=>[
            symbol,
            true
        ]));
    Object.assign(target, symbolObject);
}
var bindMigrationAwareSqlAdapterFactory = (adapterFactory)=>{
    const errorRegistry = new ErrorRegistryInternal();
    const boundFactory = {
        adapterName: adapterFactory.adapterName,
        provider: adapterFactory.provider,
        errorRegistry,
        connect: async (...args)=>{
            const ctx = await wrapAsync(errorRegistry, adapterFactory.connect.bind(adapterFactory))(...args);
            return ctx.map((ctx2)=>bindAdapter(ctx2, errorRegistry));
        },
        connectToShadowDb: async (...args)=>{
            const ctx = await wrapAsync(errorRegistry, adapterFactory.connectToShadowDb.bind(adapterFactory))(...args);
            return ctx.map((ctx2)=>bindAdapter(ctx2, errorRegistry));
        }
    };
    copySymbolsFromSource(adapterFactory, boundFactory);
    return boundFactory;
};
var bindSqlAdapterFactory = (adapterFactory)=>{
    const errorRegistry = new ErrorRegistryInternal();
    const boundFactory = {
        adapterName: adapterFactory.adapterName,
        provider: adapterFactory.provider,
        errorRegistry,
        connect: async (...args)=>{
            const ctx = await wrapAsync(errorRegistry, adapterFactory.connect.bind(adapterFactory))(...args);
            return ctx.map((ctx2)=>bindAdapter(ctx2, errorRegistry));
        }
    };
    copySymbolsFromSource(adapterFactory, boundFactory);
    return boundFactory;
};
var bindAdapter = (adapter, errorRegistry = new ErrorRegistryInternal())=>{
    const boundAdapter = {
        adapterName: adapter.adapterName,
        errorRegistry,
        queryRaw: wrapAsync(errorRegistry, adapter.queryRaw.bind(adapter)),
        executeRaw: wrapAsync(errorRegistry, adapter.executeRaw.bind(adapter)),
        executeScript: wrapAsync(errorRegistry, adapter.executeScript.bind(adapter)),
        dispose: wrapAsync(errorRegistry, adapter.dispose.bind(adapter)),
        provider: adapter.provider,
        startTransaction: async (...args)=>{
            const ctx = await wrapAsync(errorRegistry, adapter.startTransaction.bind(adapter))(...args);
            return ctx.map((ctx2)=>bindTransaction(errorRegistry, ctx2));
        }
    };
    if (adapter.getConnectionInfo) {
        boundAdapter.getConnectionInfo = wrapSync(errorRegistry, adapter.getConnectionInfo.bind(adapter));
    }
    return boundAdapter;
};
var bindTransaction = (errorRegistry, transaction)=>{
    return {
        adapterName: transaction.adapterName,
        provider: transaction.provider,
        options: transaction.options,
        queryRaw: wrapAsync(errorRegistry, transaction.queryRaw.bind(transaction)),
        executeRaw: wrapAsync(errorRegistry, transaction.executeRaw.bind(transaction)),
        commit: wrapAsync(errorRegistry, transaction.commit.bind(transaction)),
        rollback: wrapAsync(errorRegistry, transaction.rollback.bind(transaction))
    };
};
function wrapAsync(registry, fn) {
    return async (...args)=>{
        try {
            return ok(await fn(...args));
        } catch (error) {
            debug("[error@wrapAsync]", error);
            if (isDriverAdapterError(error)) {
                return err(error.cause);
            }
            const id = registry.registerNewError(error);
            return err({
                kind: "GenericJs",
                id
            });
        }
    };
}
function wrapSync(registry, fn) {
    return (...args)=>{
        try {
            return ok(fn(...args));
        } catch (error) {
            debug("[error@wrapSync]", error);
            if (isDriverAdapterError(error)) {
                return err(error.cause);
            }
            const id = registry.registerNewError(error);
            return err({
                kind: "GenericJs",
                id
            });
        }
    };
}
// src/const.ts
var ColumnTypeEnum = {
    // Scalars
    Int32: 0,
    Int64: 1,
    Float: 2,
    Double: 3,
    Numeric: 4,
    Boolean: 5,
    Character: 6,
    Text: 7,
    Date: 8,
    Time: 9,
    DateTime: 10,
    Json: 11,
    Enum: 12,
    Bytes: 13,
    Set: 14,
    Uuid: 15,
    // Arrays
    Int32Array: 64,
    Int64Array: 65,
    FloatArray: 66,
    DoubleArray: 67,
    NumericArray: 68,
    BooleanArray: 69,
    CharacterArray: 70,
    TextArray: 71,
    DateArray: 72,
    TimeArray: 73,
    DateTimeArray: 74,
    JsonArray: 75,
    EnumArray: 76,
    BytesArray: 77,
    UuidArray: 78,
    // Custom
    UnknownNumber: 128
};
// src/mock.ts
var mockAdapterErrors = {
    queryRaw: new Error("Not implemented: queryRaw"),
    executeRaw: new Error("Not implemented: executeRaw"),
    startTransaction: new Error("Not implemented: startTransaction"),
    executeScript: new Error("Not implemented: executeScript"),
    dispose: new Error("Not implemented: dispose")
};
function mockAdapter(provider) {
    return {
        provider,
        adapterName: "@prisma/adapter-mock",
        queryRaw: ()=>Promise.reject(mockAdapterErrors.queryRaw),
        executeRaw: ()=>Promise.reject(mockAdapterErrors.executeRaw),
        startTransaction: ()=>Promise.reject(mockAdapterErrors.startTransaction),
        executeScript: ()=>Promise.reject(mockAdapterErrors.executeScript),
        dispose: ()=>Promise.reject(mockAdapterErrors.dispose),
        [Symbol.for("adapter.mockAdapter")]: true
    };
}
function mockAdapterFactory(provider) {
    return {
        provider,
        adapterName: "@prisma/adapter-mock",
        connect: ()=>Promise.resolve(mockAdapter(provider)),
        [Symbol.for("adapter.mockAdapterFactory")]: true
    };
}
function mockMigrationAwareAdapterFactory(provider) {
    return {
        provider,
        adapterName: "@prisma/adapter-mock",
        connect: ()=>Promise.resolve(mockAdapter(provider)),
        connectToShadowDb: ()=>Promise.resolve(mockAdapter(provider)),
        [Symbol.for("adapter.mockMigrationAwareAdapterFactory")]: true
    };
}
;
}),
"[project]/align/node_modules/@prisma/adapter-pg/dist/index.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

__turbopack_context__.s([
    "PrismaPg",
    ()=>PrismaPgAdapterFactory
]);
// src/pg.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$node_modules$2f40$prisma$2f$debug$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/@prisma/driver-adapter-utils/node_modules/@prisma/debug/dist/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/align/node_modules/@prisma/driver-adapter-utils/dist/index.mjs [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$2c$__$5b$project$5d2f$align$2f$node_modules$2f$pg$29$__ = __turbopack_context__.i("[externals]/pg [external] (pg, esm_import, [project]/align/node_modules/pg)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$postgres$2d$array$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/postgres-array/index.js [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$2c$__$5b$project$5d2f$align$2f$node_modules$2f$pg$29$__
]);
[__TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$2c$__$5b$project$5d2f$align$2f$node_modules$2f$pg$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__;
;
;
// package.json
var name = "@prisma/adapter-pg";
// src/constants.ts
var FIRST_NORMAL_OBJECT_ID = 16384;
;
;
;
var { types } = __TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$2c$__$5b$project$5d2f$align$2f$node_modules$2f$pg$29$__["default"];
var { builtins: ScalarColumnType, getTypeParser } = types;
var AdditionalScalarColumnType = {
    NAME: 19
};
var ArrayColumnType = {
    BIT_ARRAY: 1561,
    BOOL_ARRAY: 1e3,
    BYTEA_ARRAY: 1001,
    BPCHAR_ARRAY: 1014,
    CHAR_ARRAY: 1002,
    CIDR_ARRAY: 651,
    DATE_ARRAY: 1182,
    FLOAT4_ARRAY: 1021,
    FLOAT8_ARRAY: 1022,
    INET_ARRAY: 1041,
    INT2_ARRAY: 1005,
    INT4_ARRAY: 1007,
    INT8_ARRAY: 1016,
    JSONB_ARRAY: 3807,
    JSON_ARRAY: 199,
    MONEY_ARRAY: 791,
    NUMERIC_ARRAY: 1231,
    OID_ARRAY: 1028,
    TEXT_ARRAY: 1009,
    TIMESTAMP_ARRAY: 1115,
    TIMESTAMPTZ_ARRAY: 1185,
    TIME_ARRAY: 1183,
    UUID_ARRAY: 2951,
    VARBIT_ARRAY: 1563,
    VARCHAR_ARRAY: 1015,
    XML_ARRAY: 143
};
var UnsupportedNativeDataType = class _UnsupportedNativeDataType extends Error {
    // map of type codes to type names
    static typeNames = {
        16: "bool",
        17: "bytea",
        18: "char",
        19: "name",
        20: "int8",
        21: "int2",
        22: "int2vector",
        23: "int4",
        24: "regproc",
        25: "text",
        26: "oid",
        27: "tid",
        28: "xid",
        29: "cid",
        30: "oidvector",
        32: "pg_ddl_command",
        71: "pg_type",
        75: "pg_attribute",
        81: "pg_proc",
        83: "pg_class",
        114: "json",
        142: "xml",
        194: "pg_node_tree",
        269: "table_am_handler",
        325: "index_am_handler",
        600: "point",
        601: "lseg",
        602: "path",
        603: "box",
        604: "polygon",
        628: "line",
        650: "cidr",
        700: "float4",
        701: "float8",
        705: "unknown",
        718: "circle",
        774: "macaddr8",
        790: "money",
        829: "macaddr",
        869: "inet",
        1033: "aclitem",
        1042: "bpchar",
        1043: "varchar",
        1082: "date",
        1083: "time",
        1114: "timestamp",
        1184: "timestamptz",
        1186: "interval",
        1266: "timetz",
        1560: "bit",
        1562: "varbit",
        1700: "numeric",
        1790: "refcursor",
        2202: "regprocedure",
        2203: "regoper",
        2204: "regoperator",
        2205: "regclass",
        2206: "regtype",
        2249: "record",
        2275: "cstring",
        2276: "any",
        2277: "anyarray",
        2278: "void",
        2279: "trigger",
        2280: "language_handler",
        2281: "internal",
        2283: "anyelement",
        2287: "_record",
        2776: "anynonarray",
        2950: "uuid",
        2970: "txid_snapshot",
        3115: "fdw_handler",
        3220: "pg_lsn",
        3310: "tsm_handler",
        3361: "pg_ndistinct",
        3402: "pg_dependencies",
        3500: "anyenum",
        3614: "tsvector",
        3615: "tsquery",
        3642: "gtsvector",
        3734: "regconfig",
        3769: "regdictionary",
        3802: "jsonb",
        3831: "anyrange",
        3838: "event_trigger",
        3904: "int4range",
        3906: "numrange",
        3908: "tsrange",
        3910: "tstzrange",
        3912: "daterange",
        3926: "int8range",
        4072: "jsonpath",
        4089: "regnamespace",
        4096: "regrole",
        4191: "regcollation",
        4451: "int4multirange",
        4532: "nummultirange",
        4533: "tsmultirange",
        4534: "tstzmultirange",
        4535: "datemultirange",
        4536: "int8multirange",
        4537: "anymultirange",
        4538: "anycompatiblemultirange",
        4600: "pg_brin_bloom_summary",
        4601: "pg_brin_minmax_multi_summary",
        5017: "pg_mcv_list",
        5038: "pg_snapshot",
        5069: "xid8",
        5077: "anycompatible",
        5078: "anycompatiblearray",
        5079: "anycompatiblenonarray",
        5080: "anycompatiblerange"
    };
    type;
    constructor(code){
        super();
        this.type = _UnsupportedNativeDataType.typeNames[code] || "Unknown";
        this.message = `Unsupported column type ${this.type}`;
    }
};
function fieldToColumnType(fieldTypeId) {
    switch(fieldTypeId){
        case ScalarColumnType.INT2:
        case ScalarColumnType.INT4:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].Int32;
        case ScalarColumnType.INT8:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].Int64;
        case ScalarColumnType.FLOAT4:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].Float;
        case ScalarColumnType.FLOAT8:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].Double;
        case ScalarColumnType.BOOL:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].Boolean;
        case ScalarColumnType.DATE:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].Date;
        case ScalarColumnType.TIME:
        case ScalarColumnType.TIMETZ:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].Time;
        case ScalarColumnType.TIMESTAMP:
        case ScalarColumnType.TIMESTAMPTZ:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].DateTime;
        case ScalarColumnType.NUMERIC:
        case ScalarColumnType.MONEY:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].Numeric;
        case ScalarColumnType.JSON:
        case ScalarColumnType.JSONB:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].Json;
        case ScalarColumnType.UUID:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].Uuid;
        case ScalarColumnType.OID:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].Int64;
        case ScalarColumnType.BPCHAR:
        case ScalarColumnType.TEXT:
        case ScalarColumnType.VARCHAR:
        case ScalarColumnType.BIT:
        case ScalarColumnType.VARBIT:
        case ScalarColumnType.INET:
        case ScalarColumnType.CIDR:
        case ScalarColumnType.XML:
        case AdditionalScalarColumnType.NAME:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].Text;
        case ScalarColumnType.BYTEA:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].Bytes;
        case ArrayColumnType.INT2_ARRAY:
        case ArrayColumnType.INT4_ARRAY:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].Int32Array;
        case ArrayColumnType.FLOAT4_ARRAY:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].FloatArray;
        case ArrayColumnType.FLOAT8_ARRAY:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].DoubleArray;
        case ArrayColumnType.NUMERIC_ARRAY:
        case ArrayColumnType.MONEY_ARRAY:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].NumericArray;
        case ArrayColumnType.BOOL_ARRAY:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].BooleanArray;
        case ArrayColumnType.CHAR_ARRAY:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].CharacterArray;
        case ArrayColumnType.BPCHAR_ARRAY:
        case ArrayColumnType.TEXT_ARRAY:
        case ArrayColumnType.VARCHAR_ARRAY:
        case ArrayColumnType.VARBIT_ARRAY:
        case ArrayColumnType.BIT_ARRAY:
        case ArrayColumnType.INET_ARRAY:
        case ArrayColumnType.CIDR_ARRAY:
        case ArrayColumnType.XML_ARRAY:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].TextArray;
        case ArrayColumnType.DATE_ARRAY:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].DateArray;
        case ArrayColumnType.TIME_ARRAY:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].TimeArray;
        case ArrayColumnType.TIMESTAMP_ARRAY:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].DateTimeArray;
        case ArrayColumnType.TIMESTAMPTZ_ARRAY:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].DateTimeArray;
        case ArrayColumnType.JSON_ARRAY:
        case ArrayColumnType.JSONB_ARRAY:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].JsonArray;
        case ArrayColumnType.BYTEA_ARRAY:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].BytesArray;
        case ArrayColumnType.UUID_ARRAY:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].UuidArray;
        case ArrayColumnType.INT8_ARRAY:
        case ArrayColumnType.OID_ARRAY:
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].Int64Array;
        default:
            if (fieldTypeId >= FIRST_NORMAL_OBJECT_ID) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ColumnTypeEnum"].Text;
            }
            throw new UnsupportedNativeDataType(fieldTypeId);
    }
}
function normalize_array(element_normalizer) {
    return (str)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$postgres$2d$array$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parse"])(str, element_normalizer);
}
function normalize_numeric(numeric) {
    return numeric;
}
function normalize_date(date) {
    return date;
}
function normalize_timestamp(time) {
    return `${time.replace(" ", "T")}+00:00`;
}
function normalize_timestamptz(time) {
    return time.replace(" ", "T").replace(/[+-]\d{2}(:\d{2})?$/, "+00:00");
}
function normalize_time(time) {
    return time;
}
function normalize_timez(time) {
    return time.replace(/[+-]\d{2}(:\d{2})?$/, "");
}
function normalize_money(money) {
    return money.slice(1);
}
function normalize_xml(xml) {
    return xml;
}
function toJson(json) {
    return json;
}
var parsePgBytes = getTypeParser(ScalarColumnType.BYTEA);
var normalizeByteaArray = getTypeParser(ArrayColumnType.BYTEA_ARRAY);
function convertBytes(serializedBytes) {
    return parsePgBytes(serializedBytes);
}
function normalizeBit(bit) {
    return bit;
}
var customParsers = {
    [ScalarColumnType.NUMERIC]: normalize_numeric,
    [ArrayColumnType.NUMERIC_ARRAY]: normalize_array(normalize_numeric),
    [ScalarColumnType.TIME]: normalize_time,
    [ArrayColumnType.TIME_ARRAY]: normalize_array(normalize_time),
    [ScalarColumnType.TIMETZ]: normalize_timez,
    [ScalarColumnType.DATE]: normalize_date,
    [ArrayColumnType.DATE_ARRAY]: normalize_array(normalize_date),
    [ScalarColumnType.TIMESTAMP]: normalize_timestamp,
    [ArrayColumnType.TIMESTAMP_ARRAY]: normalize_array(normalize_timestamp),
    [ScalarColumnType.TIMESTAMPTZ]: normalize_timestamptz,
    [ArrayColumnType.TIMESTAMPTZ_ARRAY]: normalize_array(normalize_timestamptz),
    [ScalarColumnType.MONEY]: normalize_money,
    [ArrayColumnType.MONEY_ARRAY]: normalize_array(normalize_money),
    [ScalarColumnType.JSON]: toJson,
    [ArrayColumnType.JSON_ARRAY]: normalize_array(toJson),
    [ScalarColumnType.JSONB]: toJson,
    [ArrayColumnType.JSONB_ARRAY]: normalize_array(toJson),
    [ScalarColumnType.BYTEA]: convertBytes,
    [ArrayColumnType.BYTEA_ARRAY]: normalizeByteaArray,
    [ArrayColumnType.BIT_ARRAY]: normalize_array(normalizeBit),
    [ArrayColumnType.VARBIT_ARRAY]: normalize_array(normalizeBit),
    [ArrayColumnType.XML_ARRAY]: normalize_array(normalize_xml)
};
function mapArg(arg, argType) {
    if (arg === null) {
        return null;
    }
    if (Array.isArray(arg) && argType.arity === "list") {
        return arg.map((value)=>mapArg(value, argType));
    }
    if (typeof arg === "string" && argType.scalarType === "datetime") {
        arg = new Date(arg);
    }
    if (arg instanceof Date) {
        switch(argType.dbType){
            case "TIME":
            case "TIMETZ":
                return formatTime(arg);
            case "DATE":
                return formatDate(arg);
            default:
                return formatDateTime(arg);
        }
    }
    if (typeof arg === "string" && argType.scalarType === "bytes") {
        return Buffer.from(arg, "base64");
    }
    if (ArrayBuffer.isView(arg)) {
        return new Uint8Array(arg.buffer, arg.byteOffset, arg.byteLength);
    }
    return arg;
}
function formatDateTime(date) {
    const pad = (n, z = 2)=>String(n).padStart(z, "0");
    const ms = date.getUTCMilliseconds();
    return pad(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1) + "-" + pad(date.getUTCDate()) + " " + pad(date.getUTCHours()) + ":" + pad(date.getUTCMinutes()) + ":" + pad(date.getUTCSeconds()) + (ms ? "." + String(ms).padStart(3, "0") : "");
}
function formatDate(date) {
    const pad = (n, z = 2)=>String(n).padStart(z, "0");
    return pad(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1) + "-" + pad(date.getUTCDate());
}
function formatTime(date) {
    const pad = (n, z = 2)=>String(n).padStart(z, "0");
    const ms = date.getUTCMilliseconds();
    return pad(date.getUTCHours()) + ":" + pad(date.getUTCMinutes()) + ":" + pad(date.getUTCSeconds()) + (ms ? "." + String(ms).padStart(3, "0") : "");
}
// src/errors.ts
var TLS_ERRORS = /* @__PURE__ */ new Set([
    "UNABLE_TO_GET_ISSUER_CERT",
    "UNABLE_TO_GET_CRL",
    "UNABLE_TO_DECRYPT_CERT_SIGNATURE",
    "UNABLE_TO_DECRYPT_CRL_SIGNATURE",
    "UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY",
    "CERT_SIGNATURE_FAILURE",
    "CRL_SIGNATURE_FAILURE",
    "CERT_NOT_YET_VALID",
    "CERT_HAS_EXPIRED",
    "CRL_NOT_YET_VALID",
    "CRL_HAS_EXPIRED",
    "ERROR_IN_CERT_NOT_BEFORE_FIELD",
    "ERROR_IN_CERT_NOT_AFTER_FIELD",
    "ERROR_IN_CRL_LAST_UPDATE_FIELD",
    "ERROR_IN_CRL_NEXT_UPDATE_FIELD",
    "DEPTH_ZERO_SELF_SIGNED_CERT",
    "SELF_SIGNED_CERT_IN_CHAIN",
    "UNABLE_TO_GET_ISSUER_CERT_LOCALLY",
    "UNABLE_TO_VERIFY_LEAF_SIGNATURE",
    "CERT_CHAIN_TOO_LONG",
    "CERT_REVOKED",
    "INVALID_CA",
    "INVALID_PURPOSE",
    "CERT_UNTRUSTED",
    "CERT_REJECTED",
    "HOSTNAME_MISMATCH",
    "ERR_TLS_CERT_ALTNAME_FORMAT",
    "ERR_TLS_CERT_ALTNAME_INVALID"
]);
var SOCKET_ERRORS = /* @__PURE__ */ new Set([
    "ENOTFOUND",
    "ECONNREFUSED",
    "ECONNRESET",
    "ETIMEDOUT"
]);
function convertDriverError(error) {
    if (isSocketError(error)) {
        return mapSocketError(error);
    }
    if (isTlsError(error)) {
        return {
            kind: "TlsConnectionError",
            reason: error.message
        };
    }
    if (isDriverError(error)) {
        return {
            originalCode: error.code,
            originalMessage: error.message,
            ...mapDriverError(error)
        };
    }
    throw error;
}
function mapDriverError(error) {
    switch(error.code){
        case "22001":
            return {
                kind: "LengthMismatch",
                column: error.column
            };
        case "22003":
            return {
                kind: "ValueOutOfRange",
                cause: error.message
            };
        case "22P02":
            return {
                kind: "InvalidInputValue",
                message: error.message
            };
        case "23505":
            {
                const fields = error.detail?.match(/Key \(([^)]+)\)/)?.at(1)?.split(", ");
                return {
                    kind: "UniqueConstraintViolation",
                    constraint: fields !== void 0 ? {
                        fields
                    } : void 0
                };
            }
        case "23502":
            {
                const fields = error.detail?.match(/Key \(([^)]+)\)/)?.at(1)?.split(", ");
                return {
                    kind: "NullConstraintViolation",
                    constraint: fields !== void 0 ? {
                        fields
                    } : void 0
                };
            }
        case "23503":
            {
                let constraint;
                if (error.column) {
                    constraint = {
                        fields: [
                            error.column
                        ]
                    };
                } else if (error.constraint) {
                    constraint = {
                        index: error.constraint
                    };
                }
                return {
                    kind: "ForeignKeyConstraintViolation",
                    constraint
                };
            }
        case "3D000":
            return {
                kind: "DatabaseDoesNotExist",
                db: error.message.split(" ").at(1)?.split('"').at(1)
            };
        case "28000":
            return {
                kind: "DatabaseAccessDenied",
                db: error.message.split(",").find((s)=>s.startsWith(" database"))?.split('"').at(1)
            };
        case "28P01":
            return {
                kind: "AuthenticationFailed",
                user: error.message.split(" ").pop()?.split('"').at(1)
            };
        case "40001":
            return {
                kind: "TransactionWriteConflict"
            };
        case "42P01":
            return {
                kind: "TableDoesNotExist",
                table: error.message.split(" ").at(1)?.split('"').at(1)
            };
        case "42703":
            return {
                kind: "ColumnNotFound",
                column: error.message.split(" ").at(1)?.split('"').at(1)
            };
        case "42P04":
            return {
                kind: "DatabaseAlreadyExists",
                db: error.message.split(" ").at(1)?.split('"').at(1)
            };
        case "53300":
            return {
                kind: "TooManyConnections",
                cause: error.message
            };
        default:
            return {
                kind: "postgres",
                code: error.code ?? "N/A",
                severity: error.severity ?? "N/A",
                message: error.message,
                detail: error.detail,
                column: error.column,
                hint: error.hint
            };
    }
}
function isDriverError(error) {
    return typeof error.code === "string" && typeof error.message === "string" && typeof error.severity === "string" && (typeof error.detail === "string" || error.detail === void 0) && (typeof error.column === "string" || error.column === void 0) && (typeof error.hint === "string" || error.hint === void 0);
}
function mapSocketError(error) {
    switch(error.code){
        case "ENOTFOUND":
        case "ECONNREFUSED":
            return {
                kind: "DatabaseNotReachable",
                host: error.address ?? error.hostname,
                port: error.port
            };
        case "ECONNRESET":
            return {
                kind: "ConnectionClosed"
            };
        case "ETIMEDOUT":
            return {
                kind: "SocketTimeout"
            };
    }
}
function isSocketError(error) {
    return typeof error.code === "string" && typeof error.syscall === "string" && typeof error.errno === "number" && SOCKET_ERRORS.has(error.code);
}
function isTlsError(error) {
    if (typeof error.code === "string") {
        return TLS_ERRORS.has(error.code);
    }
    switch(error.message){
        case "The server does not support SSL connections":
        case "There was an error establishing an SSL connection":
            return true;
    }
    return false;
}
// src/pg.ts
var types2 = __TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$2c$__$5b$project$5d2f$align$2f$node_modules$2f$pg$29$__["default"].types;
var debug = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$node_modules$2f40$prisma$2f$debug$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Debug"])("prisma:driver-adapter:pg");
var PgQueryable = class {
    constructor(client, pgOptions){
        this.client = client;
        this.pgOptions = pgOptions;
    }
    provider = "postgres";
    adapterName = name;
    /**
   * Execute a query given as SQL, interpolating the given parameters.
   */ async queryRaw(query) {
        const tag = "[js::query_raw]";
        debug(`${tag} %O`, query);
        const { fields, rows } = await this.performIO(query);
        const columnNames = fields.map((field)=>field.name);
        let columnTypes = [];
        try {
            columnTypes = fields.map((field)=>fieldToColumnType(field.dataTypeID));
        } catch (e) {
            if (e instanceof UnsupportedNativeDataType) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DriverAdapterError"]({
                    kind: "UnsupportedNativeDataType",
                    type: e.type
                });
            }
            throw e;
        }
        const udtParser = this.pgOptions?.userDefinedTypeParser;
        if (udtParser) {
            for(let i = 0; i < fields.length; i++){
                const field = fields[i];
                if (field.dataTypeID >= FIRST_NORMAL_OBJECT_ID && !Object.hasOwn(customParsers, field.dataTypeID)) {
                    for(let j = 0; j < rows.length; j++){
                        rows[j][i] = await udtParser(field.dataTypeID, rows[j][i], this);
                    }
                }
            }
        }
        return {
            columnNames,
            columnTypes,
            rows
        };
    }
    /**
   * Execute a query given as SQL, interpolating the given parameters and
   * returning the number of affected rows.
   * Note: Queryable expects a u64, but napi.rs only supports u32.
   */ async executeRaw(query) {
        const tag = "[js::execute_raw]";
        debug(`${tag} %O`, query);
        return (await this.performIO(query)).rowCount ?? 0;
    }
    /**
   * Run a query against the database, returning the result set.
   * Should the query fail due to a connection error, the connection is
   * marked as unhealthy.
   */ async performIO(query) {
        const { sql, args } = query;
        const values = args.map((arg, i)=>mapArg(arg, query.argTypes[i]));
        try {
            const result = await this.client.query({
                text: sql,
                values,
                rowMode: "array",
                types: {
                    // This is the error expected:
                    // No overload matches this call.
                    // The last overload gave the following error.
                    // Type '(oid: number, format?: any) => (json: string) => unknown' is not assignable to type '{ <T>(oid: number): TypeParser<string, string | T>; <T>(oid: number, format: "text"): TypeParser<string, string | T>; <T>(oid: number, format: "binary"): TypeParser<...>; }'.
                    //   Type '(json: string) => unknown' is not assignable to type 'TypeParser<Buffer, any>'.
                    //     Types of parameters 'json' and 'value' are incompatible.
                    //       Type 'Buffer' is not assignable to type 'string'.ts(2769)
                    //
                    // Because pg-types types expect us to handle both binary and text protocol versions,
                    // where as far we can see, pg will ever pass only text version.
                    //
                    // @ts-expect-error
                    getTypeParser: (oid, format)=>{
                        if (format === "text" && customParsers[oid]) {
                            return customParsers[oid];
                        }
                        return types2.getTypeParser(oid, format);
                    }
                }
            }, values);
            return result;
        } catch (e) {
            this.onError(e);
        }
    }
    onError(error) {
        debug("Error in performIO: %O", error);
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f40$prisma$2f$driver$2d$adapter$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DriverAdapterError"](convertDriverError(error));
    }
};
var PgTransaction = class extends PgQueryable {
    constructor(client, options, pgOptions, cleanup){
        super(client, pgOptions);
        this.options = options;
        this.pgOptions = pgOptions;
        this.cleanup = cleanup;
    }
    async commit() {
        debug(`[js::commit]`);
        this.cleanup?.();
        this.client.release();
    }
    async rollback() {
        debug(`[js::rollback]`);
        this.cleanup?.();
        this.client.release();
    }
};
var PrismaPgAdapter = class extends PgQueryable {
    constructor(client, pgOptions, release){
        super(client);
        this.pgOptions = pgOptions;
        this.release = release;
    }
    async startTransaction(isolationLevel) {
        const options = {
            usePhantomQuery: false
        };
        const tag = "[js::startTransaction]";
        debug("%s options: %O", tag, options);
        const conn = await this.client.connect().catch((error)=>this.onError(error));
        const onError = (err)=>{
            debug(`Error from pool connection: ${err.message} %O`, err);
            this.pgOptions?.onConnectionError?.(err);
        };
        conn.on("error", onError);
        const cleanup = ()=>{
            conn.removeListener("error", onError);
        };
        try {
            const tx = new PgTransaction(conn, options, this.pgOptions, cleanup);
            await tx.executeRaw({
                sql: "BEGIN",
                args: [],
                argTypes: []
            });
            if (isolationLevel) {
                await tx.executeRaw({
                    sql: `SET TRANSACTION ISOLATION LEVEL ${isolationLevel}`,
                    args: [],
                    argTypes: []
                });
            }
            return tx;
        } catch (error) {
            cleanup();
            conn.release(error);
            this.onError(error);
        }
    }
    async executeScript(script) {
        const statements = script.split(";").map((stmt)=>stmt.trim()).filter((stmt)=>stmt.length > 0);
        for (const stmt of statements){
            try {
                await this.client.query(stmt);
            } catch (error) {
                this.onError(error);
            }
        }
    }
    getConnectionInfo() {
        return {
            schemaName: this.pgOptions?.schema,
            supportsRelationJoins: true
        };
    }
    async dispose() {
        return this.release?.();
    }
    underlyingDriver() {
        return this.client;
    }
};
var PrismaPgAdapterFactory = class {
    constructor(poolOrConfig, options){
        this.options = options;
        if (poolOrConfig instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$2c$__$5b$project$5d2f$align$2f$node_modules$2f$pg$29$__["default"].Pool) {
            this.externalPool = poolOrConfig;
            this.config = poolOrConfig.options;
        } else {
            this.externalPool = null;
            this.config = poolOrConfig;
        }
    }
    provider = "postgres";
    adapterName = name;
    config;
    externalPool;
    async connect() {
        const client = this.externalPool ?? new __TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$2c$__$5b$project$5d2f$align$2f$node_modules$2f$pg$29$__["default"].Pool(this.config);
        const onIdleClientError = (err)=>{
            debug(`Error from idle pool client: ${err.message} %O`, err);
            this.options?.onPoolError?.(err);
        };
        client.on("error", onIdleClientError);
        return new PrismaPgAdapter(client, this.options, async ()=>{
            if (this.externalPool) {
                if (this.options?.disposeExternalPool) {
                    await this.externalPool.end();
                    this.externalPool = null;
                } else {
                    this.externalPool.removeListener("error", onIdleClientError);
                }
            } else {
                await client.end();
            }
        });
    }
    async connectToShadowDb() {
        const conn = await this.connect();
        const database = `prisma_migrate_shadow_db_${globalThis.crypto.randomUUID()}`;
        await conn.executeScript(`CREATE DATABASE "${database}"`);
        const client = new __TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$2c$__$5b$project$5d2f$align$2f$node_modules$2f$pg$29$__["default"].Pool({
            ...this.config,
            database
        });
        return new PrismaPgAdapter(client, void 0, async ()=>{
            await conn.executeScript(`DROP DATABASE "${database}"`);
            await client.end();
        });
    }
};
;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/align/node_modules/postgres-array/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const BACKSLASH = '\\';
const DQUOT = '"';
const LBRACE = '{';
const RBRACE = '}';
const LBRACKET = '[';
const EQUALS = '=';
const COMMA = ',';
/** When the raw value is this, it means a literal `null` */ const NULL_STRING = 'NULL';
/**
 * Parses an array according to
 * https://www.postgresql.org/docs/17/arrays.html#ARRAYS-IO
 *
 * Trusts the data (mostly), so only hook up to trusted Postgres servers.
 */ function makeParseArrayWithTransform(transform) {
    const haveTransform = transform != null;
    return function parseArray(str) {
        const rbraceIndex = str.length - 1;
        if (rbraceIndex === 1) {
            return [];
        }
        if (str[rbraceIndex] !== RBRACE) {
            throw new Error('Invalid array text - must end with }');
        }
        // If starts with `[`, it is specifying the index boundas. Skip past first `=`.
        let position = 0;
        if (str[position] === LBRACKET) {
            position = str.indexOf(EQUALS) + 1;
        }
        if (str[position++] !== LBRACE) {
            throw new Error('Invalid array text - must start with {');
        }
        const output = [];
        let current = output;
        const stack = [];
        let currentStringStart = position;
        let currentString = '';
        let expectValue = true;
        for(; position < rbraceIndex; ++position){
            let char = str[position];
            // > The array output routine will put double quotes around element values if
            // > they are empty strings, contain curly braces, delimiter characters, double
            // > quotes, backslashes, or white space, or match the word NULL. Double quotes
            // > and backslashes embedded in element values will be backslash-escaped.
            if (char === DQUOT) {
                // It's escaped
                currentStringStart = ++position;
                let dquot = str.indexOf(DQUOT, currentStringStart);
                let backSlash = str.indexOf(BACKSLASH, currentStringStart);
                while(backSlash !== -1 && backSlash < dquot){
                    position = backSlash;
                    const part = str.slice(currentStringStart, position);
                    currentString += part;
                    currentStringStart = ++position;
                    if (dquot === position++) {
                        // This was an escaped doublequote; find the next one!
                        dquot = str.indexOf(DQUOT, position);
                    }
                    // Either way, find the next backslash
                    backSlash = str.indexOf(BACKSLASH, position);
                }
                position = dquot;
                const part = str.slice(currentStringStart, position);
                currentString += part;
                current.push(haveTransform ? transform(currentString) : currentString);
                currentString = '';
                expectValue = false;
            } else if (char === LBRACE) {
                const newArray = [];
                current.push(newArray);
                stack.push(current);
                current = newArray;
                currentStringStart = position + 1;
                expectValue = true;
            } else if (char === COMMA) {
                expectValue = true;
            } else if (char === RBRACE) {
                expectValue = false;
                const arr = stack.pop();
                if (arr === undefined) {
                    throw new Error("Invalid array text - too many '}'");
                }
                current = arr;
            } else if (expectValue) {
                currentStringStart = position;
                while((char = str[position]) !== COMMA && char !== RBRACE && position < rbraceIndex){
                    ++position;
                }
                const part = str.slice(currentStringStart, position--);
                current.push(part === NULL_STRING ? null : haveTransform ? transform(part) : part);
                expectValue = false;
            } else {
                throw new Error('Was expecting delimeter');
            }
        }
        return output;
    };
}
const parseArray = makeParseArrayWithTransform();
exports.parse = (source, transform)=>transform != null ? makeParseArrayWithTransform(transform)(source) : parseArray(source);
}),
"[project]/align/node_modules/environment/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* globals WorkerGlobalScope, DedicatedWorkerGlobalScope, SharedWorkerGlobalScope, ServiceWorkerGlobalScope */ __turbopack_context__.s([
    "isAndroid",
    ()=>isAndroid,
    "isBrowser",
    ()=>isBrowser,
    "isBun",
    ()=>isBun,
    "isDedicatedWorker",
    ()=>isDedicatedWorker,
    "isDeno",
    ()=>isDeno,
    "isElectron",
    ()=>isElectron,
    "isIos",
    ()=>isIos,
    "isJsDom",
    ()=>isJsDom,
    "isLinux",
    ()=>isLinux,
    "isMacOs",
    ()=>isMacOs,
    "isNode",
    ()=>isNode,
    "isServiceWorker",
    ()=>isServiceWorker,
    "isSharedWorker",
    ()=>isSharedWorker,
    "isWebWorker",
    ()=>isWebWorker,
    "isWindows",
    ()=>isWindows
]);
const isBrowser = globalThis.window?.document !== undefined;
const isNode = globalThis.process?.versions?.node !== undefined;
const isBun = globalThis.process?.versions?.bun !== undefined;
const isDeno = globalThis.Deno?.version?.deno !== undefined;
const isElectron = globalThis.process?.versions?.electron !== undefined;
const isJsDom = globalThis.navigator?.userAgent?.includes('jsdom') === true;
const isWebWorker = typeof WorkerGlobalScope !== 'undefined' && globalThis instanceof WorkerGlobalScope;
const isDedicatedWorker = typeof DedicatedWorkerGlobalScope !== 'undefined' && globalThis instanceof DedicatedWorkerGlobalScope;
const isSharedWorker = typeof SharedWorkerGlobalScope !== 'undefined' && globalThis instanceof SharedWorkerGlobalScope;
const isServiceWorker = typeof ServiceWorkerGlobalScope !== 'undefined' && globalThis instanceof ServiceWorkerGlobalScope;
// Note: I'm intentionally not DRYing up the other variables to keep them "lazy".
const platform = globalThis.navigator?.userAgentData?.platform;
const isMacOs = platform === 'macOS' || globalThis.navigator?.platform === 'MacIntel' // Even on Apple silicon Macs.
 || globalThis.navigator?.userAgent?.includes(' Mac ') === true || globalThis.process?.platform === 'darwin';
const isWindows = platform === 'Windows' || globalThis.navigator?.platform === 'Win32' || globalThis.process?.platform === 'win32';
const isLinux = platform === 'Linux' || globalThis.navigator?.platform?.startsWith('Linux') === true || globalThis.navigator?.userAgent?.includes(' Linux ') === true || globalThis.process?.platform === 'linux';
const isIos = platform === 'iOS' || globalThis.navigator?.platform === 'MacIntel' && globalThis.navigator?.maxTouchPoints > 1 || /iPad|iPhone|iPod/.test(globalThis.navigator?.platform);
const isAndroid = platform === 'Android' || globalThis.navigator?.platform === 'Android' || globalThis.navigator?.userAgent?.includes(' Android ') === true || globalThis.process?.platform === 'android';
}),
"[project]/align/node_modules/ansi-escapes/base.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ConEmu",
    ()=>ConEmu,
    "beep",
    ()=>beep,
    "clearScreen",
    ()=>clearScreen,
    "clearTerminal",
    ()=>clearTerminal,
    "clearViewport",
    ()=>clearViewport,
    "cursorBackward",
    ()=>cursorBackward,
    "cursorDown",
    ()=>cursorDown,
    "cursorForward",
    ()=>cursorForward,
    "cursorGetPosition",
    ()=>cursorGetPosition,
    "cursorHide",
    ()=>cursorHide,
    "cursorLeft",
    ()=>cursorLeft,
    "cursorMove",
    ()=>cursorMove,
    "cursorNextLine",
    ()=>cursorNextLine,
    "cursorPrevLine",
    ()=>cursorPrevLine,
    "cursorRestorePosition",
    ()=>cursorRestorePosition,
    "cursorSavePosition",
    ()=>cursorSavePosition,
    "cursorShow",
    ()=>cursorShow,
    "cursorTo",
    ()=>cursorTo,
    "cursorUp",
    ()=>cursorUp,
    "enterAlternativeScreen",
    ()=>enterAlternativeScreen,
    "eraseDown",
    ()=>eraseDown,
    "eraseEndLine",
    ()=>eraseEndLine,
    "eraseLine",
    ()=>eraseLine,
    "eraseLines",
    ()=>eraseLines,
    "eraseScreen",
    ()=>eraseScreen,
    "eraseStartLine",
    ()=>eraseStartLine,
    "eraseUp",
    ()=>eraseUp,
    "exitAlternativeScreen",
    ()=>exitAlternativeScreen,
    "iTerm",
    ()=>iTerm,
    "image",
    ()=>image,
    "link",
    ()=>link,
    "scrollDown",
    ()=>scrollDown,
    "scrollUp",
    ()=>scrollUp,
    "setCwd",
    ()=>setCwd
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:os [external] (node:os, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$environment$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/environment/index.js [app-route] (ecmascript)");
;
;
;
const ESC = '\u001B[';
const OSC = '\u001B]';
const BEL = '\u0007';
const SEP = ';';
const isTerminalApp = !__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$environment$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isBrowser"] && __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].env.TERM_PROGRAM === 'Apple_Terminal';
const isWindows = !__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$environment$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isBrowser"] && __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].platform === 'win32';
const isTmux = !__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$environment$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isBrowser"] && (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].env.TERM?.startsWith('screen') || __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].env.TERM?.startsWith('tmux') || __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].env.TMUX !== undefined);
const cwdFunction = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$environment$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isBrowser"] ? ()=>{
    throw new Error('`process.cwd()` only works in Node.js, not the browser.');
} : __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].cwd;
const wrapOsc = (sequence)=>{
    if (isTmux) {
        // Tmux requires OSC sequences to be wrapped with DCS tmux; <sequence> ST
        // and all ESCs in <sequence> to be replaced with ESC ESC.
        // It only accepts ESC backslash for ST.
        return '\u001BPtmux;' + sequence.replaceAll('\u001B', '\u001B\u001B') + '\u001B\\';
    }
    return sequence;
};
const cursorTo = (x, y)=>{
    if (typeof x !== 'number') {
        throw new TypeError('The `x` argument is required');
    }
    if (typeof y !== 'number') {
        return ESC + (x + 1) + 'G';
    }
    return ESC + (y + 1) + SEP + (x + 1) + 'H';
};
const cursorMove = (x, y)=>{
    if (typeof x !== 'number') {
        throw new TypeError('The `x` argument is required');
    }
    let returnValue = '';
    if (x < 0) {
        returnValue += ESC + -x + 'D';
    } else if (x > 0) {
        returnValue += ESC + x + 'C';
    }
    if (y < 0) {
        returnValue += ESC + -y + 'A';
    } else if (y > 0) {
        returnValue += ESC + y + 'B';
    }
    return returnValue;
};
const cursorUp = (count = 1)=>ESC + count + 'A';
const cursorDown = (count = 1)=>ESC + count + 'B';
const cursorForward = (count = 1)=>ESC + count + 'C';
const cursorBackward = (count = 1)=>ESC + count + 'D';
const cursorLeft = ESC + 'G';
const cursorSavePosition = isTerminalApp ? '\u001B7' : ESC + 's';
const cursorRestorePosition = isTerminalApp ? '\u001B8' : ESC + 'u';
const cursorGetPosition = ESC + '6n';
const cursorNextLine = ESC + 'E';
const cursorPrevLine = ESC + 'F';
const cursorHide = ESC + '?25l';
const cursorShow = ESC + '?25h';
const eraseLines = (count)=>{
    let clear = '';
    for(let i = 0; i < count; i++){
        clear += eraseLine + (i < count - 1 ? cursorUp() : '');
    }
    if (count) {
        clear += cursorLeft;
    }
    return clear;
};
const eraseEndLine = ESC + 'K';
const eraseStartLine = ESC + '1K';
const eraseLine = ESC + '2K';
const eraseDown = ESC + 'J';
const eraseUp = ESC + '1J';
const eraseScreen = ESC + '2J';
const scrollUp = ESC + 'S';
const scrollDown = ESC + 'T';
const clearScreen = '\u001Bc';
const clearViewport = `${eraseScreen}${ESC}H`;
const isOldWindows = ()=>{
    if (__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$environment$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isBrowser"] || !isWindows) {
        return false;
    }
    const parts = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["default"].release().split('.');
    const major = Number(parts[0]);
    const build = Number(parts[2] ?? 0);
    if (major < 10) {
        return true;
    }
    if (major === 10 && build < 10_586) {
        return true;
    }
    return false;
};
const clearTerminal = isOldWindows() ? `${eraseScreen}${ESC}0f` : `${eraseScreen}${ESC}3J${ESC}H`;
const enterAlternativeScreen = ESC + '?1049h';
const exitAlternativeScreen = ESC + '?1049l';
const beep = BEL;
const link = (text, url)=>{
    const openLink = wrapOsc(`${OSC}8${SEP}${SEP}${url}${BEL}`);
    const closeLink = wrapOsc(`${OSC}8${SEP}${SEP}${BEL}`);
    return openLink + text + closeLink;
};
const image = (data, options = {})=>{
    let returnValue = `${OSC}1337;File=inline=1`;
    if (options.width) {
        returnValue += `;width=${options.width}`;
    }
    if (options.height) {
        returnValue += `;height=${options.height}`;
    }
    if (options.preserveAspectRatio === false) {
        returnValue += ';preserveAspectRatio=0';
    }
    const imageBuffer = Buffer.from(data);
    // `size` is optional in the spec, but xterm.js requires it.
    return wrapOsc(returnValue + `;size=${imageBuffer.byteLength}` + ':' + imageBuffer.toString('base64') + BEL);
};
const iTerm = {
    setCwd: (cwd = cwdFunction())=>wrapOsc(`${OSC}50;CurrentDir=${cwd}${BEL}`),
    annotation (message, options = {}) {
        let returnValue = `${OSC}1337;`;
        const hasX = options.x !== undefined;
        const hasY = options.y !== undefined;
        if ((hasX || hasY) && !(hasX && hasY && options.length !== undefined)) {
            throw new Error('`x`, `y` and `length` must be defined when `x` or `y` is defined');
        }
        message = message.replaceAll('|', '');
        returnValue += options.isHidden ? 'AddHiddenAnnotation=' : 'AddAnnotation=';
        if (options.length > 0) {
            returnValue += (hasX ? [
                message,
                options.length,
                options.x,
                options.y
            ] : [
                options.length,
                message
            ]).join('|');
        } else {
            returnValue += message;
        }
        return wrapOsc(returnValue + BEL);
    }
};
const ConEmu = {
    setCwd: (cwd = cwdFunction())=>wrapOsc(`${OSC}9;9;${cwd}${BEL}`)
};
const setCwd = (cwd = cwdFunction())=>iTerm.setCwd(cwd) + ConEmu.setCwd(cwd);
}),
"[project]/align/node_modules/tslog/esm/urlToObj.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "urlToObject",
    ()=>urlToObject
]);
function urlToObject(url) {
    return {
        href: url.href,
        protocol: url.protocol,
        username: url.username,
        password: url.password,
        host: url.host,
        hostname: url.hostname,
        port: url.port,
        pathname: url.pathname,
        search: url.search,
        searchParams: [
            ...url.searchParams
        ].map(([key, value])=>({
                key,
                value
            })),
        hash: url.hash,
        origin: url.origin
    };
}
}),
"[project]/align/node_modules/tslog/esm/prettyLogStyles.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "prettyLogStyles",
    ()=>prettyLogStyles
]);
const prettyLogStyles = {
    reset: [
        0,
        0
    ],
    bold: [
        1,
        22
    ],
    dim: [
        2,
        22
    ],
    italic: [
        3,
        23
    ],
    underline: [
        4,
        24
    ],
    overline: [
        53,
        55
    ],
    inverse: [
        7,
        27
    ],
    hidden: [
        8,
        28
    ],
    strikethrough: [
        9,
        29
    ],
    black: [
        30,
        39
    ],
    red: [
        31,
        39
    ],
    green: [
        32,
        39
    ],
    yellow: [
        33,
        39
    ],
    blue: [
        34,
        39
    ],
    magenta: [
        35,
        39
    ],
    cyan: [
        36,
        39
    ],
    white: [
        37,
        39
    ],
    blackBright: [
        90,
        39
    ],
    redBright: [
        91,
        39
    ],
    greenBright: [
        92,
        39
    ],
    yellowBright: [
        93,
        39
    ],
    blueBright: [
        94,
        39
    ],
    magentaBright: [
        95,
        39
    ],
    cyanBright: [
        96,
        39
    ],
    whiteBright: [
        97,
        39
    ],
    bgBlack: [
        40,
        49
    ],
    bgRed: [
        41,
        49
    ],
    bgGreen: [
        42,
        49
    ],
    bgYellow: [
        43,
        49
    ],
    bgBlue: [
        44,
        49
    ],
    bgMagenta: [
        45,
        49
    ],
    bgCyan: [
        46,
        49
    ],
    bgWhite: [
        47,
        49
    ],
    bgBlackBright: [
        100,
        49
    ],
    bgRedBright: [
        101,
        49
    ],
    bgGreenBright: [
        102,
        49
    ],
    bgYellowBright: [
        103,
        49
    ],
    bgBlueBright: [
        104,
        49
    ],
    bgMagentaBright: [
        105,
        49
    ],
    bgCyanBright: [
        106,
        49
    ],
    bgWhiteBright: [
        107,
        49
    ]
};
}),
"[project]/align/node_modules/tslog/esm/formatTemplate.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "formatTemplate",
    ()=>formatTemplate
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$prettyLogStyles$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/tslog/esm/prettyLogStyles.js [app-route] (ecmascript)");
;
function formatTemplate(settings, template, values, hideUnsetPlaceholder = false) {
    const templateString = String(template);
    const ansiColorWrap = (placeholderValue, code)=>`\u001b[${code[0]}m${placeholderValue}\u001b[${code[1]}m`;
    const styleWrap = (value, style)=>{
        if (style != null && typeof style === "string") {
            return ansiColorWrap(value, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$prettyLogStyles$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyLogStyles"][style]);
        } else if (style != null && Array.isArray(style)) {
            return style.reduce((prevValue, thisStyle)=>styleWrap(prevValue, thisStyle), value);
        } else {
            if (style != null && style[value.trim()] != null) {
                return styleWrap(value, style[value.trim()]);
            } else if (style != null && style["*"] != null) {
                return styleWrap(value, style["*"]);
            } else {
                return value;
            }
        }
    };
    const defaultStyle = null;
    return templateString.replace(/{{(.+?)}}/g, (_, placeholder)=>{
        const value = values[placeholder] != null ? String(values[placeholder]) : hideUnsetPlaceholder ? "" : _;
        return settings.stylePrettyLogs ? styleWrap(value, settings?.prettyLogStyles?.[placeholder] ?? defaultStyle) + ansiColorWrap("", __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$prettyLogStyles$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyLogStyles"].reset) : value;
    });
}
}),
"[project]/align/node_modules/tslog/esm/formatNumberAddZeros.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "formatNumberAddZeros",
    ()=>formatNumberAddZeros
]);
function formatNumberAddZeros(value, digits = 2, addNumber = 0) {
    if (value != null && isNaN(value)) {
        return "";
    }
    value = value != null ? value + addNumber : value;
    return digits === 2 ? value == null ? "--" : value < 10 ? "0" + value : value.toString() : value == null ? "---" : value < 10 ? "00" + value : value < 100 ? "0" + value : value.toString();
}
}),
"[project]/align/node_modules/tslog/esm/internal/metaFormatting.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "buildPrettyMeta",
    ()=>buildPrettyMeta
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$formatTemplate$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/tslog/esm/formatTemplate.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$formatNumberAddZeros$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/tslog/esm/formatNumberAddZeros.js [app-route] (ecmascript)");
;
;
function buildPrettyMeta(settings, meta) {
    if (meta == null) {
        return {
            text: "",
            template: settings.prettyLogTemplate,
            placeholders: {}
        };
    }
    let template = settings.prettyLogTemplate;
    const placeholderValues = {};
    if (template.includes("{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}")) {
        template = template.replace("{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}", "{{dateIsoStr}}");
    } else {
        if (settings.prettyLogTimeZone === "UTC") {
            placeholderValues["yyyy"] = meta.date?.getUTCFullYear() ?? "----";
            placeholderValues["mm"] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$formatNumberAddZeros$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatNumberAddZeros"])(meta.date?.getUTCMonth(), 2, 1);
            placeholderValues["dd"] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$formatNumberAddZeros$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatNumberAddZeros"])(meta.date?.getUTCDate(), 2);
            placeholderValues["hh"] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$formatNumberAddZeros$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatNumberAddZeros"])(meta.date?.getUTCHours(), 2);
            placeholderValues["MM"] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$formatNumberAddZeros$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatNumberAddZeros"])(meta.date?.getUTCMinutes(), 2);
            placeholderValues["ss"] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$formatNumberAddZeros$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatNumberAddZeros"])(meta.date?.getUTCSeconds(), 2);
            placeholderValues["ms"] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$formatNumberAddZeros$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatNumberAddZeros"])(meta.date?.getUTCMilliseconds(), 3);
        } else {
            placeholderValues["yyyy"] = meta.date?.getFullYear() ?? "----";
            placeholderValues["mm"] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$formatNumberAddZeros$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatNumberAddZeros"])(meta.date?.getMonth(), 2, 1);
            placeholderValues["dd"] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$formatNumberAddZeros$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatNumberAddZeros"])(meta.date?.getDate(), 2);
            placeholderValues["hh"] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$formatNumberAddZeros$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatNumberAddZeros"])(meta.date?.getHours(), 2);
            placeholderValues["MM"] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$formatNumberAddZeros$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatNumberAddZeros"])(meta.date?.getMinutes(), 2);
            placeholderValues["ss"] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$formatNumberAddZeros$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatNumberAddZeros"])(meta.date?.getSeconds(), 2);
            placeholderValues["ms"] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$formatNumberAddZeros$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatNumberAddZeros"])(meta.date?.getMilliseconds(), 3);
        }
    }
    const dateInSettingsTimeZone = settings.prettyLogTimeZone === "UTC" ? meta.date : meta.date != null ? new Date(meta.date.getTime() - meta.date.getTimezoneOffset() * 60000) : undefined;
    placeholderValues["rawIsoStr"] = dateInSettingsTimeZone?.toISOString() ?? "";
    placeholderValues["dateIsoStr"] = dateInSettingsTimeZone?.toISOString().replace("T", " ").replace("Z", "") ?? "";
    placeholderValues["logLevelName"] = meta.logLevelName;
    placeholderValues["fileNameWithLine"] = meta.path?.fileNameWithLine ?? "";
    placeholderValues["filePathWithLine"] = meta.path?.filePathWithLine ?? "";
    placeholderValues["fullFilePath"] = meta.path?.fullFilePath ?? "";
    let parentNamesString = settings.parentNames?.join(settings.prettyErrorParentNamesSeparator);
    parentNamesString = parentNamesString != null && meta.name != null ? parentNamesString + settings.prettyErrorParentNamesSeparator : undefined;
    const combinedName = meta.name != null || parentNamesString != null ? `${parentNamesString ?? ""}${meta.name ?? ""}` : "";
    placeholderValues["name"] = combinedName;
    placeholderValues["nameWithDelimiterPrefix"] = combinedName.length > 0 ? settings.prettyErrorLoggerNameDelimiter + combinedName : "";
    placeholderValues["nameWithDelimiterSuffix"] = combinedName.length > 0 ? combinedName + settings.prettyErrorLoggerNameDelimiter : "";
    if (settings.overwrite?.addPlaceholders != null) {
        settings.overwrite.addPlaceholders(meta, placeholderValues);
    }
    return {
        text: (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$formatTemplate$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatTemplate"])(settings, template, placeholderValues),
        template,
        placeholders: placeholderValues
    };
}
}),
"[project]/align/node_modules/tslog/esm/internal/stackTrace.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "buildStackTrace",
    ()=>buildStackTrace,
    "clampIndex",
    ()=>clampIndex,
    "findFirstExternalFrameIndex",
    ()=>findFirstExternalFrameIndex,
    "getCleanStackLines",
    ()=>getCleanStackLines,
    "getDefaultIgnorePatterns",
    ()=>getDefaultIgnorePatterns,
    "getFrameAt",
    ()=>getFrameAt,
    "isIgnorableFrame",
    ()=>isIgnorableFrame,
    "pickCallerStackFrame",
    ()=>pickCallerStackFrame,
    "sanitizeStackLines",
    ()=>sanitizeStackLines,
    "splitStackLines",
    ()=>splitStackLines,
    "toStackFrames",
    ()=>toStackFrames
]);
const DEFAULT_IGNORE_PATTERNS = [
    /(?:^|[\\/])node_modules[\\/].*tslog/i,
    /(?:^|[\\/])deps[\\/].*tslog/i,
    /tslog[\\/]+src[\\/]+internal[\\/]/i,
    /tslog[\\/]+src[\\/]BaseLogger/i,
    /tslog[\\/]+src[\\/]index/i
];
function splitStackLines(error) {
    const stack = typeof error?.stack === "string" ? error.stack : undefined;
    if (stack == null || stack.length === 0) {
        return [];
    }
    return stack.split("\n").map((line)=>line.trimEnd());
}
function sanitizeStackLines(lines) {
    return lines.filter((line)=>line.length > 0 && !/^\s*Error\b/.test(line));
}
function toStackFrames(lines, parseLine) {
    const frames = [];
    for (const line of lines){
        const frame = parseLine(line);
        if (frame != null) {
            frames.push(frame);
        }
    }
    return frames;
}
function findFirstExternalFrameIndex(frames, ignorePatterns = DEFAULT_IGNORE_PATTERNS) {
    for(let index = 0; index < frames.length; index += 1){
        const frame = frames[index];
        const filePathCandidate = frame.filePath ?? "";
        const fullPathCandidate = frame.fullFilePath ?? "";
        if (!ignorePatterns.some((pattern)=>pattern.test(filePathCandidate) || pattern.test(fullPathCandidate))) {
            return index;
        }
    }
    return 0;
}
function getFrameAt(frames, index) {
    if (index < 0 || index >= frames.length) {
        return undefined;
    }
    return frames[index];
}
function getCleanStackLines(error) {
    return sanitizeStackLines(splitStackLines(error));
}
function buildStackTrace(error, parseLine) {
    return toStackFrames(getCleanStackLines(error), parseLine);
}
function isIgnorableFrame(frame, ignorePatterns) {
    const filePathCandidate = frame.filePath ?? "";
    const fullPathCandidate = frame.fullFilePath ?? "";
    return ignorePatterns.some((pattern)=>pattern.test(filePathCandidate) || pattern.test(fullPathCandidate));
}
function clampIndex(index, maxExclusive) {
    if (index < 0) {
        return 0;
    }
    if (index >= maxExclusive) {
        return Math.max(0, maxExclusive - 1);
    }
    return index;
}
function pickCallerStackFrame(error, parseLine, options = {}) {
    const lines = getCleanStackLines(error);
    const frames = toStackFrames(lines, parseLine);
    if (frames.length === 0) {
        return undefined;
    }
    const ignorePatterns = options.ignorePatterns ?? DEFAULT_IGNORE_PATTERNS;
    const autoIndex = findFirstExternalFrameIndex(frames, ignorePatterns);
    const resolvedIndex = options.stackDepthLevel != null ? options.stackDepthLevel : autoIndex;
    return getFrameAt(frames, clampIndex(resolvedIndex, frames.length));
}
function getDefaultIgnorePatterns() {
    return [
        ...DEFAULT_IGNORE_PATTERNS
    ];
}
}),
"[project]/align/node_modules/tslog/esm/internal/errorUtils.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "collectErrorCauses",
    ()=>collectErrorCauses,
    "toError",
    ()=>toError,
    "toErrorObject",
    ()=>toErrorObject
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$stackTrace$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/tslog/esm/internal/stackTrace.js [app-route] (ecmascript)");
;
const DEFAULT_CAUSE_DEPTH = 5;
function collectErrorCauses(error, options = {}) {
    const maxDepth = options.maxDepth ?? DEFAULT_CAUSE_DEPTH;
    const causes = [];
    const visited = new Set();
    let current = error;
    let depth = 0;
    while(current != null && depth < maxDepth){
        const cause = current?.cause;
        if (cause == null || visited.has(cause)) {
            break;
        }
        visited.add(cause);
        causes.push(toError(cause));
        current = cause;
        depth += 1;
    }
    return causes;
}
function toError(value) {
    if (value instanceof Error) {
        return value;
    }
    const error = new Error(typeof value === "string" ? value : JSON.stringify(value));
    if (typeof value === "object" && value != null) {
        Object.assign(error, value);
    }
    return error;
}
function toErrorObject(error, parseLine) {
    return {
        nativeError: error,
        name: error.name ?? "Error",
        message: error.message ?? "",
        stack: (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$stackTrace$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildStackTrace"])(error, parseLine)
    };
}
}),
"[project]/align/node_modules/tslog/esm/internal/jsonStringifyRecursive.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "jsonStringifyRecursive",
    ()=>jsonStringifyRecursive
]);
function jsonStringifyRecursive(obj) {
    const cache = new Set();
    return JSON.stringify(obj, (key, value)=>{
        if (typeof value === "object" && value !== null) {
            if (cache.has(value)) {
                return "[Circular]";
            }
            cache.add(value);
        }
        if (typeof value === "bigint") {
            return `${value}`;
        }
        if (typeof value === "undefined") {
            return "[undefined]";
        }
        return value;
    });
}
}),
"[project]/align/node_modules/tslog/esm/internal/util.inspect.polyfill.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "formatValue",
    ()=>formatValue,
    "formatWithOptions",
    ()=>formatWithOptions,
    "inspect",
    ()=>inspect
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$prettyLogStyles$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/tslog/esm/prettyLogStyles.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$jsonStringifyRecursive$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/tslog/esm/internal/jsonStringifyRecursive.js [app-route] (ecmascript)");
;
;
function inspect(obj, opts) {
    const ctx = {
        seen: [],
        stylize: stylizeNoColor
    };
    if (opts != null) {
        _extend(ctx, opts);
    }
    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined(ctx.depth)) ctx.depth = 2;
    if (isUndefined(ctx.colors)) ctx.colors = true;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
}
inspect.colors = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$prettyLogStyles$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyLogStyles"];
inspect.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    regexp: "red"
};
function isBoolean(arg) {
    return typeof arg === "boolean";
}
function isUndefined(arg) {
    return arg === undefined;
}
function stylizeNoColor(str) {
    return str;
}
function stylizeWithColor(str, styleType) {
    const style = inspect.styles[styleType];
    if (style != null && inspect?.colors?.[style]?.[0] != null && inspect?.colors?.[style]?.[1] != null) {
        return "\u001b[" + inspect.colors[style][0] + "m" + str + "\u001b[" + inspect.colors[style][1] + "m";
    } else {
        return str;
    }
}
function isFunction(arg) {
    return typeof arg === "function";
}
function isString(arg) {
    return typeof arg === "string";
}
function isNumber(arg) {
    return typeof arg === "number";
}
function isNull(arg) {
    return arg === null;
}
function hasOwn(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
function isRegExp(re) {
    return isObject(re) && objectToString(re) === "[object RegExp]";
}
function isObject(arg) {
    return typeof arg === "object" && arg !== null;
}
function isError(e) {
    return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
}
function isDate(d) {
    return isObject(d) && objectToString(d) === "[object Date]";
}
function objectToString(o) {
    return Object.prototype.toString.call(o);
}
function arrayToHash(array) {
    const hash = {};
    array.forEach((val)=>{
        hash[val] = true;
    });
    return hash;
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    const output = [];
    for(let i = 0, l = value.length; i < l; ++i){
        if (hasOwn(value, String(i))) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
            output.push("");
        }
    }
    keys.forEach((key)=>{
        if (!key.match(/^\d+$/)) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
    });
    return output;
}
function formatError(value) {
    return "[" + Error.prototype.toString.call(value) + "]";
}
function formatValue(ctx, value, recurseTimes = 0) {
    if (ctx.customInspect && value != null && isFunction(value) && value?.inspect !== inspect && !(value?.constructor && value?.constructor.prototype === value)) {
        if (typeof value.inspect !== "function" && value.toString != null) {
            return value.toString();
        }
        let ret = value?.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
    }
    const primitive = formatPrimitive(ctx, value);
    if (primitive) {
        return primitive;
    }
    let keys = Object.keys(value);
    const visibleKeys = arrayToHash(keys);
    try {
        if (ctx.showHidden && Object.getOwnPropertyNames) {
            keys = Object.getOwnPropertyNames(value);
        }
    } catch  {}
    if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value);
    }
    if (keys.length === 0) {
        if (isFunction(ctx.stylize)) {
            if (isFunction(value)) {
                const name = value.name ? ": " + value.name : "";
                return ctx.stylize("[Function" + name + "]", "special");
            }
            if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
            }
            if (isDate(value)) {
                return ctx.stylize(Date.prototype.toISOString.call(value), "date");
            }
            if (isError(value)) {
                return formatError(value);
            }
        } else {
            return value;
        }
    }
    let base = "";
    let array = false;
    let braces = [
        "{\n",
        "\n}"
    ];
    if (Array.isArray(value)) {
        array = true;
        braces = [
            "[\n",
            "\n]"
        ];
    }
    if (isFunction(value)) {
        const n = value.name ? ": " + value.name : "";
        base = " [Function" + n + "]";
    }
    if (isRegExp(value)) {
        base = " " + RegExp.prototype.toString.call(value);
    }
    if (isDate(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
    }
    if (isError(value)) {
        base = " " + formatError(value);
    }
    if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
    }
    if (recurseTimes < 0) {
        if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
            return ctx.stylize("[Object]", "special");
        }
    }
    ctx.seen.push(value);
    let output;
    if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else {
        output = keys.map((key)=>{
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
    }
    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    let name, str;
    let desc = {
        value: void 0
    };
    try {
        desc.value = value[key];
    } catch  {}
    try {
        if (Object.getOwnPropertyDescriptor) {
            desc = Object.getOwnPropertyDescriptor(value, key) || desc;
        }
    } catch  {}
    if (desc.get) {
        if (desc.set) {
            str = ctx.stylize("[Getter/Setter]", "special");
        } else {
            str = ctx.stylize("[Getter]", "special");
        }
    } else {
        if (desc.set) {
            str = ctx.stylize("[Setter]", "special");
        }
    }
    if (!hasOwn(visibleKeys, key)) {
        name = "[" + key + "]";
    }
    if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
                str = formatValue(ctx, desc.value, undefined);
            } else {
                str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf("\n") > -1) {
                if (array) {
                    str = str.split("\n").map((line)=>{
                        return "  " + line;
                    }).join("\n").substr(2);
                } else {
                    str = "\n" + str.split("\n").map((line)=>{
                        return "   " + line;
                    }).join("\n");
                }
            }
        } else {
            str = ctx.stylize("[Circular]", "special");
        }
    }
    if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
            return str;
        }
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.substr(1, name.length - 2);
            name = ctx.stylize(name, "name");
        } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, "\\'").replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, "string");
        }
    }
    return name + ": " + str;
}
function formatPrimitive(ctx, value) {
    if (isUndefined(value)) return ctx.stylize("undefined", "undefined");
    if (isString(value)) {
        const simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, "\\'") + "'";
        return ctx.stylize(simple, "string");
    }
    if (isNumber(value)) return ctx.stylize("" + value, "number");
    if (isBoolean(value)) return ctx.stylize("" + value, "boolean");
    if (isNull(value)) return ctx.stylize("null", "null");
}
function reduceToSingleString(output, base, braces) {
    return braces[0] + (base === "" ? "" : base + "\n") + "  " + output.join(",\n  ") + " " + braces[1];
}
function _extend(origin, add) {
    const typedOrigin = {
        ...origin
    };
    if (!add || !isObject(add)) return origin;
    const clonedAdd = {
        ...add
    };
    const keys = Object.keys(add);
    let i = keys.length;
    while(i--){
        typedOrigin[keys[i]] = clonedAdd[keys[i]];
    }
    return typedOrigin;
}
function formatWithOptions(inspectOptions, ...args) {
    const ctx = {
        seen: [],
        stylize: stylizeNoColor
    };
    if (inspectOptions != null) {
        _extend(ctx, inspectOptions);
    }
    const first = args[0];
    let a = 0;
    let str = "";
    let join = "";
    if (typeof first === "string") {
        if (args.length === 1) {
            return first;
        }
        let tempStr;
        let lastPos = 0;
        for(let i = 0; i < first.length - 1; i++){
            if (first.charCodeAt(i) === 37) {
                const nextChar = first.charCodeAt(++i);
                if (a + 1 !== args.length) {
                    switch(nextChar){
                        case 115:
                            {
                                const tempArg = args[++a];
                                if (typeof tempArg === "number") {
                                    tempStr = formatPrimitive(ctx, tempArg);
                                } else if (typeof tempArg === "bigint") {
                                    tempStr = formatPrimitive(ctx, tempArg);
                                } else if (typeof tempArg !== "object" || tempArg === null) {
                                    tempStr = String(tempArg);
                                } else {
                                    tempStr = inspect(tempArg, {
                                        ...inspectOptions,
                                        compact: 3,
                                        colors: false,
                                        depth: 0
                                    });
                                }
                                break;
                            }
                        case 106:
                            tempStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$jsonStringifyRecursive$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsonStringifyRecursive"])(args[++a]);
                            break;
                        case 100:
                            {
                                const tempNum = args[++a];
                                if (typeof tempNum === "bigint") {
                                    tempStr = formatPrimitive(ctx, tempNum);
                                } else if (typeof tempNum === "symbol") {
                                    tempStr = "NaN";
                                } else {
                                    tempStr = formatPrimitive(ctx, tempNum);
                                }
                                break;
                            }
                        case 79:
                            tempStr = inspect(args[++a], inspectOptions);
                            break;
                        case 111:
                            tempStr = inspect(args[++a], {
                                ...inspectOptions,
                                showHidden: true,
                                showProxy: true,
                                depth: 4
                            });
                            break;
                        case 105:
                            {
                                const tempInteger = args[++a];
                                if (typeof tempInteger === "bigint") {
                                    tempStr = formatPrimitive(ctx, tempInteger);
                                } else if (typeof tempInteger === "symbol") {
                                    tempStr = "NaN";
                                } else {
                                    tempStr = formatPrimitive(ctx, parseInt(tempStr));
                                }
                                break;
                            }
                        case 102:
                            {
                                const tempFloat = args[++a];
                                if (typeof tempFloat === "symbol") {
                                    tempStr = "NaN";
                                } else {
                                    tempStr = formatPrimitive(ctx, parseInt(tempFloat));
                                }
                                break;
                            }
                        case 99:
                            a += 1;
                            tempStr = "";
                            break;
                        case 37:
                            str += first.slice(lastPos, i);
                            lastPos = i + 1;
                            continue;
                        default:
                            continue;
                    }
                    if (lastPos !== i - 1) {
                        str += first.slice(lastPos, i - 1);
                    }
                    str += tempStr;
                    lastPos = i + 1;
                } else if (nextChar === 37) {
                    str += first.slice(lastPos, i);
                    lastPos = i + 1;
                }
            }
        }
        if (lastPos !== 0) {
            a++;
            join = " ";
            if (lastPos < first.length) {
                str += first.slice(lastPos);
            }
        }
    }
    while(a < args.length){
        const value = args[a];
        str += join;
        str += typeof value !== "string" ? inspect(value, inspectOptions) : value;
        join = " ";
        a++;
    }
    return str;
}
}),
"[project]/align/node_modules/tslog/esm/internal/environment.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "consoleSupportsCssStyling",
    ()=>consoleSupportsCssStyling,
    "isBrowserEnvironment",
    ()=>isBrowserEnvironment,
    "safeGetCwd",
    ()=>safeGetCwd
]);
function safeGetCwd() {
    try {
        const nodeProcess = globalThis?.process;
        if (typeof nodeProcess?.cwd === "function") {
            return nodeProcess.cwd();
        }
    } catch  {}
    try {
        const deno = globalThis?.["Deno"];
        if (typeof deno?.cwd === "function") {
            return deno.cwd();
        }
    } catch  {}
    return undefined;
}
function isBrowserEnvironment() {
    return ("TURBOPACK compile-time value", "undefined") !== "undefined" && typeof document !== "undefined";
}
function consoleSupportsCssStyling() {
    if (!isBrowserEnvironment()) {
        return false;
    }
    //TURBOPACK unreachable
    ;
    const navigatorObj = undefined;
    const userAgent = undefined;
    const windowObj = undefined;
}
}),
"[project]/align/node_modules/tslog/esm/BaseLogger.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BaseLogger",
    ()=>BaseLogger,
    "createLoggerEnvironment",
    ()=>createLoggerEnvironment,
    "loggerEnvironment",
    ()=>loggerEnvironment
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$urlToObj$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/tslog/esm/urlToObj.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$metaFormatting$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/tslog/esm/internal/metaFormatting.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$errorUtils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/tslog/esm/internal/errorUtils.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$formatTemplate$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/tslog/esm/formatTemplate.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$util$2e$inspect$2e$polyfill$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/tslog/esm/internal/util.inspect.polyfill.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$stackTrace$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/tslog/esm/internal/stackTrace.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$environment$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/tslog/esm/internal/environment.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$jsonStringifyRecursive$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/tslog/esm/internal/jsonStringifyRecursive.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
function createLoggerEnvironment() {
    const runtimeInfo = detectRuntimeInfo();
    const meta = createRuntimeMeta(runtimeInfo);
    const usesBrowserStack = runtimeInfo.name === "browser" || runtimeInfo.name === "worker";
    const callerIgnorePatterns = usesBrowserStack ? [
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$stackTrace$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getDefaultIgnorePatterns"])(),
        /node_modules[\\/].*tslog/i
    ] : [
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$stackTrace$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getDefaultIgnorePatterns"])(),
        /node:(?:internal|vm)/i,
        /\binternal[\\/]/i
    ];
    let cachedCwd;
    const environment = {
        getMeta (logLevelId, logLevelName, stackDepthLevel, hideLogPositionForPerformance, name, parentNames) {
            return Object.assign({}, meta, {
                name,
                parentNames,
                date: new Date(),
                logLevelId,
                logLevelName,
                path: !hideLogPositionForPerformance ? environment.getCallerStackFrame(stackDepthLevel) : undefined
            });
        },
        getCallerStackFrame (stackDepthLevel, error = new Error()) {
            const frames = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$stackTrace$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildStackTrace"])(error, (line)=>parseStackLine(line));
            if (frames.length === 0) {
                return {};
            }
            const autoIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$stackTrace$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["findFirstExternalFrameIndex"])(frames, callerIgnorePatterns);
            const useManualIndex = Number.isFinite(stackDepthLevel) && stackDepthLevel >= 0;
            const resolvedIndex = useManualIndex ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$stackTrace$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["clampIndex"])(stackDepthLevel, frames.length) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$stackTrace$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["clampIndex"])(autoIndex, frames.length);
            return frames[resolvedIndex] ?? {};
        },
        getErrorTrace (error) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$stackTrace$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildStackTrace"])(error, (line)=>parseStackLine(line));
        },
        isError (value) {
            return isNativeError(value);
        },
        isBuffer (value) {
            return typeof Buffer !== "undefined" && typeof Buffer.isBuffer === "function" ? Buffer.isBuffer(value) : false;
        },
        prettyFormatLogObj (maskedArgs, settings) {
            return maskedArgs.reduce((result, arg)=>{
                if (environment.isError(arg)) {
                    result.errors.push(environment.prettyFormatErrorObj(arg, settings));
                } else {
                    result.args.push(arg);
                }
                return result;
            }, {
                args: [],
                errors: []
            });
        },
        prettyFormatErrorObj (error, settings) {
            const stackLines = formatStackFrames(environment.getErrorTrace(error), settings);
            const causeSections = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$errorUtils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["collectErrorCauses"])(error).map((cause, index)=>{
                const header = `Caused by (${index + 1}): ${cause.name ?? "Error"}${cause.message ? `: ${cause.message}` : ""}`;
                const frames = formatStackFrames((0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$stackTrace$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildStackTrace"])(cause, (line)=>parseStackLine(line)), settings);
                return [
                    header,
                    ...frames
                ].join("\n");
            });
            const placeholderValuesError = {
                errorName: ` ${error.name} `,
                errorMessage: formatErrorMessage(error),
                errorStack: [
                    ...stackLines,
                    ...causeSections
                ].join("\n")
            };
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$formatTemplate$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatTemplate"])(settings, settings.prettyErrorTemplate, placeholderValuesError);
        },
        transportFormatted (logMetaMarkup, logArgs, logErrors, logMeta, settings) {
            const prettyLogs = settings.stylePrettyLogs !== false;
            const logErrorsStr = (logErrors.length > 0 && logArgs.length > 0 ? "\n" : "") + logErrors.join("\n");
            const sanitizedMetaMarkup = stripAnsi(logMetaMarkup);
            const metaMarkupForText = prettyLogs ? logMetaMarkup : sanitizedMetaMarkup;
            if (shouldUseCss(prettyLogs)) {
                settings.prettyInspectOptions.colors = false;
                const formattedArgs = formatWithOptionsSafe(settings.prettyInspectOptions, logArgs);
                const cssMeta = logMeta != null ? buildCssMetaOutput(settings, logMeta) : {
                    text: sanitizedMetaMarkup,
                    styles: []
                };
                const hasCssMeta = cssMeta.text.length > 0 && cssMeta.styles.length > 0;
                const metaOutput = hasCssMeta ? cssMeta.text : sanitizedMetaMarkup;
                const output = metaOutput + formattedArgs + logErrorsStr;
                if (hasCssMeta) {
                    console.log(output, ...cssMeta.styles);
                } else {
                    console.log(output);
                }
                return;
            }
            settings.prettyInspectOptions.colors = prettyLogs;
            const formattedArgs = formatWithOptionsSafe(settings.prettyInspectOptions, logArgs);
            console.log(metaMarkupForText + formattedArgs + logErrorsStr);
        },
        transportJSON (json) {
            console.log((0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$jsonStringifyRecursive$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsonStringifyRecursive"])(json));
        }
    };
    if (getNodeEnv() === "test") {
        environment.__resetWorkingDirectoryCacheForTests = ()=>{
            cachedCwd = undefined;
        };
    }
    return environment;
    //TURBOPACK unreachable
    ;
    function parseStackLine(line) {
        return usesBrowserStack ? parseBrowserStackLine(line) : parseServerStackLine(line);
    }
    function parseServerStackLine(rawLine) {
        if (typeof rawLine !== "string" || rawLine.length === 0) {
            return undefined;
        }
        const trimmedLine = rawLine.trim();
        if (!trimmedLine.includes(" at ") && !trimmedLine.startsWith("at ")) {
            return undefined;
        }
        const line = trimmedLine.replace(/^at\s+/, "");
        let method;
        let location = line;
        const methodMatch = line.match(/^(.*?)\s+\((.*)\)$/);
        if (methodMatch) {
            method = methodMatch[1];
            location = methodMatch[2];
        }
        const sanitizedLocation = location.replace(/^\(/, "").replace(/\)$/, "");
        const withoutQuery = sanitizedLocation.replace(/\?.*$/, "");
        let fileLine;
        let fileColumn;
        let filePathCandidate = withoutQuery;
        const segments = withoutQuery.split(":");
        if (segments.length >= 3 && /^\d+$/.test(segments[segments.length - 1] ?? "")) {
            fileColumn = segments.pop();
            fileLine = segments.pop();
            filePathCandidate = segments.join(":");
        } else if (segments.length >= 2 && /^\d+$/.test(segments[segments.length - 1] ?? "")) {
            fileLine = segments.pop();
            filePathCandidate = segments.join(":");
        }
        let normalizedPath = filePathCandidate.replace(/^file:\/\//, "");
        const cwd = getWorkingDirectory();
        if (cwd != null && normalizedPath.startsWith(cwd)) {
            normalizedPath = normalizedPath.slice(cwd.length);
            normalizedPath = normalizedPath.replace(/^[\\/]/, "");
        }
        if (normalizedPath.length === 0) {
            normalizedPath = filePathCandidate;
        }
        const normalizedPathWithoutLine = normalizeFilePath(normalizedPath);
        const effectivePath = normalizedPathWithoutLine.length > 0 ? normalizedPathWithoutLine : normalizedPath;
        const pathSegments = effectivePath.split(/\\|\//);
        const fileName = pathSegments[pathSegments.length - 1];
        const fileNameWithLine = fileName && fileLine ? `${fileName}:${fileLine}` : undefined;
        const filePathWithLine = effectivePath && fileLine ? `${effectivePath}:${fileLine}` : undefined;
        return {
            fullFilePath: sanitizedLocation,
            fileName,
            fileNameWithLine,
            fileColumn,
            fileLine,
            filePath: effectivePath,
            filePathWithLine,
            method
        };
    }
    function parseBrowserStackLine(line) {
        const href = globalThis.location?.origin;
        if (line == null) {
            return undefined;
        }
        const match = line.match(BROWSER_PATH_REGEX);
        if (!match) {
            return undefined;
        }
        const filePath = match[1]?.replace(/\?.*$/, "");
        if (filePath == null) {
            return undefined;
        }
        const pathParts = filePath.split("/");
        const fileLine = match[2];
        const fileColumn = match[3];
        const fileName = pathParts[pathParts.length - 1];
        return {
            fullFilePath: href ? `${href}${filePath}` : filePath,
            fileName,
            fileNameWithLine: fileName && fileLine ? `${fileName}:${fileLine}` : undefined,
            fileColumn,
            fileLine,
            filePath,
            filePathWithLine: fileLine ? `${filePath}:${fileLine}` : undefined,
            method: undefined
        };
    }
    function formatStackFrames(frames, settings) {
        return frames.map((stackFrame)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$formatTemplate$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatTemplate"])(settings, settings.prettyErrorStackTemplate, {
                ...stackFrame
            }, true));
    }
    function formatErrorMessage(error) {
        return Object.getOwnPropertyNames(error).filter((key)=>key !== "stack" && key !== "cause").reduce((result, key)=>{
            const value = error[key];
            if (typeof value === "function") {
                return result;
            }
            result.push(String(value));
            return result;
        }, []).join(", ");
    }
    function shouldUseCss(prettyLogs) {
        return prettyLogs && (runtimeInfo.name === "browser" || runtimeInfo.name === "worker") && (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$environment$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["consoleSupportsCssStyling"])();
    }
    function stripAnsi(value) {
        return value.replace(ANSI_REGEX, "");
    }
    function buildCssMetaOutput(settings, metaValue) {
        if (metaValue == null) {
            return {
                text: "",
                styles: []
            };
        }
        const { template, placeholders } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$metaFormatting$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildPrettyMeta"])(settings, metaValue);
        const parts = [];
        const styles = [];
        let lastIndex = 0;
        const placeholderRegex = /{{(.+?)}}/g;
        let match;
        while((match = placeholderRegex.exec(template)) != null){
            if (match.index > lastIndex) {
                parts.push(template.slice(lastIndex, match.index));
            }
            const key = match[1];
            const rawValue = placeholders[key] != null ? String(placeholders[key]) : "";
            const tokens = collectStyleTokens(settings.prettyLogStyles?.[key], rawValue);
            const css = tokensToCss(tokens);
            if (css.length > 0) {
                parts.push(`%c${rawValue}%c`);
                styles.push(css, "");
            } else {
                parts.push(rawValue);
            }
            lastIndex = placeholderRegex.lastIndex;
        }
        if (lastIndex < template.length) {
            parts.push(template.slice(lastIndex));
        }
        return {
            text: parts.join(""),
            styles
        };
    }
    function collectStyleTokens(style, value) {
        if (style == null) {
            return [];
        }
        if (typeof style === "string") {
            return [
                style
            ];
        }
        if (Array.isArray(style)) {
            return style.flatMap((token)=>collectStyleTokens(token, value));
        }
        if (typeof style === "object") {
            const normalizedValue = value.trim();
            const nextStyle = style[normalizedValue] ?? style["*"];
            if (nextStyle == null) {
                return [];
            }
            return collectStyleTokens(nextStyle, value);
        }
        return [];
    }
    function tokensToCss(tokens) {
        const seen = new Set();
        const cssParts = [];
        for (const token of tokens){
            const css = styleTokenToCss(token);
            if (css != null && css.length > 0 && !seen.has(css)) {
                seen.add(css);
                cssParts.push(css);
            }
        }
        return cssParts.join("; ");
    }
    function styleTokenToCss(token) {
        const color = COLOR_TOKENS[token];
        if (color != null) {
            return `color: ${color}`;
        }
        const background = BACKGROUND_TOKENS[token];
        if (background != null) {
            return `background-color: ${background}`;
        }
        switch(token){
            case "bold":
                return "font-weight: bold";
            case "dim":
                return "opacity: 0.75";
            case "italic":
                return "font-style: italic";
            case "underline":
                return "text-decoration: underline";
            case "overline":
                return "text-decoration: overline";
            case "inverse":
                return "filter: invert(1)";
            case "hidden":
                return "visibility: hidden";
            case "strikethrough":
                return "text-decoration: line-through";
            default:
                return undefined;
        }
    }
    function getWorkingDirectory() {
        if (cachedCwd === undefined) {
            cachedCwd = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$environment$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["safeGetCwd"])() ?? null;
        }
        return cachedCwd ?? undefined;
    }
    function shouldCaptureHostname() {
        return runtimeInfo.name === "node" || runtimeInfo.name === "deno" || runtimeInfo.name === "bun";
    }
    function shouldCaptureRuntimeVersion() {
        return runtimeInfo.name === "node" || runtimeInfo.name === "deno" || runtimeInfo.name === "bun";
    }
    function createRuntimeMeta(info) {
        if (info.name === "browser" || info.name === "worker") {
            return {
                runtime: info.name,
                browser: info.userAgent
            };
        }
        const metaStatic = {
            runtime: info.name
        };
        if (shouldCaptureRuntimeVersion()) {
            metaStatic.runtimeVersion = info.version ?? "unknown";
        }
        if (shouldCaptureHostname()) {
            metaStatic.hostname = info.hostname ?? "unknown";
        }
        return metaStatic;
    }
    function formatWithOptionsSafe(options, args) {
        try {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$util$2e$inspect$2e$polyfill$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatWithOptions"])(options, ...args);
        } catch  {
            return args.map(stringifyFallback).join(" ");
        }
    }
    function stringifyFallback(value) {
        if (typeof value === "string") {
            return value;
        }
        try {
            return JSON.stringify(value);
        } catch  {
            return String(value);
        }
    }
    function normalizeFilePath(value) {
        if (typeof value !== "string" || value.length === 0) {
            return value;
        }
        const replaced = value.replace(/\\+/g, "\\").replace(/\\/g, "/");
        const hasRootDoubleSlash = replaced.startsWith("//");
        const hasLeadingSlash = replaced.startsWith("/") && !hasRootDoubleSlash;
        const driveMatch = replaced.match(/^[A-Za-z]:/);
        const drivePrefix = driveMatch ? driveMatch[0] : "";
        const withoutDrive = drivePrefix ? replaced.slice(drivePrefix.length) : replaced;
        const segments = withoutDrive.split("/");
        const normalizedSegments = [];
        for (const segment of segments){
            if (segment === "" || segment === ".") {
                continue;
            }
            if (segment === "..") {
                if (normalizedSegments.length > 0) {
                    normalizedSegments.pop();
                }
                continue;
            }
            normalizedSegments.push(segment);
        }
        let normalized = normalizedSegments.join("/");
        if (hasRootDoubleSlash) {
            normalized = `//${normalized}`;
        } else if (hasLeadingSlash) {
            normalized = `/${normalized}`;
        } else if (drivePrefix !== "") {
            normalized = `${drivePrefix}${normalized.length > 0 ? `/${normalized}` : ""}`;
        }
        if (normalized.length === 0) {
            return value;
        }
        return normalized;
    }
    function detectRuntimeInfo() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$environment$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isBrowserEnvironment"])()) {
            const navigatorObj = globalThis.navigator;
            return {
                name: "browser",
                userAgent: navigatorObj?.userAgent
            };
        }
        const globalScope = globalThis;
        if (typeof globalScope.importScripts === "function") {
            return {
                name: "worker",
                userAgent: globalScope.navigator?.userAgent
            };
        }
        const globalAny = globalThis;
        if (globalAny.Bun != null) {
            const bunVersion = globalAny.Bun.version;
            return {
                name: "bun",
                version: bunVersion != null ? `bun/${bunVersion}` : undefined,
                hostname: getEnvironmentHostname(globalAny.process, globalAny.Deno, globalAny.Bun, globalAny.location)
            };
        }
        if (globalAny.Deno != null) {
            const denoHostname = resolveDenoHostname(globalAny.Deno);
            const denoVersion = globalAny.Deno?.version?.deno;
            return {
                name: "deno",
                version: denoVersion != null ? `deno/${denoVersion}` : undefined,
                hostname: denoHostname ?? getEnvironmentHostname(globalAny.process, globalAny.Deno, globalAny.Bun, globalAny.location)
            };
        }
        if (globalAny.process?.versions?.node != null || globalAny.process?.version != null) {
            return {
                name: "node",
                version: globalAny.process?.versions?.node ?? globalAny.process?.version,
                hostname: getEnvironmentHostname(globalAny.process, globalAny.Deno, globalAny.Bun, globalAny.location)
            };
        }
        if (globalAny.process != null) {
            return {
                name: "node",
                version: "unknown",
                hostname: getEnvironmentHostname(globalAny.process, globalAny.Deno, globalAny.Bun, globalAny.location)
            };
        }
        return {
            name: "unknown"
        };
    }
    function getEnvironmentHostname(nodeProcess, deno, bun, location) {
        const processHostname = nodeProcess?.env?.HOSTNAME ?? nodeProcess?.env?.HOST ?? nodeProcess?.env?.COMPUTERNAME;
        if (processHostname != null && processHostname.length > 0) {
            return processHostname;
        }
        const bunHostname = bun?.env?.HOSTNAME ?? bun?.env?.HOST ?? bun?.env?.COMPUTERNAME;
        if (bunHostname != null && bunHostname.length > 0) {
            return bunHostname;
        }
        try {
            const denoEnvGet = deno?.env?.get;
            if (typeof denoEnvGet === "function") {
                const value = denoEnvGet("HOSTNAME");
                if (value != null && value.length > 0) {
                    return value;
                }
            }
        } catch  {}
        if (location?.hostname != null && location.hostname.length > 0) {
            return location.hostname;
        }
        return undefined;
    }
    function resolveDenoHostname(deno) {
        try {
            if (typeof deno?.hostname === "function") {
                const value = deno.hostname();
                if (value != null && value.length > 0) {
                    return value;
                }
            }
        } catch  {}
        const locationHostname = globalThis.location?.hostname;
        if (locationHostname != null && locationHostname.length > 0) {
            return locationHostname;
        }
        return undefined;
    }
    function getNodeEnv() {
        const globalProcess = globalThis?.process;
        return globalProcess?.env?.NODE_ENV;
    }
    function isNativeError(value) {
        if (value instanceof Error) {
            return true;
        }
        if (value != null && typeof value === "object") {
            const objectTag = Object.prototype.toString.call(value);
            if (/\[object .*Error\]/.test(objectTag)) {
                return true;
            }
            const name = value.name;
            if (typeof name === "string" && name.endsWith("Error")) {
                return true;
            }
        }
        return false;
    }
}
const ANSI_REGEX = /\u001b\[[0-9;]*m/g;
const COLOR_TOKENS = {
    black: "#000000",
    red: "#ef5350",
    green: "#66bb6a",
    yellow: "#fdd835",
    blue: "#42a5f5",
    magenta: "#ab47bc",
    cyan: "#26c6da",
    white: "#fafafa",
    blackBright: "#424242",
    redBright: "#ff7043",
    greenBright: "#81c784",
    yellowBright: "#ffe082",
    blueBright: "#64b5f6",
    magentaBright: "#ce93d8",
    cyanBright: "#4dd0e1",
    whiteBright: "#ffffff"
};
const BACKGROUND_TOKENS = {
    bgBlack: "#000000",
    bgRed: "#ef5350",
    bgGreen: "#66bb6a",
    bgYellow: "#fdd835",
    bgBlue: "#42a5f5",
    bgMagenta: "#ab47bc",
    bgCyan: "#26c6da",
    bgWhite: "#fafafa",
    bgBlackBright: "#424242",
    bgRedBright: "#ff7043",
    bgGreenBright: "#81c784",
    bgYellowBright: "#ffe082",
    bgBlueBright: "#64b5f6",
    bgMagentaBright: "#ce93d8",
    bgCyanBright: "#4dd0e1",
    bgWhiteBright: "#ffffff"
};
const BROWSER_PATH_REGEX = /(?:(?:file|https?|global code|[^@]+)@)?(?:file:)?((?:\/[^:/]+){2,})(?::(\d+))?(?::(\d+))?/;
const runtime = createLoggerEnvironment();
const loggerEnvironment = runtime;
;
class BaseLogger {
    constructor(settings, logObj, stackDepthLevel = Number.NaN){
        this.logObj = logObj;
        this.stackDepthLevel = stackDepthLevel;
        this.runtime = runtime;
        this.maxErrorCauseDepth = 5;
        this.settings = {
            type: settings?.type ?? "pretty",
            name: settings?.name,
            parentNames: settings?.parentNames,
            minLevel: settings?.minLevel ?? 0,
            argumentsArrayName: settings?.argumentsArrayName,
            hideLogPositionForProduction: settings?.hideLogPositionForProduction ?? false,
            prettyLogTemplate: settings?.prettyLogTemplate ?? "{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}\t{{logLevelName}}\t{{filePathWithLine}}{{nameWithDelimiterPrefix}}\t",
            prettyErrorTemplate: settings?.prettyErrorTemplate ?? "\n{{errorName}} {{errorMessage}}\nerror stack:\n{{errorStack}}",
            prettyErrorStackTemplate: settings?.prettyErrorStackTemplate ?? "   {{fileName}}\t{{method}}\n\t{{filePathWithLine}}",
            prettyErrorParentNamesSeparator: settings?.prettyErrorParentNamesSeparator ?? ":",
            prettyErrorLoggerNameDelimiter: settings?.prettyErrorLoggerNameDelimiter ?? "\t",
            stylePrettyLogs: settings?.stylePrettyLogs ?? true,
            prettyLogTimeZone: settings?.prettyLogTimeZone ?? "UTC",
            prettyLogStyles: settings?.prettyLogStyles ?? {
                logLevelName: {
                    "*": [
                        "bold",
                        "black",
                        "bgWhiteBright",
                        "dim"
                    ],
                    SILLY: [
                        "bold",
                        "white"
                    ],
                    TRACE: [
                        "bold",
                        "whiteBright"
                    ],
                    DEBUG: [
                        "bold",
                        "green"
                    ],
                    INFO: [
                        "bold",
                        "blue"
                    ],
                    WARN: [
                        "bold",
                        "yellow"
                    ],
                    ERROR: [
                        "bold",
                        "red"
                    ],
                    FATAL: [
                        "bold",
                        "redBright"
                    ]
                },
                dateIsoStr: "white",
                filePathWithLine: "white",
                name: [
                    "white",
                    "bold"
                ],
                nameWithDelimiterPrefix: [
                    "white",
                    "bold"
                ],
                nameWithDelimiterSuffix: [
                    "white",
                    "bold"
                ],
                errorName: [
                    "bold",
                    "bgRedBright",
                    "whiteBright"
                ],
                fileName: [
                    "yellow"
                ],
                fileNameWithLine: "white"
            },
            prettyInspectOptions: settings?.prettyInspectOptions ?? {
                colors: true,
                compact: false,
                depth: Infinity
            },
            metaProperty: settings?.metaProperty ?? "_meta",
            maskPlaceholder: settings?.maskPlaceholder ?? "[***]",
            maskValuesOfKeys: settings?.maskValuesOfKeys ?? [
                "password"
            ],
            maskValuesOfKeysCaseInsensitive: settings?.maskValuesOfKeysCaseInsensitive ?? false,
            maskValuesRegEx: settings?.maskValuesRegEx,
            prefix: [
                ...settings?.prefix ?? []
            ],
            attachedTransports: [
                ...settings?.attachedTransports ?? []
            ],
            overwrite: {
                mask: settings?.overwrite?.mask,
                toLogObj: settings?.overwrite?.toLogObj,
                addMeta: settings?.overwrite?.addMeta,
                addPlaceholders: settings?.overwrite?.addPlaceholders,
                formatMeta: settings?.overwrite?.formatMeta,
                formatLogObj: settings?.overwrite?.formatLogObj,
                transportFormatted: settings?.overwrite?.transportFormatted,
                transportJSON: settings?.overwrite?.transportJSON
            }
        };
        this.captureStackForMeta = this._shouldCaptureStack();
    }
    log(logLevelId, logLevelName, ...args) {
        if (logLevelId < this.settings.minLevel) {
            return;
        }
        const resolvedArgs = this._resolveLogArguments(args);
        const logArgs = [
            ...this.settings.prefix,
            ...resolvedArgs
        ];
        const maskedArgs = this.settings.overwrite?.mask != null ? this.settings.overwrite?.mask(logArgs) : this.settings.maskValuesOfKeys != null && this.settings.maskValuesOfKeys.length > 0 ? this._mask(logArgs) : logArgs;
        const thisLogObj = this.logObj != null ? this._recursiveCloneAndExecuteFunctions(this.logObj) : undefined;
        const logObj = this.settings.overwrite?.toLogObj != null ? this.settings.overwrite?.toLogObj(maskedArgs, thisLogObj) : this._toLogObj(maskedArgs, thisLogObj);
        const logObjWithMeta = this.settings.overwrite?.addMeta != null ? this.settings.overwrite?.addMeta(logObj, logLevelId, logLevelName) : this._addMetaToLogObj(logObj, logLevelId, logLevelName);
        const logMeta = logObjWithMeta?.[this.settings.metaProperty];
        let logMetaMarkup;
        let logArgsAndErrorsMarkup = undefined;
        if (this.settings.overwrite?.formatMeta != null) {
            logMetaMarkup = this.settings.overwrite?.formatMeta(logObjWithMeta?.[this.settings.metaProperty]);
        }
        if (this.settings.overwrite?.formatLogObj != null) {
            logArgsAndErrorsMarkup = this.settings.overwrite?.formatLogObj(maskedArgs, this.settings);
        }
        if (this.settings.type === "pretty") {
            logMetaMarkup = logMetaMarkup ?? this._prettyFormatLogObjMeta(logObjWithMeta?.[this.settings.metaProperty]);
            logArgsAndErrorsMarkup = logArgsAndErrorsMarkup ?? runtime.prettyFormatLogObj(maskedArgs, this.settings);
        }
        if (logMetaMarkup != null && logArgsAndErrorsMarkup != null) {
            if (this.settings.overwrite?.transportFormatted != null) {
                const transport = this.settings.overwrite.transportFormatted;
                const declaredParams = transport.length;
                if (declaredParams < 4) {
                    transport(logMetaMarkup, logArgsAndErrorsMarkup.args, logArgsAndErrorsMarkup.errors);
                } else if (declaredParams === 4) {
                    transport(logMetaMarkup, logArgsAndErrorsMarkup.args, logArgsAndErrorsMarkup.errors, logMeta);
                } else {
                    transport(logMetaMarkup, logArgsAndErrorsMarkup.args, logArgsAndErrorsMarkup.errors, logMeta, this.settings);
                }
            } else {
                runtime.transportFormatted(logMetaMarkup, logArgsAndErrorsMarkup.args, logArgsAndErrorsMarkup.errors, logMeta, this.settings);
            }
        } else {
            if (this.settings.overwrite?.transportJSON != null) {
                this.settings.overwrite.transportJSON(logObjWithMeta);
            } else if (this.settings.type !== "hidden") {
                runtime.transportJSON(logObjWithMeta);
            }
        }
        if (this.settings.attachedTransports != null && this.settings.attachedTransports.length > 0) {
            this.settings.attachedTransports.forEach((transportLogger)=>{
                transportLogger(logObjWithMeta);
            });
        }
        return logObjWithMeta;
    }
    attachTransport(transportLogger) {
        this.settings.attachedTransports.push(transportLogger);
    }
    getSubLogger(settings, logObj) {
        const subLoggerSettings = {
            ...this.settings,
            ...settings,
            parentNames: this.settings?.parentNames != null && this.settings?.name != null ? [
                ...this.settings.parentNames,
                this.settings.name
            ] : this.settings?.name != null ? [
                this.settings.name
            ] : undefined,
            prefix: [
                ...this.settings.prefix,
                ...settings?.prefix ?? []
            ]
        };
        const subLogger = new this.constructor(subLoggerSettings, logObj ?? this.logObj, this.stackDepthLevel);
        return subLogger;
    }
    _mask(args) {
        const maskKeys = this._getMaskKeys();
        return args?.map((arg)=>{
            return this._recursiveCloneAndMaskValuesOfKeys(arg, maskKeys);
        });
    }
    _getMaskKeys() {
        const maskKeys = this.settings.maskValuesOfKeys ?? [];
        const signature = maskKeys.map(String).join("|");
        if (this.settings.maskValuesOfKeysCaseInsensitive === true) {
            if (this.maskKeysCache?.source === maskKeys && this.maskKeysCache.caseInsensitive === true && this.maskKeysCache.signature === signature) {
                return this.maskKeysCache.normalized;
            }
            const normalized = maskKeys.map((key)=>typeof key === "string" ? key.toLowerCase() : String(key).toLowerCase());
            this.maskKeysCache = {
                source: maskKeys,
                caseInsensitive: true,
                normalized,
                signature
            };
            return normalized;
        }
        this.maskKeysCache = {
            source: maskKeys,
            caseInsensitive: false,
            normalized: maskKeys,
            signature
        };
        return maskKeys;
    }
    _resolveLogArguments(args) {
        if (args.length === 1 && typeof args[0] === "function") {
            const candidate = args[0];
            if (candidate.length === 0) {
                const result = candidate();
                return Array.isArray(result) ? result : [
                    result
                ];
            }
        }
        return args;
    }
    _recursiveCloneAndMaskValuesOfKeys(source, keys, seen = []) {
        if (seen.includes(source)) {
            return {
                ...source
            };
        }
        if (typeof source === "object" && source !== null) {
            seen.push(source);
        }
        if (runtime.isError(source) || runtime.isBuffer(source)) {
            return source;
        } else if (source instanceof Map) {
            return new Map(source);
        } else if (source instanceof Set) {
            return new Set(source);
        } else if (Array.isArray(source)) {
            return source.map((item)=>this._recursiveCloneAndMaskValuesOfKeys(item, keys, seen));
        } else if (source instanceof Date) {
            return new Date(source.getTime());
        } else if (source instanceof URL) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$urlToObj$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["urlToObject"])(source);
        } else if (source !== null && typeof source === "object") {
            const baseObject = runtime.isError(source) ? this._cloneError(source) : Object.create(Object.getPrototypeOf(source));
            return Object.getOwnPropertyNames(source).reduce((o, prop)=>{
                const lookupKey = this.settings?.maskValuesOfKeysCaseInsensitive !== true ? prop : typeof prop === "string" ? prop.toLowerCase() : String(prop).toLowerCase();
                o[prop] = keys.includes(lookupKey) ? this.settings.maskPlaceholder : (()=>{
                    try {
                        return this._recursiveCloneAndMaskValuesOfKeys(source[prop], keys, seen);
                    } catch  {
                        return null;
                    }
                })();
                return o;
            }, baseObject);
        } else {
            if (typeof source === "string") {
                let modifiedSource = source;
                for (const regEx of this.settings?.maskValuesRegEx || []){
                    modifiedSource = modifiedSource.replace(regEx, this.settings?.maskPlaceholder || "");
                }
                return modifiedSource;
            }
            return source;
        }
    }
    _recursiveCloneAndExecuteFunctions(source, seen = []) {
        if (this.isObjectOrArray(source) && seen.includes(source)) {
            return this.shallowCopy(source);
        }
        if (this.isObjectOrArray(source)) {
            seen.push(source);
        }
        if (Array.isArray(source)) {
            return source.map((item)=>this._recursiveCloneAndExecuteFunctions(item, seen));
        } else if (source instanceof Date) {
            return new Date(source.getTime());
        } else if (this.isObject(source)) {
            return Object.getOwnPropertyNames(source).reduce((o, prop)=>{
                const descriptor = Object.getOwnPropertyDescriptor(source, prop);
                if (descriptor) {
                    Object.defineProperty(o, prop, descriptor);
                    const value = source[prop];
                    o[prop] = typeof value === "function" ? value() : this._recursiveCloneAndExecuteFunctions(value, seen);
                }
                return o;
            }, Object.create(Object.getPrototypeOf(source)));
        } else {
            return source;
        }
    }
    isObjectOrArray(value) {
        return typeof value === "object" && value !== null;
    }
    isObject(value) {
        return typeof value === "object" && !Array.isArray(value) && value !== null;
    }
    shallowCopy(source) {
        if (Array.isArray(source)) {
            return [
                ...source
            ];
        } else {
            return {
                ...source
            };
        }
    }
    _toLogObj(args, clonedLogObj = {}) {
        args = args?.map((arg)=>runtime.isError(arg) ? this._toErrorObject(arg) : arg);
        if (this.settings.argumentsArrayName == null) {
            if (args.length === 1 && !Array.isArray(args[0]) && runtime.isBuffer(args[0]) !== true && !(args[0] instanceof Date)) {
                clonedLogObj = typeof args[0] === "object" && args[0] != null ? {
                    ...args[0],
                    ...clonedLogObj
                } : {
                    0: args[0],
                    ...clonedLogObj
                };
            } else {
                clonedLogObj = {
                    ...clonedLogObj,
                    ...args
                };
            }
        } else {
            clonedLogObj = {
                ...clonedLogObj,
                [this.settings.argumentsArrayName]: args
            };
        }
        return clonedLogObj;
    }
    _cloneError(error) {
        const cloned = new error.constructor();
        Object.getOwnPropertyNames(error).forEach((key)=>{
            cloned[key] = error[key];
        });
        return cloned;
    }
    _toErrorObject(error, depth = 0, seen = new Set()) {
        if (!seen.has(error)) {
            seen.add(error);
        }
        const errorObject = {
            nativeError: error,
            name: error.name ?? "Error",
            message: error.message,
            stack: runtime.getErrorTrace(error)
        };
        if (depth >= this.maxErrorCauseDepth) {
            return errorObject;
        }
        const causeValue = error.cause;
        if (causeValue != null) {
            const normalizedCause = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$errorUtils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toError"])(causeValue);
            if (!seen.has(normalizedCause)) {
                errorObject.cause = this._toErrorObject(normalizedCause, depth + 1, seen);
            }
        }
        return errorObject;
    }
    _addMetaToLogObj(logObj, logLevelId, logLevelName) {
        return {
            ...logObj,
            [this.settings.metaProperty]: runtime.getMeta(logLevelId, logLevelName, this.stackDepthLevel, !this.captureStackForMeta, this.settings.name, this.settings.parentNames)
        };
    }
    _shouldCaptureStack() {
        if (this.settings.hideLogPositionForProduction) {
            return false;
        }
        if (this.settings.type === "json") {
            return true;
        }
        const template = this.settings.prettyLogTemplate ?? "";
        const stackPlaceholders = /{{\s*(file(Name|Path|Line|PathWithLine|NameWithLine)|fullFilePath)\s*}}/;
        if (stackPlaceholders.test(template)) {
            return true;
        }
        return false;
    }
    _prettyFormatLogObjMeta(logObjMeta) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$internal$2f$metaFormatting$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildPrettyMeta"])(this.settings, logObjMeta).text;
    }
}
}),
"[project]/align/node_modules/tslog/esm/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Logger",
    ()=>Logger
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$BaseLogger$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/align/node_modules/tslog/esm/BaseLogger.js [app-route] (ecmascript) <locals>");
;
;
;
class Logger extends __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$tslog$2f$esm$2f$BaseLogger$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["BaseLogger"] {
    constructor(settings, logObj){
        const isBrowser = ("TURBOPACK compile-time value", "undefined") !== "undefined" && typeof document !== "undefined";
        const normalizedSettings = {
            ...settings ?? {}
        };
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        super(normalizedSettings, logObj, Number.NaN);
    }
    log(logLevelId, logLevelName, ...args) {
        return super.log(logLevelId, logLevelName, ...args);
    }
    silly(...args) {
        return super.log(0, "SILLY", ...args);
    }
    trace(...args) {
        return super.log(1, "TRACE", ...args);
    }
    debug(...args) {
        return super.log(2, "DEBUG", ...args);
    }
    info(...args) {
        return super.log(3, "INFO", ...args);
    }
    warn(...args) {
        return super.log(4, "WARN", ...args);
    }
    error(...args) {
        return super.log(5, "ERROR", ...args);
    }
    fatal(...args) {
        return super.log(6, "FATAL", ...args);
    }
    getSubLogger(settings, logObj) {
        return super.getSubLogger(settings, logObj);
    }
}
}),
"[project]/align/node_modules/ini/lib/ini.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const { hasOwnProperty } = Object.prototype;
const encode = (obj, opt = {})=>{
    if (typeof opt === 'string') {
        opt = {
            section: opt
        };
    }
    opt.align = opt.align === true;
    opt.newline = opt.newline === true;
    opt.sort = opt.sort === true;
    opt.whitespace = opt.whitespace === true || opt.align === true;
    // The `typeof` check is required because accessing the `process` directly fails on browsers.
    /* istanbul ignore next */ opt.platform = opt.platform || typeof process !== 'undefined' && process.platform;
    opt.bracketedArray = opt.bracketedArray !== false;
    /* istanbul ignore next */ const eol = opt.platform === 'win32' ? '\r\n' : '\n';
    const separator = opt.whitespace ? ' = ' : '=';
    const children = [];
    const keys = opt.sort ? Object.keys(obj).sort() : Object.keys(obj);
    let padToChars = 0;
    // If aligning on the separator, then padToChars is determined as follows:
    // 1. Get the keys
    // 2. Exclude keys pointing to objects unless the value is null or an array
    // 3. Add `[]` to array keys
    // 4. Ensure non empty set of keys
    // 5. Reduce the set to the longest `safe` key
    // 6. Get the `safe` length
    if (opt.align) {
        padToChars = safe(keys.filter((k)=>obj[k] === null || Array.isArray(obj[k]) || typeof obj[k] !== 'object').map((k)=>Array.isArray(obj[k]) ? `${k}[]` : k).concat([
            ''
        ]).reduce((a, b)=>safe(a).length >= safe(b).length ? a : b)).length;
    }
    let out = '';
    const arraySuffix = opt.bracketedArray ? '[]' : '';
    for (const k of keys){
        const val = obj[k];
        if (val && Array.isArray(val)) {
            for (const item of val){
                out += safe(`${k}${arraySuffix}`).padEnd(padToChars, ' ') + separator + safe(item) + eol;
            }
        } else if (val && typeof val === 'object') {
            children.push(k);
        } else {
            out += safe(k).padEnd(padToChars, ' ') + separator + safe(val) + eol;
        }
    }
    if (opt.section && out.length) {
        out = '[' + safe(opt.section) + ']' + (opt.newline ? eol + eol : eol) + out;
    }
    for (const k of children){
        const nk = splitSections(k, '.').join('\\.');
        const section = (opt.section ? opt.section + '.' : '') + nk;
        const child = encode(obj[k], {
            ...opt,
            section
        });
        if (out.length && child.length) {
            out += eol;
        }
        out += child;
    }
    return out;
};
function splitSections(str, separator) {
    var lastMatchIndex = 0;
    var lastSeparatorIndex = 0;
    var nextIndex = 0;
    var sections = [];
    do {
        nextIndex = str.indexOf(separator, lastMatchIndex);
        if (nextIndex !== -1) {
            lastMatchIndex = nextIndex + separator.length;
            if (nextIndex > 0 && str[nextIndex - 1] === '\\') {
                continue;
            }
            sections.push(str.slice(lastSeparatorIndex, nextIndex));
            lastSeparatorIndex = nextIndex + separator.length;
        }
    }while (nextIndex !== -1)
    sections.push(str.slice(lastSeparatorIndex));
    return sections;
}
const decode = (str, opt = {})=>{
    opt.bracketedArray = opt.bracketedArray !== false;
    const out = Object.create(null);
    let p = out;
    let section = null;
    //          section          |key      = value
    const re = /^\[([^\]]*)\]\s*$|^([^=]+)(=(.*))?$/i;
    const lines = str.split(/[\r\n]+/g);
    const duplicates = {};
    for (const line of lines){
        if (!line || line.match(/^\s*[;#]/) || line.match(/^\s*$/)) {
            continue;
        }
        const match = line.match(re);
        if (!match) {
            continue;
        }
        if (match[1] !== undefined) {
            section = unsafe(match[1]);
            if (section === '__proto__') {
                // not allowed
                // keep parsing the section, but don't attach it.
                p = Object.create(null);
                continue;
            }
            p = out[section] = out[section] || Object.create(null);
            continue;
        }
        const keyRaw = unsafe(match[2]);
        let isArray;
        if (opt.bracketedArray) {
            isArray = keyRaw.length > 2 && keyRaw.slice(-2) === '[]';
        } else {
            duplicates[keyRaw] = (duplicates?.[keyRaw] || 0) + 1;
            isArray = duplicates[keyRaw] > 1;
        }
        const key = isArray && keyRaw.endsWith('[]') ? keyRaw.slice(0, -2) : keyRaw;
        if (key === '__proto__') {
            continue;
        }
        const valueRaw = match[3] ? unsafe(match[4]) : true;
        const value = valueRaw === 'true' || valueRaw === 'false' || valueRaw === 'null' ? JSON.parse(valueRaw) : valueRaw;
        // Convert keys with '[]' suffix to an array
        if (isArray) {
            if (!hasOwnProperty.call(p, key)) {
                p[key] = [];
            } else if (!Array.isArray(p[key])) {
                p[key] = [
                    p[key]
                ];
            }
        }
        // safeguard against resetting a previously defined
        // array by accidentally forgetting the brackets
        if (Array.isArray(p[key])) {
            p[key].push(value);
        } else {
            p[key] = value;
        }
    }
    // {a:{y:1},"a.b":{x:2}} --> {a:{y:1,b:{x:2}}}
    // use a filter to return the keys that have to be deleted.
    const remove = [];
    for (const k of Object.keys(out)){
        if (!hasOwnProperty.call(out, k) || typeof out[k] !== 'object' || Array.isArray(out[k])) {
            continue;
        }
        // see if the parent section is also an object.
        // if so, add it to that, and mark this one for deletion
        const parts = splitSections(k, '.');
        p = out;
        const l = parts.pop();
        const nl = l.replace(/\\\./g, '.');
        for (const part of parts){
            if (part === '__proto__') {
                continue;
            }
            if (!hasOwnProperty.call(p, part) || typeof p[part] !== 'object') {
                p[part] = Object.create(null);
            }
            p = p[part];
        }
        if (p === out && nl === l) {
            continue;
        }
        p[nl] = out[k];
        remove.push(k);
    }
    for (const del of remove){
        delete out[del];
    }
    return out;
};
const isQuoted = (val)=>{
    return val.startsWith('"') && val.endsWith('"') || val.startsWith("'") && val.endsWith("'");
};
const safe = (val)=>{
    if (typeof val !== 'string' || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim()) {
        return JSON.stringify(val);
    }
    return val.split(';').join('\\;').split('#').join('\\#');
};
const unsafe = (val)=>{
    val = (val || '').trim();
    if (isQuoted(val)) {
        // remove the single quotes before calling JSON.parse
        if (val.charAt(0) === "'") {
            val = val.slice(1, -1);
        }
        try {
            val = JSON.parse(val);
        } catch  {
        // ignore errors
        }
    } else {
        // walk the val to find the first not-escaped ; character
        let esc = false;
        let unesc = '';
        for(let i = 0, l = val.length; i < l; i++){
            const c = val.charAt(i);
            if (esc) {
                if ('\\;#'.indexOf(c) !== -1) {
                    unesc += c;
                } else {
                    unesc += '\\' + c;
                }
                esc = false;
            } else if (';#'.indexOf(c) !== -1) {
                break;
            } else if (c === '\\') {
                esc = true;
            } else {
                unesc += c;
            }
        }
        if (esc) {
            unesc += '\\';
        }
        return unesc.trim();
    }
    return val;
};
module.exports = {
    parse: decode,
    decode,
    stringify: encode,
    encode,
    safe,
    unsafe
};
}),
"[project]/align/node_modules/dotenv/package.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"name":"dotenv","version":"16.6.1","description":"Loads environment variables from .env file","main":"lib/main.js","types":"lib/main.d.ts","exports":{".":{"types":"./lib/main.d.ts","require":"./lib/main.js","default":"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},"scripts":{"dts-check":"tsc --project tests/types/tsconfig.json","lint":"standard","pretest":"npm run lint && npm run dts-check","test":"tap run --allow-empty-coverage --disable-coverage --timeout=60000","test:coverage":"tap run --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov","prerelease":"npm test","release":"standard-version"},"repository":{"type":"git","url":"git://github.com/motdotla/dotenv.git"},"homepage":"https://github.com/motdotla/dotenv#readme","funding":"https://dotenvx.com","keywords":["dotenv","env",".env","environment","variables","config","settings"],"readmeFilename":"README.md","license":"BSD-2-Clause","devDependencies":{"@types/node":"^18.11.3","decache":"^4.6.2","sinon":"^14.0.1","standard":"^17.0.0","standard-version":"^9.5.0","tap":"^19.2.0","typescript":"^4.8.4"},"engines":{"node":">=12"},"browser":{"fs":false}});}),
"[project]/align/node_modules/dotenv/lib/main.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
const crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
const packageJson = __turbopack_context__.r("[project]/align/node_modules/dotenv/package.json (json)");
const version = packageJson.version;
const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
// Parse src into an Object
function parse(src) {
    const obj = {};
    // Convert buffer to string
    let lines = src.toString();
    // Convert line breaks to same format
    lines = lines.replace(/\r\n?/mg, '\n');
    let match;
    while((match = LINE.exec(lines)) != null){
        const key = match[1];
        // Default undefined or null to empty string
        let value = match[2] || '';
        // Remove whitespace
        value = value.trim();
        // Check if double quoted
        const maybeQuote = value[0];
        // Remove surrounding quotes
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, '$2');
        // Expand newlines if double quoted
        if (maybeQuote === '"') {
            value = value.replace(/\\n/g, '\n');
            value = value.replace(/\\r/g, '\r');
        }
        // Add to object
        obj[key] = value;
    }
    return obj;
}
function _parseVault(options) {
    options = options || {};
    const vaultPath = _vaultPath(options);
    options.path = vaultPath; // parse .env.vault
    const result = DotenvModule.configDotenv(options);
    if (!result.parsed) {
        const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
        err.code = 'MISSING_DATA';
        throw err;
    }
    // handle scenario for comma separated keys - for use with key rotation
    // example: DOTENV_KEY="dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod"
    const keys = _dotenvKey(options).split(',');
    const length = keys.length;
    let decrypted;
    for(let i = 0; i < length; i++){
        try {
            // Get full key
            const key = keys[i].trim();
            // Get instructions for decrypt
            const attrs = _instructions(result, key);
            // Decrypt
            decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
            break;
        } catch (error) {
            // last key
            if (i + 1 >= length) {
                throw error;
            }
        // try next key
        }
    }
    // Parse decrypted .env string
    return DotenvModule.parse(decrypted);
}
function _warn(message) {
    console.log(`[dotenv@${version}][WARN] ${message}`);
}
function _debug(message) {
    console.log(`[dotenv@${version}][DEBUG] ${message}`);
}
function _log(message) {
    console.log(`[dotenv@${version}] ${message}`);
}
function _dotenvKey(options) {
    // prioritize developer directly setting options.DOTENV_KEY
    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
        return options.DOTENV_KEY;
    }
    // secondary infra already contains a DOTENV_KEY environment variable
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
    }
    // fallback to empty string
    return '';
}
function _instructions(result, dotenvKey) {
    // Parse DOTENV_KEY. Format is a URI
    let uri;
    try {
        uri = new URL(dotenvKey);
    } catch (error) {
        if (error.code === 'ERR_INVALID_URL') {
            const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development');
            err.code = 'INVALID_DOTENV_KEY';
            throw err;
        }
        throw error;
    }
    // Get decrypt key
    const key = uri.password;
    if (!key) {
        const err = new Error('INVALID_DOTENV_KEY: Missing key part');
        err.code = 'INVALID_DOTENV_KEY';
        throw err;
    }
    // Get environment
    const environment = uri.searchParams.get('environment');
    if (!environment) {
        const err = new Error('INVALID_DOTENV_KEY: Missing environment part');
        err.code = 'INVALID_DOTENV_KEY';
        throw err;
    }
    // Get ciphertext payload
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION
    ;
    if (!ciphertext) {
        const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
        err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT';
        throw err;
    }
    return {
        ciphertext,
        key
    };
}
function _vaultPath(options) {
    let possibleVaultPath = null;
    if (options && options.path && options.path.length > 0) {
        if (Array.isArray(options.path)) {
            for (const filepath of options.path){
                if (fs.existsSync(filepath)) {
                    possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`;
                }
            }
        } else {
            possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`;
        }
    } else {
        possibleVaultPath = path.resolve(process.cwd(), '.env.vault');
    }
    if (fs.existsSync(possibleVaultPath)) {
        return possibleVaultPath;
    }
    return null;
}
function _resolveHome(envPath) {
    return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath;
}
function _configVault(options) {
    const debug = Boolean(options && options.debug);
    const quiet = options && 'quiet' in options ? options.quiet : true;
    if (debug || !quiet) {
        _log('Loading env from encrypted .env.vault');
    }
    const parsed = DotenvModule._parseVault(options);
    let processEnv = process.env;
    if (options && options.processEnv != null) {
        processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options);
    return {
        parsed
    };
}
function configDotenv(options) {
    const dotenvPath = path.resolve(process.cwd(), '.env');
    let encoding = 'utf8';
    const debug = Boolean(options && options.debug);
    const quiet = options && 'quiet' in options ? options.quiet : true;
    if (options && options.encoding) {
        encoding = options.encoding;
    } else {
        if (debug) {
            _debug('No encoding is specified. UTF-8 is used by default');
        }
    }
    let optionPaths = [
        dotenvPath
    ] // default, look for .env
    ;
    if (options && options.path) {
        if (!Array.isArray(options.path)) {
            optionPaths = [
                _resolveHome(options.path)
            ];
        } else {
            optionPaths = []; // reset default
            for (const filepath of options.path){
                optionPaths.push(_resolveHome(filepath));
            }
        }
    }
    // Build the parsed data in a temporary object (because we need to return it).  Once we have the final
    // parsed data, we will combine it with process.env (or options.processEnv if provided).
    let lastError;
    const parsedAll = {};
    for (const path of optionPaths){
        try {
            // Specifying an encoding returns a string instead of a buffer
            const parsed = DotenvModule.parse(fs.readFileSync(path, {
                encoding
            }));
            DotenvModule.populate(parsedAll, parsed, options);
        } catch (e) {
            if (debug) {
                _debug(`Failed to load ${path} ${e.message}`);
            }
            lastError = e;
        }
    }
    let processEnv = process.env;
    if (options && options.processEnv != null) {
        processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsedAll, options);
    if (debug || !quiet) {
        const keysCount = Object.keys(parsedAll).length;
        const shortPaths = [];
        for (const filePath of optionPaths){
            try {
                const relative = path.relative(process.cwd(), filePath);
                shortPaths.push(relative);
            } catch (e) {
                if (debug) {
                    _debug(`Failed to load ${filePath} ${e.message}`);
                }
                lastError = e;
            }
        }
        _log(`injecting env (${keysCount}) from ${shortPaths.join(',')}`);
    }
    if (lastError) {
        return {
            parsed: parsedAll,
            error: lastError
        };
    } else {
        return {
            parsed: parsedAll
        };
    }
}
// Populates process.env from .env file
function config(options) {
    // fallback to original dotenv if DOTENV_KEY is not set
    if (_dotenvKey(options).length === 0) {
        return DotenvModule.configDotenv(options);
    }
    const vaultPath = _vaultPath(options);
    // dotenvKey exists but .env.vault file does not exist
    if (!vaultPath) {
        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
        return DotenvModule.configDotenv(options);
    }
    return DotenvModule._configVault(options);
}
function decrypt(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), 'hex');
    let ciphertext = Buffer.from(encrypted, 'base64');
    const nonce = ciphertext.subarray(0, 12);
    const authTag = ciphertext.subarray(-16);
    ciphertext = ciphertext.subarray(12, -16);
    try {
        const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce);
        aesgcm.setAuthTag(authTag);
        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error) {
        const isRange = error instanceof RangeError;
        const invalidKeyLength = error.message === 'Invalid key length';
        const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data';
        if (isRange || invalidKeyLength) {
            const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)');
            err.code = 'INVALID_DOTENV_KEY';
            throw err;
        } else if (decryptionFailed) {
            const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY');
            err.code = 'DECRYPTION_FAILED';
            throw err;
        } else {
            throw error;
        }
    }
}
// Populate process.env with parsed values
function populate(processEnv, parsed, options = {}) {
    const debug = Boolean(options && options.debug);
    const override = Boolean(options && options.override);
    if (typeof parsed !== 'object') {
        const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate');
        err.code = 'OBJECT_REQUIRED';
        throw err;
    }
    // Set process.env
    for (const key of Object.keys(parsed)){
        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
            if (override === true) {
                processEnv[key] = parsed[key];
            }
            if (debug) {
                if (override === true) {
                    _debug(`"${key}" is already defined and WAS overwritten`);
                } else {
                    _debug(`"${key}" is already defined and was NOT overwritten`);
                }
            }
        } else {
            processEnv[key] = parsed[key];
        }
    }
}
const DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config,
    decrypt,
    parse,
    populate
};
module.exports.configDotenv = DotenvModule.configDotenv;
module.exports._configVault = DotenvModule._configVault;
module.exports._parseVault = DotenvModule._parseVault;
module.exports.config = DotenvModule.config;
module.exports.decrypt = DotenvModule.decrypt;
module.exports.parse = DotenvModule.parse;
module.exports.populate = DotenvModule.populate;
module.exports = DotenvModule;
}),
"[project]/align/node_modules/dotenv/lib/env-options.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// ../config.js accepts options via environment variables
const options = {};
if (process.env.DOTENV_CONFIG_ENCODING != null) {
    options.encoding = process.env.DOTENV_CONFIG_ENCODING;
}
if (process.env.DOTENV_CONFIG_PATH != null) {
    options.path = process.env.DOTENV_CONFIG_PATH;
}
if (process.env.DOTENV_CONFIG_QUIET != null) {
    options.quiet = process.env.DOTENV_CONFIG_QUIET;
}
if (process.env.DOTENV_CONFIG_DEBUG != null) {
    options.debug = process.env.DOTENV_CONFIG_DEBUG;
}
if (process.env.DOTENV_CONFIG_OVERRIDE != null) {
    options.override = process.env.DOTENV_CONFIG_OVERRIDE;
}
if (process.env.DOTENV_CONFIG_DOTENV_KEY != null) {
    options.DOTENV_KEY = process.env.DOTENV_CONFIG_DOTENV_KEY;
}
module.exports = options;
}),
"[project]/align/node_modules/dotenv/lib/cli-options.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const re = /^dotenv_config_(encoding|path|quiet|debug|override|DOTENV_KEY)=(.+)$/;
module.exports = function optionMatcher(args) {
    const options = args.reduce(function(acc, cur) {
        const matches = cur.match(re);
        if (matches) {
            acc[matches[1]] = matches[2];
        }
        return acc;
    }, {});
    if (!('quiet' in options)) {
        options.quiet = 'true';
    }
    return options;
};
}),
"[project]/align/node_modules/dotenv/config.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

(function() {
    __turbopack_context__.r("[project]/align/node_modules/dotenv/lib/main.js [app-route] (ecmascript)").config(Object.assign({}, __turbopack_context__.r("[project]/align/node_modules/dotenv/lib/env-options.js [app-route] (ecmascript)"), __turbopack_context__.r("[project]/align/node_modules/dotenv/lib/cli-options.js [app-route] (ecmascript)")(process.argv)));
})();
}),
"[project]/align/node_modules/uuid/dist/esm/rng.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>rng
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
;
const rnds8Pool = new Uint8Array(256);
let poolPtr = rnds8Pool.length;
function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
        (0, __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["randomFillSync"])(rnds8Pool);
        poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
}),
"[project]/align/node_modules/uuid/dist/esm/regex.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
const __TURBOPACK__default__export__ = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
}),
"[project]/align/node_modules/uuid/dist/esm/validate.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/uuid/dist/esm/regex.js [app-route] (ecmascript)");
;
function validate(uuid) {
    return typeof uuid === 'string' && __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].test(uuid);
}
const __TURBOPACK__default__export__ = validate;
}),
"[project]/align/node_modules/uuid/dist/esm/stringify.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "unsafeStringify",
    ()=>unsafeStringify
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$validate$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/uuid/dist/esm/validate.js [app-route] (ecmascript)");
;
const byteToHex = [];
for(let i = 0; i < 256; ++i){
    byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$validate$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(uuid)) {
        throw TypeError('Stringified UUID is invalid');
    }
    return uuid;
}
const __TURBOPACK__default__export__ = stringify;
}),
"[project]/align/node_modules/uuid/dist/esm/v7.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "updateV7State",
    ()=>updateV7State
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$rng$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/uuid/dist/esm/rng.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$stringify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/uuid/dist/esm/stringify.js [app-route] (ecmascript)");
;
;
const _state = {};
function v7(options, buf, offset) {
    let bytes;
    if (options) {
        bytes = v7Bytes(options.random ?? options.rng?.() ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$rng$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(), options.msecs, options.seq, buf, offset);
    } else {
        const now = Date.now();
        const rnds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$rng$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])();
        updateV7State(_state, now, rnds);
        bytes = v7Bytes(rnds, _state.msecs, _state.seq, buf, offset);
    }
    return buf ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$stringify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["unsafeStringify"])(bytes);
}
function updateV7State(state, now, rnds) {
    state.msecs ??= -Infinity;
    state.seq ??= 0;
    if (now > state.msecs) {
        state.seq = rnds[6] << 23 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
        state.msecs = now;
    } else {
        state.seq = state.seq + 1 | 0;
        if (state.seq === 0) {
            state.msecs++;
        }
    }
    return state;
}
function v7Bytes(rnds, msecs, seq, buf, offset = 0) {
    if (rnds.length < 16) {
        throw new Error('Random bytes length must be >= 16');
    }
    if (!buf) {
        buf = new Uint8Array(16);
        offset = 0;
    } else {
        if (offset < 0 || offset + 16 > buf.length) {
            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
        }
    }
    msecs ??= Date.now();
    seq ??= rnds[6] * 0x7f << 24 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
    buf[offset++] = msecs / 0x10000000000 & 0xff;
    buf[offset++] = msecs / 0x100000000 & 0xff;
    buf[offset++] = msecs / 0x1000000 & 0xff;
    buf[offset++] = msecs / 0x10000 & 0xff;
    buf[offset++] = msecs / 0x100 & 0xff;
    buf[offset++] = msecs & 0xff;
    buf[offset++] = 0x70 | seq >>> 28 & 0x0f;
    buf[offset++] = seq >>> 20 & 0xff;
    buf[offset++] = 0x80 | seq >>> 14 & 0x3f;
    buf[offset++] = seq >>> 6 & 0xff;
    buf[offset++] = seq << 2 & 0xff | rnds[10] & 0x03;
    buf[offset++] = rnds[11];
    buf[offset++] = rnds[12];
    buf[offset++] = rnds[13];
    buf[offset++] = rnds[14];
    buf[offset++] = rnds[15];
    return buf;
}
const __TURBOPACK__default__export__ = v7;
}),
"[project]/align/node_modules/uuid/dist/esm/v7.js [app-route] (ecmascript) <export default as v7>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "v7",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$v7$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$v7$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/uuid/dist/esm/v7.js [app-route] (ecmascript)");
}),
"[project]/align/node_modules/fast-json-stable-stringify/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function(data, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = {
        cmp: opts
    };
    var cycles = typeof opts.cycles === 'boolean' ? opts.cycles : false;
    var cmp = opts.cmp && function(f) {
        return function(node) {
            return function(a, b) {
                var aobj = {
                    key: a,
                    value: node[a]
                };
                var bobj = {
                    key: b,
                    value: node[b]
                };
                return f(aobj, bobj);
            };
        };
    }(opts.cmp);
    var seen = [];
    return function stringify(node) {
        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }
        if (node === undefined) return;
        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
            out = '[';
            for(i = 0; i < node.length; i++){
                if (i) out += ',';
                out += stringify(node[i]) || 'null';
            }
            return out + ']';
        }
        if (node === null) return 'null';
        if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify('__cycle__');
            throw new TypeError('Converting circular structure to JSON');
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = '';
        for(i = 0; i < keys.length; i++){
            var key = keys[i];
            var value = stringify(node[key]);
            if (!value) continue;
            if (out) out += ',';
            out += JSON.stringify(key) + ':' + value;
        }
        seen.splice(seenIndex, 1);
        return '{' + out + '}';
    }(data);
};
}),
"[project]/align/node_modules/xxhash-wasm/esm/xxhash-wasm.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>e
]);
const t = new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    48,
    8,
    96,
    3,
    127,
    127,
    127,
    1,
    127,
    96,
    3,
    127,
    127,
    127,
    0,
    96,
    2,
    127,
    127,
    0,
    96,
    1,
    127,
    1,
    127,
    96,
    3,
    127,
    127,
    126,
    1,
    126,
    96,
    3,
    126,
    127,
    127,
    1,
    126,
    96,
    2,
    127,
    126,
    0,
    96,
    1,
    127,
    1,
    126,
    3,
    11,
    10,
    0,
    0,
    2,
    1,
    3,
    4,
    5,
    6,
    1,
    7,
    5,
    3,
    1,
    0,
    1,
    7,
    85,
    9,
    3,
    109,
    101,
    109,
    2,
    0,
    5,
    120,
    120,
    104,
    51,
    50,
    0,
    0,
    6,
    105,
    110,
    105,
    116,
    51,
    50,
    0,
    2,
    8,
    117,
    112,
    100,
    97,
    116,
    101,
    51,
    50,
    0,
    3,
    8,
    100,
    105,
    103,
    101,
    115,
    116,
    51,
    50,
    0,
    4,
    5,
    120,
    120,
    104,
    54,
    52,
    0,
    5,
    6,
    105,
    110,
    105,
    116,
    54,
    52,
    0,
    7,
    8,
    117,
    112,
    100,
    97,
    116,
    101,
    54,
    52,
    0,
    8,
    8,
    100,
    105,
    103,
    101,
    115,
    116,
    54,
    52,
    0,
    9,
    10,
    251,
    22,
    10,
    242,
    1,
    1,
    4,
    127,
    32,
    0,
    32,
    1,
    106,
    33,
    3,
    32,
    1,
    65,
    16,
    79,
    4,
    127,
    32,
    3,
    65,
    16,
    107,
    33,
    6,
    32,
    2,
    65,
    168,
    136,
    141,
    161,
    2,
    106,
    33,
    3,
    32,
    2,
    65,
    137,
    235,
    208,
    208,
    7,
    107,
    33,
    4,
    32,
    2,
    65,
    207,
    140,
    162,
    142,
    6,
    106,
    33,
    5,
    3,
    64,
    32,
    3,
    32,
    0,
    40,
    2,
    0,
    65,
    247,
    148,
    175,
    175,
    120,
    108,
    106,
    65,
    13,
    119,
    65,
    177,
    243,
    221,
    241,
    121,
    108,
    33,
    3,
    32,
    4,
    32,
    0,
    65,
    4,
    106,
    34,
    0,
    40,
    2,
    0,
    65,
    247,
    148,
    175,
    175,
    120,
    108,
    106,
    65,
    13,
    119,
    65,
    177,
    243,
    221,
    241,
    121,
    108,
    33,
    4,
    32,
    2,
    32,
    0,
    65,
    4,
    106,
    34,
    0,
    40,
    2,
    0,
    65,
    247,
    148,
    175,
    175,
    120,
    108,
    106,
    65,
    13,
    119,
    65,
    177,
    243,
    221,
    241,
    121,
    108,
    33,
    2,
    32,
    5,
    32,
    0,
    65,
    4,
    106,
    34,
    0,
    40,
    2,
    0,
    65,
    247,
    148,
    175,
    175,
    120,
    108,
    106,
    65,
    13,
    119,
    65,
    177,
    243,
    221,
    241,
    121,
    108,
    33,
    5,
    32,
    6,
    32,
    0,
    65,
    4,
    106,
    34,
    0,
    79,
    13,
    0,
    11,
    32,
    2,
    65,
    12,
    119,
    32,
    5,
    65,
    18,
    119,
    106,
    32,
    4,
    65,
    7,
    119,
    106,
    32,
    3,
    65,
    1,
    119,
    106,
    5,
    32,
    2,
    65,
    177,
    207,
    217,
    178,
    1,
    106,
    11,
    32,
    1,
    106,
    32,
    0,
    32,
    1,
    65,
    15,
    113,
    16,
    1,
    11,
    146,
    1,
    0,
    32,
    1,
    32,
    2,
    106,
    33,
    2,
    3,
    64,
    32,
    1,
    65,
    4,
    106,
    32,
    2,
    75,
    69,
    4,
    64,
    32,
    0,
    32,
    1,
    40,
    2,
    0,
    65,
    189,
    220,
    202,
    149,
    124,
    108,
    106,
    65,
    17,
    119,
    65,
    175,
    214,
    211,
    190,
    2,
    108,
    33,
    0,
    32,
    1,
    65,
    4,
    106,
    33,
    1,
    12,
    1,
    11,
    11,
    3,
    64,
    32,
    1,
    32,
    2,
    79,
    69,
    4,
    64,
    32,
    0,
    32,
    1,
    45,
    0,
    0,
    65,
    177,
    207,
    217,
    178,
    1,
    108,
    106,
    65,
    11,
    119,
    65,
    177,
    243,
    221,
    241,
    121,
    108,
    33,
    0,
    32,
    1,
    65,
    1,
    106,
    33,
    1,
    12,
    1,
    11,
    11,
    32,
    0,
    32,
    0,
    65,
    15,
    118,
    115,
    65,
    247,
    148,
    175,
    175,
    120,
    108,
    34,
    0,
    65,
    13,
    118,
    32,
    0,
    115,
    65,
    189,
    220,
    202,
    149,
    124,
    108,
    34,
    0,
    65,
    16,
    118,
    32,
    0,
    115,
    11,
    63,
    0,
    32,
    0,
    65,
    8,
    106,
    32,
    1,
    65,
    168,
    136,
    141,
    161,
    2,
    106,
    54,
    2,
    0,
    32,
    0,
    65,
    12,
    106,
    32,
    1,
    65,
    137,
    235,
    208,
    208,
    7,
    107,
    54,
    2,
    0,
    32,
    0,
    65,
    16,
    106,
    32,
    1,
    54,
    2,
    0,
    32,
    0,
    65,
    20,
    106,
    32,
    1,
    65,
    207,
    140,
    162,
    142,
    6,
    106,
    54,
    2,
    0,
    11,
    195,
    4,
    1,
    6,
    127,
    32,
    1,
    32,
    2,
    106,
    33,
    6,
    32,
    0,
    65,
    24,
    106,
    33,
    4,
    32,
    0,
    65,
    40,
    106,
    40,
    2,
    0,
    33,
    3,
    32,
    0,
    32,
    0,
    40,
    2,
    0,
    32,
    2,
    106,
    54,
    2,
    0,
    32,
    0,
    65,
    4,
    106,
    34,
    5,
    32,
    5,
    40,
    2,
    0,
    32,
    2,
    65,
    16,
    79,
    32,
    0,
    40,
    2,
    0,
    65,
    16,
    79,
    114,
    114,
    54,
    2,
    0,
    32,
    2,
    32,
    3,
    106,
    65,
    16,
    73,
    4,
    64,
    32,
    3,
    32,
    4,
    106,
    32,
    1,
    32,
    2,
    252,
    10,
    0,
    0,
    32,
    0,
    65,
    40,
    106,
    32,
    2,
    32,
    3,
    106,
    54,
    2,
    0,
    15,
    11,
    32,
    3,
    4,
    64,
    32,
    3,
    32,
    4,
    106,
    32,
    1,
    65,
    16,
    32,
    3,
    107,
    34,
    2,
    252,
    10,
    0,
    0,
    32,
    0,
    65,
    8,
    106,
    34,
    3,
    32,
    3,
    40,
    2,
    0,
    32,
    4,
    40,
    2,
    0,
    65,
    247,
    148,
    175,
    175,
    120,
    108,
    106,
    65,
    13,
    119,
    65,
    177,
    243,
    221,
    241,
    121,
    108,
    54,
    2,
    0,
    32,
    0,
    65,
    12,
    106,
    34,
    3,
    32,
    3,
    40,
    2,
    0,
    32,
    4,
    65,
    4,
    106,
    40,
    2,
    0,
    65,
    247,
    148,
    175,
    175,
    120,
    108,
    106,
    65,
    13,
    119,
    65,
    177,
    243,
    221,
    241,
    121,
    108,
    54,
    2,
    0,
    32,
    0,
    65,
    16,
    106,
    34,
    3,
    32,
    3,
    40,
    2,
    0,
    32,
    4,
    65,
    8,
    106,
    40,
    2,
    0,
    65,
    247,
    148,
    175,
    175,
    120,
    108,
    106,
    65,
    13,
    119,
    65,
    177,
    243,
    221,
    241,
    121,
    108,
    54,
    2,
    0,
    32,
    0,
    65,
    20,
    106,
    34,
    3,
    32,
    3,
    40,
    2,
    0,
    32,
    4,
    65,
    12,
    106,
    40,
    2,
    0,
    65,
    247,
    148,
    175,
    175,
    120,
    108,
    106,
    65,
    13,
    119,
    65,
    177,
    243,
    221,
    241,
    121,
    108,
    54,
    2,
    0,
    32,
    0,
    65,
    40,
    106,
    65,
    0,
    54,
    2,
    0,
    32,
    1,
    32,
    2,
    106,
    33,
    1,
    11,
    32,
    1,
    32,
    6,
    65,
    16,
    107,
    77,
    4,
    64,
    32,
    6,
    65,
    16,
    107,
    33,
    8,
    32,
    0,
    65,
    8,
    106,
    40,
    2,
    0,
    33,
    2,
    32,
    0,
    65,
    12,
    106,
    40,
    2,
    0,
    33,
    3,
    32,
    0,
    65,
    16,
    106,
    40,
    2,
    0,
    33,
    5,
    32,
    0,
    65,
    20,
    106,
    40,
    2,
    0,
    33,
    7,
    3,
    64,
    32,
    2,
    32,
    1,
    40,
    2,
    0,
    65,
    247,
    148,
    175,
    175,
    120,
    108,
    106,
    65,
    13,
    119,
    65,
    177,
    243,
    221,
    241,
    121,
    108,
    33,
    2,
    32,
    3,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    40,
    2,
    0,
    65,
    247,
    148,
    175,
    175,
    120,
    108,
    106,
    65,
    13,
    119,
    65,
    177,
    243,
    221,
    241,
    121,
    108,
    33,
    3,
    32,
    5,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    40,
    2,
    0,
    65,
    247,
    148,
    175,
    175,
    120,
    108,
    106,
    65,
    13,
    119,
    65,
    177,
    243,
    221,
    241,
    121,
    108,
    33,
    5,
    32,
    7,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    40,
    2,
    0,
    65,
    247,
    148,
    175,
    175,
    120,
    108,
    106,
    65,
    13,
    119,
    65,
    177,
    243,
    221,
    241,
    121,
    108,
    33,
    7,
    32,
    8,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    79,
    13,
    0,
    11,
    32,
    0,
    65,
    8,
    106,
    32,
    2,
    54,
    2,
    0,
    32,
    0,
    65,
    12,
    106,
    32,
    3,
    54,
    2,
    0,
    32,
    0,
    65,
    16,
    106,
    32,
    5,
    54,
    2,
    0,
    32,
    0,
    65,
    20,
    106,
    32,
    7,
    54,
    2,
    0,
    11,
    32,
    1,
    32,
    6,
    73,
    4,
    64,
    32,
    4,
    32,
    1,
    32,
    6,
    32,
    1,
    107,
    34,
    1,
    252,
    10,
    0,
    0,
    32,
    0,
    65,
    40,
    106,
    32,
    1,
    54,
    2,
    0,
    11,
    11,
    97,
    1,
    1,
    127,
    32,
    0,
    65,
    16,
    106,
    40,
    2,
    0,
    33,
    1,
    32,
    0,
    65,
    4,
    106,
    40,
    2,
    0,
    4,
    127,
    32,
    1,
    65,
    12,
    119,
    32,
    0,
    65,
    20,
    106,
    40,
    2,
    0,
    65,
    18,
    119,
    106,
    32,
    0,
    65,
    12,
    106,
    40,
    2,
    0,
    65,
    7,
    119,
    106,
    32,
    0,
    65,
    8,
    106,
    40,
    2,
    0,
    65,
    1,
    119,
    106,
    5,
    32,
    1,
    65,
    177,
    207,
    217,
    178,
    1,
    106,
    11,
    32,
    0,
    40,
    2,
    0,
    106,
    32,
    0,
    65,
    24,
    106,
    32,
    0,
    65,
    40,
    106,
    40,
    2,
    0,
    16,
    1,
    11,
    255,
    3,
    2,
    3,
    126,
    1,
    127,
    32,
    0,
    32,
    1,
    106,
    33,
    6,
    32,
    1,
    65,
    32,
    79,
    4,
    126,
    32,
    6,
    65,
    32,
    107,
    33,
    6,
    32,
    2,
    66,
    214,
    235,
    130,
    238,
    234,
    253,
    137,
    245,
    224,
    0,
    124,
    33,
    3,
    32,
    2,
    66,
    177,
    169,
    172,
    193,
    173,
    184,
    212,
    166,
    61,
    125,
    33,
    4,
    32,
    2,
    66,
    249,
    234,
    208,
    208,
    231,
    201,
    161,
    228,
    225,
    0,
    124,
    33,
    5,
    3,
    64,
    32,
    3,
    32,
    0,
    41,
    3,
    0,
    66,
    207,
    214,
    211,
    190,
    210,
    199,
    171,
    217,
    66,
    126,
    124,
    66,
    31,
    137,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    33,
    3,
    32,
    4,
    32,
    0,
    65,
    8,
    106,
    34,
    0,
    41,
    3,
    0,
    66,
    207,
    214,
    211,
    190,
    210,
    199,
    171,
    217,
    66,
    126,
    124,
    66,
    31,
    137,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    33,
    4,
    32,
    2,
    32,
    0,
    65,
    8,
    106,
    34,
    0,
    41,
    3,
    0,
    66,
    207,
    214,
    211,
    190,
    210,
    199,
    171,
    217,
    66,
    126,
    124,
    66,
    31,
    137,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    33,
    2,
    32,
    5,
    32,
    0,
    65,
    8,
    106,
    34,
    0,
    41,
    3,
    0,
    66,
    207,
    214,
    211,
    190,
    210,
    199,
    171,
    217,
    66,
    126,
    124,
    66,
    31,
    137,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    33,
    5,
    32,
    6,
    32,
    0,
    65,
    8,
    106,
    34,
    0,
    79,
    13,
    0,
    11,
    32,
    2,
    66,
    12,
    137,
    32,
    5,
    66,
    18,
    137,
    124,
    32,
    4,
    66,
    7,
    137,
    124,
    32,
    3,
    66,
    1,
    137,
    124,
    32,
    3,
    66,
    207,
    214,
    211,
    190,
    210,
    199,
    171,
    217,
    66,
    126,
    66,
    31,
    137,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    133,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    66,
    157,
    163,
    181,
    234,
    131,
    177,
    141,
    138,
    250,
    0,
    125,
    32,
    4,
    66,
    207,
    214,
    211,
    190,
    210,
    199,
    171,
    217,
    66,
    126,
    66,
    31,
    137,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    133,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    66,
    157,
    163,
    181,
    234,
    131,
    177,
    141,
    138,
    250,
    0,
    125,
    32,
    2,
    66,
    207,
    214,
    211,
    190,
    210,
    199,
    171,
    217,
    66,
    126,
    66,
    31,
    137,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    133,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    66,
    157,
    163,
    181,
    234,
    131,
    177,
    141,
    138,
    250,
    0,
    125,
    32,
    5,
    66,
    207,
    214,
    211,
    190,
    210,
    199,
    171,
    217,
    66,
    126,
    66,
    31,
    137,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    133,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    66,
    157,
    163,
    181,
    234,
    131,
    177,
    141,
    138,
    250,
    0,
    125,
    5,
    32,
    2,
    66,
    197,
    207,
    217,
    178,
    241,
    229,
    186,
    234,
    39,
    124,
    11,
    32,
    1,
    173,
    124,
    32,
    0,
    32,
    1,
    65,
    31,
    113,
    16,
    6,
    11,
    134,
    2,
    0,
    32,
    1,
    32,
    2,
    106,
    33,
    2,
    3,
    64,
    32,
    2,
    32,
    1,
    65,
    8,
    106,
    79,
    4,
    64,
    32,
    1,
    41,
    3,
    0,
    66,
    207,
    214,
    211,
    190,
    210,
    199,
    171,
    217,
    66,
    126,
    66,
    31,
    137,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    32,
    0,
    133,
    66,
    27,
    137,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    66,
    157,
    163,
    181,
    234,
    131,
    177,
    141,
    138,
    250,
    0,
    125,
    33,
    0,
    32,
    1,
    65,
    8,
    106,
    33,
    1,
    12,
    1,
    11,
    11,
    32,
    1,
    65,
    4,
    106,
    32,
    2,
    77,
    4,
    64,
    32,
    0,
    32,
    1,
    53,
    2,
    0,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    133,
    66,
    23,
    137,
    66,
    207,
    214,
    211,
    190,
    210,
    199,
    171,
    217,
    66,
    126,
    66,
    249,
    243,
    221,
    241,
    153,
    246,
    153,
    171,
    22,
    124,
    33,
    0,
    32,
    1,
    65,
    4,
    106,
    33,
    1,
    11,
    3,
    64,
    32,
    1,
    32,
    2,
    73,
    4,
    64,
    32,
    0,
    32,
    1,
    49,
    0,
    0,
    66,
    197,
    207,
    217,
    178,
    241,
    229,
    186,
    234,
    39,
    126,
    133,
    66,
    11,
    137,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    33,
    0,
    32,
    1,
    65,
    1,
    106,
    33,
    1,
    12,
    1,
    11,
    11,
    32,
    0,
    32,
    0,
    66,
    33,
    136,
    133,
    66,
    207,
    214,
    211,
    190,
    210,
    199,
    171,
    217,
    66,
    126,
    34,
    0,
    32,
    0,
    66,
    29,
    136,
    133,
    66,
    249,
    243,
    221,
    241,
    153,
    246,
    153,
    171,
    22,
    126,
    34,
    0,
    32,
    0,
    66,
    32,
    136,
    133,
    11,
    77,
    0,
    32,
    0,
    65,
    8,
    106,
    32,
    1,
    66,
    214,
    235,
    130,
    238,
    234,
    253,
    137,
    245,
    224,
    0,
    124,
    55,
    3,
    0,
    32,
    0,
    65,
    16,
    106,
    32,
    1,
    66,
    177,
    169,
    172,
    193,
    173,
    184,
    212,
    166,
    61,
    125,
    55,
    3,
    0,
    32,
    0,
    65,
    24,
    106,
    32,
    1,
    55,
    3,
    0,
    32,
    0,
    65,
    32,
    106,
    32,
    1,
    66,
    249,
    234,
    208,
    208,
    231,
    201,
    161,
    228,
    225,
    0,
    124,
    55,
    3,
    0,
    11,
    244,
    4,
    2,
    3,
    127,
    4,
    126,
    32,
    1,
    32,
    2,
    106,
    33,
    5,
    32,
    0,
    65,
    40,
    106,
    33,
    4,
    32,
    0,
    65,
    200,
    0,
    106,
    40,
    2,
    0,
    33,
    3,
    32,
    0,
    32,
    0,
    41,
    3,
    0,
    32,
    2,
    173,
    124,
    55,
    3,
    0,
    32,
    2,
    32,
    3,
    106,
    65,
    32,
    73,
    4,
    64,
    32,
    3,
    32,
    4,
    106,
    32,
    1,
    32,
    2,
    252,
    10,
    0,
    0,
    32,
    0,
    65,
    200,
    0,
    106,
    32,
    2,
    32,
    3,
    106,
    54,
    2,
    0,
    15,
    11,
    32,
    3,
    4,
    64,
    32,
    3,
    32,
    4,
    106,
    32,
    1,
    65,
    32,
    32,
    3,
    107,
    34,
    2,
    252,
    10,
    0,
    0,
    32,
    0,
    65,
    8,
    106,
    34,
    3,
    32,
    3,
    41,
    3,
    0,
    32,
    4,
    41,
    3,
    0,
    66,
    207,
    214,
    211,
    190,
    210,
    199,
    171,
    217,
    66,
    126,
    124,
    66,
    31,
    137,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    55,
    3,
    0,
    32,
    0,
    65,
    16,
    106,
    34,
    3,
    32,
    3,
    41,
    3,
    0,
    32,
    4,
    65,
    8,
    106,
    41,
    3,
    0,
    66,
    207,
    214,
    211,
    190,
    210,
    199,
    171,
    217,
    66,
    126,
    124,
    66,
    31,
    137,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    55,
    3,
    0,
    32,
    0,
    65,
    24,
    106,
    34,
    3,
    32,
    3,
    41,
    3,
    0,
    32,
    4,
    65,
    16,
    106,
    41,
    3,
    0,
    66,
    207,
    214,
    211,
    190,
    210,
    199,
    171,
    217,
    66,
    126,
    124,
    66,
    31,
    137,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    55,
    3,
    0,
    32,
    0,
    65,
    32,
    106,
    34,
    3,
    32,
    3,
    41,
    3,
    0,
    32,
    4,
    65,
    24,
    106,
    41,
    3,
    0,
    66,
    207,
    214,
    211,
    190,
    210,
    199,
    171,
    217,
    66,
    126,
    124,
    66,
    31,
    137,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    55,
    3,
    0,
    32,
    0,
    65,
    200,
    0,
    106,
    65,
    0,
    54,
    2,
    0,
    32,
    1,
    32,
    2,
    106,
    33,
    1,
    11,
    32,
    1,
    65,
    32,
    106,
    32,
    5,
    77,
    4,
    64,
    32,
    5,
    65,
    32,
    107,
    33,
    2,
    32,
    0,
    65,
    8,
    106,
    41,
    3,
    0,
    33,
    6,
    32,
    0,
    65,
    16,
    106,
    41,
    3,
    0,
    33,
    7,
    32,
    0,
    65,
    24,
    106,
    41,
    3,
    0,
    33,
    8,
    32,
    0,
    65,
    32,
    106,
    41,
    3,
    0,
    33,
    9,
    3,
    64,
    32,
    6,
    32,
    1,
    41,
    3,
    0,
    66,
    207,
    214,
    211,
    190,
    210,
    199,
    171,
    217,
    66,
    126,
    124,
    66,
    31,
    137,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    33,
    6,
    32,
    7,
    32,
    1,
    65,
    8,
    106,
    34,
    1,
    41,
    3,
    0,
    66,
    207,
    214,
    211,
    190,
    210,
    199,
    171,
    217,
    66,
    126,
    124,
    66,
    31,
    137,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    33,
    7,
    32,
    8,
    32,
    1,
    65,
    8,
    106,
    34,
    1,
    41,
    3,
    0,
    66,
    207,
    214,
    211,
    190,
    210,
    199,
    171,
    217,
    66,
    126,
    124,
    66,
    31,
    137,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    33,
    8,
    32,
    9,
    32,
    1,
    65,
    8,
    106,
    34,
    1,
    41,
    3,
    0,
    66,
    207,
    214,
    211,
    190,
    210,
    199,
    171,
    217,
    66,
    126,
    124,
    66,
    31,
    137,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    33,
    9,
    32,
    2,
    32,
    1,
    65,
    8,
    106,
    34,
    1,
    79,
    13,
    0,
    11,
    32,
    0,
    65,
    8,
    106,
    32,
    6,
    55,
    3,
    0,
    32,
    0,
    65,
    16,
    106,
    32,
    7,
    55,
    3,
    0,
    32,
    0,
    65,
    24,
    106,
    32,
    8,
    55,
    3,
    0,
    32,
    0,
    65,
    32,
    106,
    32,
    9,
    55,
    3,
    0,
    11,
    32,
    1,
    32,
    5,
    73,
    4,
    64,
    32,
    4,
    32,
    1,
    32,
    5,
    32,
    1,
    107,
    34,
    1,
    252,
    10,
    0,
    0,
    32,
    0,
    65,
    200,
    0,
    106,
    32,
    1,
    54,
    2,
    0,
    11,
    11,
    188,
    2,
    1,
    5,
    126,
    32,
    0,
    65,
    24,
    106,
    41,
    3,
    0,
    33,
    1,
    32,
    0,
    41,
    3,
    0,
    34,
    2,
    66,
    32,
    90,
    4,
    126,
    32,
    0,
    65,
    8,
    106,
    41,
    3,
    0,
    34,
    3,
    66,
    1,
    137,
    32,
    0,
    65,
    16,
    106,
    41,
    3,
    0,
    34,
    4,
    66,
    7,
    137,
    124,
    32,
    1,
    66,
    12,
    137,
    32,
    0,
    65,
    32,
    106,
    41,
    3,
    0,
    34,
    5,
    66,
    18,
    137,
    124,
    124,
    32,
    3,
    66,
    207,
    214,
    211,
    190,
    210,
    199,
    171,
    217,
    66,
    126,
    66,
    31,
    137,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    133,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    66,
    157,
    163,
    181,
    234,
    131,
    177,
    141,
    138,
    250,
    0,
    125,
    32,
    4,
    66,
    207,
    214,
    211,
    190,
    210,
    199,
    171,
    217,
    66,
    126,
    66,
    31,
    137,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    133,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    66,
    157,
    163,
    181,
    234,
    131,
    177,
    141,
    138,
    250,
    0,
    125,
    32,
    1,
    66,
    207,
    214,
    211,
    190,
    210,
    199,
    171,
    217,
    66,
    126,
    66,
    31,
    137,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    133,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    66,
    157,
    163,
    181,
    234,
    131,
    177,
    141,
    138,
    250,
    0,
    125,
    32,
    5,
    66,
    207,
    214,
    211,
    190,
    210,
    199,
    171,
    217,
    66,
    126,
    66,
    31,
    137,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    133,
    66,
    135,
    149,
    175,
    175,
    152,
    182,
    222,
    155,
    158,
    127,
    126,
    66,
    157,
    163,
    181,
    234,
    131,
    177,
    141,
    138,
    250,
    0,
    125,
    5,
    32,
    1,
    66,
    197,
    207,
    217,
    178,
    241,
    229,
    186,
    234,
    39,
    124,
    11,
    32,
    2,
    124,
    32,
    0,
    65,
    40,
    106,
    32,
    2,
    66,
    31,
    131,
    167,
    16,
    6,
    11
]);
async function e() {
    return function(t) {
        const { exports: { mem: e, xxh32: n, xxh64: r, init32: i, update32: a, digest32: o, init64: s, update64: u, digest64: c } } = t;
        let h = new Uint8Array(e.buffer);
        function g(t, n) {
            if (e.buffer.byteLength < t + n) {
                const r = Math.ceil((t + n - e.buffer.byteLength) / 65536);
                e.grow(r), h = new Uint8Array(e.buffer);
            }
        }
        function f(t, e, n, r, i, a) {
            g(t);
            const o = new Uint8Array(t);
            return h.set(o), n(0, e), o.set(h.subarray(0, t)), {
                update (e) {
                    let n;
                    return h.set(o), "string" == typeof e ? (g(3 * e.length, t), n = w.encodeInto(e, h.subarray(t)).written) : (g(e.byteLength, t), h.set(e, t), n = e.byteLength), r(0, t, n), o.set(h.subarray(0, t)), this;
                },
                digest: ()=>(h.set(o), a(i(0)))
            };
        }
        function y(t) {
            return t >>> 0;
        }
        const b = 2n ** 64n - 1n;
        function d(t) {
            return t & b;
        }
        const w = new TextEncoder, l = 0, p = 0n;
        function x(t, e = l) {
            return g(3 * t.length, 0), y(n(0, w.encodeInto(t, h).written, e));
        }
        function L(t, e = p) {
            return g(3 * t.length, 0), d(r(0, w.encodeInto(t, h).written, e));
        }
        return {
            h32: x,
            h32ToString: (t, e = l)=>x(t, e).toString(16).padStart(8, "0"),
            h32Raw: (t, e = l)=>(g(t.byteLength, 0), h.set(t), y(n(0, t.byteLength, e))),
            create32: (t = l)=>f(48, t, i, a, o, y),
            h64: L,
            h64ToString: (t, e = p)=>L(t, e).toString(16).padStart(16, "0"),
            h64Raw: (t, e = p)=>(g(t.byteLength, 0), h.set(t), d(r(0, t.byteLength, e))),
            create64: (t = p)=>f(88, t, s, u, c, d)
        };
    }((await WebAssembly.instantiate(t)).instance);
}
;
 //# sourceMappingURL=xxhash-wasm.js.map
}),
"[project]/align/node_modules/mustache/mustache.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */ var objectToString = Object.prototype.toString;
var isArray = Array.isArray || function isArrayPolyfill(object) {
    return objectToString.call(object) === '[object Array]';
};
function isFunction(object) {
    return typeof object === 'function';
}
/**
 * More correct typeof string handling array
 * which normally returns typeof 'object'
 */ function typeStr(obj) {
    return isArray(obj) ? 'array' : typeof obj;
}
function escapeRegExp(string) {
    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
}
/**
 * Null safe way of checking whether or not an object,
 * including its prototype, has a given property
 */ function hasProperty(obj, propName) {
    return obj != null && typeof obj === 'object' && propName in obj;
}
/**
 * Safe way of detecting whether or not the given thing is a primitive and
 * whether it has the given property
 */ function primitiveHasOwnProperty(primitive, propName) {
    return primitive != null && typeof primitive !== 'object' && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);
}
// Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
// See https://github.com/janl/mustache.js/issues/189
var regExpTest = RegExp.prototype.test;
function testRegExp(re, string) {
    return regExpTest.call(re, string);
}
var nonSpaceRe = /\S/;
function isWhitespace(string) {
    return !testRegExp(nonSpaceRe, string);
}
var entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;',
    '`': '&#x60;',
    '=': '&#x3D;'
};
function escapeHtml(string) {
    return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
        return entityMap[s];
    });
}
var whiteRe = /\s*/;
var spaceRe = /\s+/;
var equalsRe = /\s*=/;
var curlyRe = /\s*\}/;
var tagRe = /#|\^|\/|>|\{|&|=|!/;
/**
 * Breaks up the given `template` string into a tree of tokens. If the `tags`
 * argument is given here it must be an array with two string values: the
 * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
 * course, the default is to use mustaches (i.e. mustache.tags).
 *
 * A token is an array with at least 4 elements. The first element is the
 * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
 * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
 * all text that appears outside a symbol this element is "text".
 *
 * The second element of a token is its "value". For mustache tags this is
 * whatever else was inside the tag besides the opening symbol. For text tokens
 * this is the text itself.
 *
 * The third and fourth elements of the token are the start and end indices,
 * respectively, of the token in the original template.
 *
 * Tokens that are the root node of a subtree contain two more elements: 1) an
 * array of tokens in the subtree and 2) the index in the original template at
 * which the closing tag for that section begins.
 *
 * Tokens for partials also contain two more elements: 1) a string value of
 * indendation prior to that tag and 2) the index of that tag on that line -
 * eg a value of 2 indicates the partial is the third tag on this line.
 */ function parseTemplate(template, tags) {
    if (!template) return [];
    var lineHasNonSpace = false;
    var sections = []; // Stack to hold section tokens
    var tokens = []; // Buffer to hold the tokens
    var spaces = []; // Indices of whitespace tokens on the current line
    var hasTag = false; // Is there a {{tag}} on the current line?
    var nonSpace = false; // Is there a non-space char on the current line?
    var indentation = ''; // Tracks indentation for tags that use it
    var tagIndex = 0; // Stores a count of number of tags encountered on a line
    // Strips all whitespace tokens array for the current line
    // if there was a {{#tag}} on it and otherwise only space.
    function stripSpace() {
        if (hasTag && !nonSpace) {
            while(spaces.length)delete tokens[spaces.pop()];
        } else {
            spaces = [];
        }
        hasTag = false;
        nonSpace = false;
    }
    var openingTagRe, closingTagRe, closingCurlyRe;
    function compileTags(tagsToCompile) {
        if (typeof tagsToCompile === 'string') tagsToCompile = tagsToCompile.split(spaceRe, 2);
        if (!isArray(tagsToCompile) || tagsToCompile.length !== 2) throw new Error('Invalid tags: ' + tagsToCompile);
        openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\s*');
        closingTagRe = new RegExp('\\s*' + escapeRegExp(tagsToCompile[1]));
        closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tagsToCompile[1]));
    }
    compileTags(tags || mustache.tags);
    var scanner = new Scanner(template);
    var start, type, value, chr, token, openSection;
    while(!scanner.eos()){
        start = scanner.pos;
        // Match any text between tags.
        value = scanner.scanUntil(openingTagRe);
        if (value) {
            for(var i = 0, valueLength = value.length; i < valueLength; ++i){
                chr = value.charAt(i);
                if (isWhitespace(chr)) {
                    spaces.push(tokens.length);
                    indentation += chr;
                } else {
                    nonSpace = true;
                    lineHasNonSpace = true;
                    indentation += ' ';
                }
                tokens.push([
                    'text',
                    chr,
                    start,
                    start + 1
                ]);
                start += 1;
                // Check for whitespace on the current line.
                if (chr === '\n') {
                    stripSpace();
                    indentation = '';
                    tagIndex = 0;
                    lineHasNonSpace = false;
                }
            }
        }
        // Match the opening tag.
        if (!scanner.scan(openingTagRe)) break;
        hasTag = true;
        // Get the tag type.
        type = scanner.scan(tagRe) || 'name';
        scanner.scan(whiteRe);
        // Get the tag value.
        if (type === '=') {
            value = scanner.scanUntil(equalsRe);
            scanner.scan(equalsRe);
            scanner.scanUntil(closingTagRe);
        } else if (type === '{') {
            value = scanner.scanUntil(closingCurlyRe);
            scanner.scan(curlyRe);
            scanner.scanUntil(closingTagRe);
            type = '&';
        } else {
            value = scanner.scanUntil(closingTagRe);
        }
        // Match the closing tag.
        if (!scanner.scan(closingTagRe)) throw new Error('Unclosed tag at ' + scanner.pos);
        if (type == '>') {
            token = [
                type,
                value,
                start,
                scanner.pos,
                indentation,
                tagIndex,
                lineHasNonSpace
            ];
        } else {
            token = [
                type,
                value,
                start,
                scanner.pos
            ];
        }
        tagIndex++;
        tokens.push(token);
        if (type === '#' || type === '^') {
            sections.push(token);
        } else if (type === '/') {
            // Check section nesting.
            openSection = sections.pop();
            if (!openSection) throw new Error('Unopened section "' + value + '" at ' + start);
            if (openSection[1] !== value) throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
        } else if (type === 'name' || type === '{' || type === '&') {
            nonSpace = true;
        } else if (type === '=') {
            // Set the tags for the next time around.
            compileTags(value);
        }
    }
    stripSpace();
    // Make sure there are no open sections when we're done.
    openSection = sections.pop();
    if (openSection) throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
    return nestTokens(squashTokens(tokens));
}
/**
 * Combines the values of consecutive text tokens in the given `tokens` array
 * to a single token.
 */ function squashTokens(tokens) {
    var squashedTokens = [];
    var token, lastToken;
    for(var i = 0, numTokens = tokens.length; i < numTokens; ++i){
        token = tokens[i];
        if (token) {
            if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
                lastToken[1] += token[1];
                lastToken[3] = token[3];
            } else {
                squashedTokens.push(token);
                lastToken = token;
            }
        }
    }
    return squashedTokens;
}
/**
 * Forms the given array of `tokens` into a nested tree structure where
 * tokens that represent a section have two additional items: 1) an array of
 * all tokens that appear in that section and 2) the index in the original
 * template that represents the end of that section.
 */ function nestTokens(tokens) {
    var nestedTokens = [];
    var collector = nestedTokens;
    var sections = [];
    var token, section;
    for(var i = 0, numTokens = tokens.length; i < numTokens; ++i){
        token = tokens[i];
        switch(token[0]){
            case '#':
            case '^':
                collector.push(token);
                sections.push(token);
                collector = token[4] = [];
                break;
            case '/':
                section = sections.pop();
                section[5] = token[2];
                collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
                break;
            default:
                collector.push(token);
        }
    }
    return nestedTokens;
}
/**
 * A simple string scanner that is used by the template parser to find
 * tokens in template strings.
 */ function Scanner(string) {
    this.string = string;
    this.tail = string;
    this.pos = 0;
}
/**
 * Returns `true` if the tail is empty (end of string).
 */ Scanner.prototype.eos = function eos() {
    return this.tail === '';
};
/**
 * Tries to match the given regular expression at the current position.
 * Returns the matched text if it can match, the empty string otherwise.
 */ Scanner.prototype.scan = function scan(re) {
    var match = this.tail.match(re);
    if (!match || match.index !== 0) return '';
    var string = match[0];
    this.tail = this.tail.substring(string.length);
    this.pos += string.length;
    return string;
};
/**
 * Skips all text until the given regular expression can be matched. Returns
 * the skipped string, which is the entire tail if no match can be made.
 */ Scanner.prototype.scanUntil = function scanUntil(re) {
    var index = this.tail.search(re), match;
    switch(index){
        case -1:
            match = this.tail;
            this.tail = '';
            break;
        case 0:
            match = '';
            break;
        default:
            match = this.tail.substring(0, index);
            this.tail = this.tail.substring(index);
    }
    this.pos += match.length;
    return match;
};
/**
 * Represents a rendering context by wrapping a view object and
 * maintaining a reference to the parent context.
 */ function Context(view, parentContext) {
    this.view = view;
    this.cache = {
        '.': this.view
    };
    this.parent = parentContext;
}
/**
 * Creates a new context using the given view with this context
 * as the parent.
 */ Context.prototype.push = function push(view) {
    return new Context(view, this);
};
/**
 * Returns the value of the given name in this context, traversing
 * up the context hierarchy if the value is absent in this context's view.
 */ Context.prototype.lookup = function lookup(name) {
    var cache1 = this.cache;
    var value;
    if (cache1.hasOwnProperty(name)) {
        value = cache1[name];
    } else {
        var context = this, intermediateValue, names, index, lookupHit = false;
        while(context){
            if (name.indexOf('.') > 0) {
                intermediateValue = context.view;
                names = name.split('.');
                index = 0;
                /**
         * Using the dot notion path in `name`, we descend through the
         * nested objects.
         *
         * To be certain that the lookup has been successful, we have to
         * check if the last object in the path actually has the property
         * we are looking for. We store the result in `lookupHit`.
         *
         * This is specially necessary for when the value has been set to
         * `undefined` and we want to avoid looking up parent contexts.
         *
         * In the case where dot notation is used, we consider the lookup
         * to be successful even if the last "object" in the path is
         * not actually an object but a primitive (e.g., a string, or an
         * integer), because it is sometimes useful to access a property
         * of an autoboxed primitive, such as the length of a string.
         **/ while(intermediateValue != null && index < names.length){
                    if (index === names.length - 1) lookupHit = hasProperty(intermediateValue, names[index]) || primitiveHasOwnProperty(intermediateValue, names[index]);
                    intermediateValue = intermediateValue[names[index++]];
                }
            } else {
                intermediateValue = context.view[name];
                /**
         * Only checking against `hasProperty`, which always returns `false` if
         * `context.view` is not an object. Deliberately omitting the check
         * against `primitiveHasOwnProperty` if dot notation is not used.
         *
         * Consider this example:
         * ```
         * Mustache.render("The length of a football field is {{#length}}{{length}}{{/length}}.", {length: "100 yards"})
         * ```
         *
         * If we were to check also against `primitiveHasOwnProperty`, as we do
         * in the dot notation case, then render call would return:
         *
         * "The length of a football field is 9."
         *
         * rather than the expected:
         *
         * "The length of a football field is 100 yards."
         **/ lookupHit = hasProperty(context.view, name);
            }
            if (lookupHit) {
                value = intermediateValue;
                break;
            }
            context = context.parent;
        }
        cache1[name] = value;
    }
    if (isFunction(value)) value = value.call(this.view);
    return value;
};
/**
 * A Writer knows how to take a stream of tokens and render them to a
 * string, given a context. It also maintains a cache of templates to
 * avoid the need to parse the same template twice.
 */ function Writer() {
    this.templateCache = {
        _cache: {},
        set: function set(key, value) {
            this._cache[key] = value;
        },
        get: function get(key) {
            return this._cache[key];
        },
        clear: function clear() {
            this._cache = {};
        }
    };
}
/**
 * Clears all cached templates in this writer.
 */ Writer.prototype.clearCache = function clearCache() {
    if (typeof this.templateCache !== 'undefined') {
        this.templateCache.clear();
    }
};
/**
 * Parses and caches the given `template` according to the given `tags` or
 * `mustache.tags` if `tags` is omitted,  and returns the array of tokens
 * that is generated from the parse.
 */ Writer.prototype.parse = function parse(template, tags) {
    var cache1 = this.templateCache;
    var cacheKey = template + ':' + (tags || mustache.tags).join(':');
    var isCacheEnabled = typeof cache1 !== 'undefined';
    var tokens = isCacheEnabled ? cache1.get(cacheKey) : undefined;
    if (tokens == undefined) {
        tokens = parseTemplate(template, tags);
        isCacheEnabled && cache1.set(cacheKey, tokens);
    }
    return tokens;
};
/**
 * High-level method that is used to render the given `template` with
 * the given `view`.
 *
 * The optional `partials` argument may be an object that contains the
 * names and templates of partials that are used in the template. It may
 * also be a function that is used to load partial templates on the fly
 * that takes a single argument: the name of the partial.
 *
 * If the optional `config` argument is given here, then it should be an
 * object with a `tags` attribute or an `escape` attribute or both.
 * If an array is passed, then it will be interpreted the same way as
 * a `tags` attribute on a `config` object.
 *
 * The `tags` attribute of a `config` object must be an array with two
 * string values: the opening and closing tags used in the template (e.g.
 * [ "<%", "%>" ]). The default is to mustache.tags.
 *
 * The `escape` attribute of a `config` object must be a function which
 * accepts a string as input and outputs a safely escaped string.
 * If an `escape` function is not provided, then an HTML-safe string
 * escaping function is used as the default.
 */ Writer.prototype.render = function render(template, view, partials, config) {
    var tags = this.getConfigTags(config);
    var tokens = this.parse(template, tags);
    var context = view instanceof Context ? view : new Context(view, undefined);
    return this.renderTokens(tokens, context, partials, template, config);
};
/**
 * Low-level method that renders the given array of `tokens` using
 * the given `context` and `partials`.
 *
 * Note: The `originalTemplate` is only ever used to extract the portion
 * of the original template that was contained in a higher-order section.
 * If the template doesn't use higher-order sections, this argument may
 * be omitted.
 */ Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate, config) {
    var buffer = '';
    var token, symbol, value;
    for(var i = 0, numTokens = tokens.length; i < numTokens; ++i){
        value = undefined;
        token = tokens[i];
        symbol = token[0];
        if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate, config);
        else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate, config);
        else if (symbol === '>') value = this.renderPartial(token, context, partials, config);
        else if (symbol === '&') value = this.unescapedValue(token, context);
        else if (symbol === 'name') value = this.escapedValue(token, context, config);
        else if (symbol === 'text') value = this.rawValue(token);
        if (value !== undefined) buffer += value;
    }
    return buffer;
};
Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate, config) {
    var self = this;
    var buffer = '';
    var value = context.lookup(token[1]);
    // This function is used to render an arbitrary template
    // in the current context by higher-order sections.
    function subRender(template) {
        return self.render(template, context, partials, config);
    }
    if (!value) return;
    if (isArray(value)) {
        for(var j = 0, valueLength = value.length; j < valueLength; ++j){
            buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);
        }
    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {
        buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);
    } else if (isFunction(value)) {
        if (typeof originalTemplate !== 'string') throw new Error('Cannot use higher-order sections without the original template');
        // Extract the portion of the original template that the section contains.
        value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);
        if (value != null) buffer += value;
    } else {
        buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);
    }
    return buffer;
};
Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate, config) {
    var value = context.lookup(token[1]);
    // Use JavaScript's definition of falsy. Include empty arrays.
    // See https://github.com/janl/mustache.js/issues/186
    if (!value || isArray(value) && value.length === 0) return this.renderTokens(token[4], context, partials, originalTemplate, config);
};
Writer.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {
    var filteredIndentation = indentation.replace(/[^ \t]/g, '');
    var partialByNl = partial.split('\n');
    for(var i = 0; i < partialByNl.length; i++){
        if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
            partialByNl[i] = filteredIndentation + partialByNl[i];
        }
    }
    return partialByNl.join('\n');
};
Writer.prototype.renderPartial = function renderPartial(token, context, partials, config) {
    if (!partials) return;
    var tags = this.getConfigTags(config);
    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
    if (value != null) {
        var lineHasNonSpace = token[6];
        var tagIndex = token[5];
        var indentation = token[4];
        var indentedValue = value;
        if (tagIndex == 0 && indentation) {
            indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
        }
        var tokens = this.parse(indentedValue, tags);
        return this.renderTokens(tokens, context, partials, indentedValue, config);
    }
};
Writer.prototype.unescapedValue = function unescapedValue(token, context) {
    var value = context.lookup(token[1]);
    if (value != null) return value;
};
Writer.prototype.escapedValue = function escapedValue(token, context, config) {
    var escape = this.getConfigEscape(config) || mustache.escape;
    var value = context.lookup(token[1]);
    if (value != null) return typeof value === 'number' && escape === mustache.escape ? String(value) : escape(value);
};
Writer.prototype.rawValue = function rawValue(token) {
    return token[1];
};
Writer.prototype.getConfigTags = function getConfigTags(config) {
    if (isArray(config)) {
        return config;
    } else if (config && typeof config === 'object') {
        return config.tags;
    } else {
        return undefined;
    }
};
Writer.prototype.getConfigEscape = function getConfigEscape(config) {
    if (config && typeof config === 'object' && !isArray(config)) {
        return config.escape;
    } else {
        return undefined;
    }
};
var mustache = {
    name: 'mustache.js',
    version: '4.2.0',
    tags: [
        '{{',
        '}}'
    ],
    clearCache: undefined,
    escape: undefined,
    parse: undefined,
    render: undefined,
    Scanner: undefined,
    Context: undefined,
    Writer: undefined,
    /**
   * Allows a user to override the default caching strategy, by providing an
   * object with set, get and clear methods. This can also be used to disable
   * the cache by setting it to the literal `undefined`.
   */ set templateCache (cache){
        defaultWriter.templateCache = cache;
    },
    /**
   * Gets the default or overridden caching object from the default writer.
   */ get templateCache () {
        return defaultWriter.templateCache;
    }
};
// All high-level mustache.* functions use this writer.
var defaultWriter = new Writer();
/**
 * Clears all cached templates in the default writer.
 */ mustache.clearCache = function clearCache() {
    return defaultWriter.clearCache();
};
/**
 * Parses and caches the given template in the default writer and returns the
 * array of tokens it contains. Doing this ahead of time avoids the need to
 * parse templates on the fly as they are rendered.
 */ mustache.parse = function parse(template, tags) {
    return defaultWriter.parse(template, tags);
};
/**
 * Renders the `template` with the given `view`, `partials`, and `config`
 * using the default writer.
 */ mustache.render = function render(template, view, partials, config) {
    if (typeof template !== 'string') {
        throw new TypeError('Invalid template! Template should be a "string" ' + 'but "' + typeStr(template) + '" was given as the first ' + 'argument for mustache#render(template, view, partials)');
    }
    return defaultWriter.render(template, view, partials, config);
};
// Export the escaping function so that the user may override it.
// See https://github.com/janl/mustache.js/issues/244
mustache.escape = escapeHtml;
// Export these mainly for testing, but also for advanced usage.
mustache.Scanner = Scanner;
mustache.Context = Context;
mustache.Writer = Writer;
const __TURBOPACK__default__export__ = mustache;
}),
"[project]/align/node_modules/asap/raw.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var domain; // The domain module is executed on demand
var hasSetImmediate = typeof setImmediate === "function";
// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including network IO events in Node.js.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
module.exports = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing = true;
    }
    // Avoids a function call
    queue[queue.length] = task;
}
var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.
var flushing = false;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory excaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;
// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush() {
    while(index < queue.length){
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for(var scan = 0, newLength = queue.length - index; scan < newLength; scan++){
                queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
    flushing = false;
}
rawAsap.requestFlush = requestFlush;
function requestFlush() {
    // Ensure flushing is not bound to any domain.
    // It is not sufficient to exit the domain, because domains exist on a stack.
    // To execute code outside of any domain, the following dance is necessary.
    var parentDomain = process.domain;
    if (parentDomain) {
        if (!domain) {
            // Lazy execute the domain module.
            // Only employed if the user elects to use domains.
            domain = __turbopack_context__.r("[externals]/domain [external] (domain, cjs)");
        }
        domain.active = process.domain = null;
    }
    // `setImmediate` is slower that `process.nextTick`, but `process.nextTick`
    // cannot handle recursion.
    // `requestFlush` will only be called recursively from `asap.js`, to resume
    // flushing after an error is thrown into a domain.
    // Conveniently, `setImmediate` was introduced in the same version
    // `process.nextTick` started throwing recursion errors.
    if (flushing && hasSetImmediate) {
        setImmediate(flush);
    } else {
        process.nextTick(flush);
    }
    if (parentDomain) {
        domain.active = process.domain = parentDomain;
    }
}
}),
"[project]/align/node_modules/asap/asap.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var rawAsap = __turbopack_context__.r("[project]/align/node_modules/asap/raw.js [app-route] (ecmascript)");
var freeTasks = [];
/**
 * Calls a task as soon as possible after returning, in its own event, with
 * priority over IO events. An exception thrown in a task can be handled by
 * `process.on("uncaughtException") or `domain.on("error")`, but will otherwise
 * crash the process. If the error is handled, all subsequent tasks will
 * resume.
 *
 * @param {{call}} task A callable object, typically a function that takes no
 * arguments.
 */ module.exports = asap;
function asap(task) {
    var rawTask;
    if (freeTasks.length) {
        rawTask = freeTasks.pop();
    } else {
        rawTask = new RawTask();
    }
    rawTask.task = task;
    rawTask.domain = process.domain;
    rawAsap(rawTask);
}
function RawTask() {
    this.task = null;
    this.domain = null;
}
RawTask.prototype.call = function() {
    if (this.domain) {
        this.domain.enter();
    }
    var threw = true;
    try {
        this.task.call();
        threw = false;
        // If the task throws an exception (presumably) Node.js restores the
        // domain stack for the next event.
        if (this.domain) {
            this.domain.exit();
        }
    } finally{
        // We use try/finally and a threw flag to avoid messing up stack traces
        // when we catch and release errors.
        if (threw) {
            // In Node.js, uncaught exceptions are considered fatal errors.
            // Re-throw them to interrupt flushing!
            // Ensure that flushing continues if an uncaught exception is
            // suppressed listening process.on("uncaughtException") or
            // domain.on("error").
            rawAsap.requestFlush();
        }
        // If the task threw an error, we do not want to exit the domain here.
        // Exiting the domain would prevent the domain from catching the error.
        this.task = null;
        this.domain = null;
        freeTasks.push(this);
    }
};
}),
"[project]/align/node_modules/a-sync-waterfall/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// MIT license (by Elan Shanker).
(function(globals) {
    'use strict';
    var executeSync = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === 'function') {
            args[0].apply(null, args.splice(1));
        }
    };
    var executeAsync = function(fn) {
        if (typeof setImmediate === 'function') {
            setImmediate(fn);
        } else if (typeof process !== 'undefined' && process.nextTick) {
            process.nextTick(fn);
        } else {
            setTimeout(fn, 0);
        }
    };
    var makeIterator = function(tasks) {
        var makeCallback = function(index) {
            var fn = function() {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function() {
                return index < tasks.length - 1 ? makeCallback(index + 1) : null;
            };
            return fn;
        };
        return makeCallback(0);
    };
    var _isArray = Array.isArray || function(maybeArray) {
        return Object.prototype.toString.call(maybeArray) === '[object Array]';
    };
    var waterfall = function(tasks, callback, forceAsync) {
        var nextTick = forceAsync ? executeAsync : executeSync;
        callback = callback || function() {};
        if (!_isArray(tasks)) {
            var err = new Error('First argument to waterfall must be an array of functions');
            return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function(iterator) {
            return function(err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function() {};
                } else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    } else {
                        args.push(callback);
                    }
                    nextTick(function() {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(makeIterator(tasks))();
    };
    if (typeof define !== 'undefined' && define.amd) {
        ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
            return waterfall;
        }()); // RequireJS
    } else if (("TURBOPACK compile-time value", "object") !== 'undefined' && module.exports) {
        module.exports = waterfall; // CommonJS
    } else {
        globals.waterfall = waterfall; // <script>
    }
})(/*TURBOPACK member replacement*/ __turbopack_context__.e);
}),
"[project]/align/node_modules/picomatch/lib/constants.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const WIN_SLASH = '\\\\/';
const WIN_NO_SLASH = `[^${WIN_SLASH}]`;
/**
 * Posix glob regex
 */ const DOT_LITERAL = '\\.';
const PLUS_LITERAL = '\\+';
const QMARK_LITERAL = '\\?';
const SLASH_LITERAL = '\\/';
const ONE_CHAR = '(?=.)';
const QMARK = '[^/]';
const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
const NO_DOT = `(?!${DOT_LITERAL})`;
const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
const STAR = `${QMARK}*?`;
const POSIX_CHARS = {
    DOT_LITERAL,
    PLUS_LITERAL,
    QMARK_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    QMARK,
    END_ANCHOR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
};
/**
 * Windows glob regex
 */ const WINDOWS_CHARS = {
    ...POSIX_CHARS,
    SLASH_LITERAL: `[${WIN_SLASH}]`,
    QMARK: WIN_NO_SLASH,
    STAR: `${WIN_NO_SLASH}*?`,
    DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
    NO_DOT: `(?!${DOT_LITERAL})`,
    NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
    NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
    START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
    END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
};
/**
 * POSIX Bracket Regex
 */ const POSIX_REGEX_SOURCE = {
    alnum: 'a-zA-Z0-9',
    alpha: 'a-zA-Z',
    ascii: '\\x00-\\x7F',
    blank: ' \\t',
    cntrl: '\\x00-\\x1F\\x7F',
    digit: '0-9',
    graph: '\\x21-\\x7E',
    lower: 'a-z',
    print: '\\x20-\\x7E ',
    punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
    space: ' \\t\\r\\n\\v\\f',
    upper: 'A-Z',
    word: 'A-Za-z0-9_',
    xdigit: 'A-Fa-f0-9'
};
module.exports = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE,
    // regular expressions
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    // Replace globs with equivalent patterns to reduce parsing time.
    REPLACEMENTS: {
        '***': '*',
        '**/**': '**',
        '**/**/**': '**'
    },
    // Digits
    CHAR_0: 48,
    /* 0 */ CHAR_9: 57,
    /* 9 */ // Alphabet chars.
    CHAR_UPPERCASE_A: 65,
    /* A */ CHAR_LOWERCASE_A: 97,
    /* a */ CHAR_UPPERCASE_Z: 90,
    /* Z */ CHAR_LOWERCASE_Z: 122,
    /* z */ CHAR_LEFT_PARENTHESES: 40,
    /* ( */ CHAR_RIGHT_PARENTHESES: 41,
    /* ) */ CHAR_ASTERISK: 42,
    /* * */ // Non-alphabetic chars.
    CHAR_AMPERSAND: 38,
    /* & */ CHAR_AT: 64,
    /* @ */ CHAR_BACKWARD_SLASH: 92,
    /* \ */ CHAR_CARRIAGE_RETURN: 13,
    /* \r */ CHAR_CIRCUMFLEX_ACCENT: 94,
    /* ^ */ CHAR_COLON: 58,
    /* : */ CHAR_COMMA: 44,
    /* , */ CHAR_DOT: 46,
    /* . */ CHAR_DOUBLE_QUOTE: 34,
    /* " */ CHAR_EQUAL: 61,
    /* = */ CHAR_EXCLAMATION_MARK: 33,
    /* ! */ CHAR_FORM_FEED: 12,
    /* \f */ CHAR_FORWARD_SLASH: 47,
    /* / */ CHAR_GRAVE_ACCENT: 96,
    /* ` */ CHAR_HASH: 35,
    /* # */ CHAR_HYPHEN_MINUS: 45,
    /* - */ CHAR_LEFT_ANGLE_BRACKET: 60,
    /* < */ CHAR_LEFT_CURLY_BRACE: 123,
    /* { */ CHAR_LEFT_SQUARE_BRACKET: 91,
    /* [ */ CHAR_LINE_FEED: 10,
    /* \n */ CHAR_NO_BREAK_SPACE: 160,
    /* \u00A0 */ CHAR_PERCENT: 37,
    /* % */ CHAR_PLUS: 43,
    /* + */ CHAR_QUESTION_MARK: 63,
    /* ? */ CHAR_RIGHT_ANGLE_BRACKET: 62,
    /* > */ CHAR_RIGHT_CURLY_BRACE: 125,
    /* } */ CHAR_RIGHT_SQUARE_BRACKET: 93,
    /* ] */ CHAR_SEMICOLON: 59,
    /* ; */ CHAR_SINGLE_QUOTE: 39,
    /* ' */ CHAR_SPACE: 32,
    /*   */ CHAR_TAB: 9,
    /* \t */ CHAR_UNDERSCORE: 95,
    /* _ */ CHAR_VERTICAL_LINE: 124,
    /* | */ CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    /* \uFEFF */ SEP: path.sep,
    /**
   * Create EXTGLOB_CHARS
   */ extglobChars (chars) {
        return {
            '!': {
                type: 'negate',
                open: '(?:(?!(?:',
                close: `))${chars.STAR})`
            },
            '?': {
                type: 'qmark',
                open: '(?:',
                close: ')?'
            },
            '+': {
                type: 'plus',
                open: '(?:',
                close: ')+'
            },
            '*': {
                type: 'star',
                open: '(?:',
                close: ')*'
            },
            '@': {
                type: 'at',
                open: '(?:',
                close: ')'
            }
        };
    },
    /**
   * Create GLOB_CHARS
   */ globChars (win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
    }
};
}),
"[project]/align/node_modules/picomatch/lib/utils.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const win32 = process.platform === 'win32';
const { REGEX_BACKSLASH, REGEX_REMOVE_BACKSLASH, REGEX_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_GLOBAL } = __turbopack_context__.r("[project]/align/node_modules/picomatch/lib/constants.js [app-route] (ecmascript)");
exports.isObject = (val)=>val !== null && typeof val === 'object' && !Array.isArray(val);
exports.hasRegexChars = (str)=>REGEX_SPECIAL_CHARS.test(str);
exports.isRegexChar = (str)=>str.length === 1 && exports.hasRegexChars(str);
exports.escapeRegex = (str)=>str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
exports.toPosixSlashes = (str)=>str.replace(REGEX_BACKSLASH, '/');
exports.removeBackslashes = (str)=>{
    return str.replace(REGEX_REMOVE_BACKSLASH, (match)=>{
        return match === '\\' ? '' : match;
    });
};
exports.supportsLookbehinds = ()=>{
    const segs = process.version.slice(1).split('.').map(Number);
    if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
    }
    return false;
};
exports.isWindows = (options)=>{
    if (options && typeof options.windows === 'boolean') {
        return options.windows;
    }
    return win32 === true || path.sep === '\\';
};
exports.escapeLast = (input, char, lastIdx)=>{
    const idx = input.lastIndexOf(char, lastIdx);
    if (idx === -1) return input;
    if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
    return `${input.slice(0, idx)}\\${input.slice(idx)}`;
};
exports.removePrefix = (input, state = {})=>{
    let output = input;
    if (output.startsWith('./')) {
        output = output.slice(2);
        state.prefix = './';
    }
    return output;
};
exports.wrapOutput = (input, state = {}, options = {})=>{
    const prepend = options.contains ? '' : '^';
    const append = options.contains ? '' : '$';
    let output = `${prepend}(?:${input})${append}`;
    if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
    }
    return output;
};
}),
"[project]/align/node_modules/picomatch/lib/scan.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const utils = __turbopack_context__.r("[project]/align/node_modules/picomatch/lib/utils.js [app-route] (ecmascript)");
const { CHAR_ASTERISK, /* * */ CHAR_AT, /* @ */ CHAR_BACKWARD_SLASH, /* \ */ CHAR_COMMA, /* , */ CHAR_DOT, /* . */ CHAR_EXCLAMATION_MARK, /* ! */ CHAR_FORWARD_SLASH, /* / */ CHAR_LEFT_CURLY_BRACE, /* { */ CHAR_LEFT_PARENTHESES, /* ( */ CHAR_LEFT_SQUARE_BRACKET, /* [ */ CHAR_PLUS, /* + */ CHAR_QUESTION_MARK, /* ? */ CHAR_RIGHT_CURLY_BRACE, /* } */ CHAR_RIGHT_PARENTHESES, /* ) */ CHAR_RIGHT_SQUARE_BRACKET/* ] */  } = __turbopack_context__.r("[project]/align/node_modules/picomatch/lib/constants.js [app-route] (ecmascript)");
const isPathSeparator = (code)=>{
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
};
const depth = (token)=>{
    if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
    }
};
/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
 * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */ const scan = (input, options)=>{
    const opts = options || {};
    const length = input.length - 1;
    const scanToEnd = opts.parts === true || opts.scanToEnd === true;
    const slashes = [];
    const tokens = [];
    const parts = [];
    let str = input;
    let index = -1;
    let start = 0;
    let lastIndex = 0;
    let isBrace = false;
    let isBracket = false;
    let isGlob = false;
    let isExtglob = false;
    let isGlobstar = false;
    let braceEscaped = false;
    let backslashes = false;
    let negated = false;
    let negatedExtglob = false;
    let finished = false;
    let braces = 0;
    let prev;
    let code;
    let token = {
        value: '',
        depth: 0,
        isGlob: false
    };
    const eos = ()=>index >= length;
    const peek = ()=>str.charCodeAt(index + 1);
    const advance = ()=>{
        prev = code;
        return str.charCodeAt(++index);
    };
    while(index < length){
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            code = advance();
            if (code === CHAR_LEFT_CURLY_BRACE) {
                braceEscaped = true;
            }
            continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            while(eos() !== true && (code = advance())){
                if (code === CHAR_BACKWARD_SLASH) {
                    backslashes = token.backslashes = true;
                    advance();
                    continue;
                }
                if (code === CHAR_LEFT_CURLY_BRACE) {
                    braces++;
                    continue;
                }
                if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
                    isBrace = token.isBrace = true;
                    isGlob = token.isGlob = true;
                    finished = true;
                    if (scanToEnd === true) {
                        continue;
                    }
                    break;
                }
                if (braceEscaped !== true && code === CHAR_COMMA) {
                    isBrace = token.isBrace = true;
                    isGlob = token.isGlob = true;
                    finished = true;
                    if (scanToEnd === true) {
                        continue;
                    }
                    break;
                }
                if (code === CHAR_RIGHT_CURLY_BRACE) {
                    braces--;
                    if (braces === 0) {
                        braceEscaped = false;
                        isBrace = token.isBrace = true;
                        finished = true;
                        break;
                    }
                }
            }
            if (scanToEnd === true) {
                continue;
            }
            break;
        }
        if (code === CHAR_FORWARD_SLASH) {
            slashes.push(index);
            tokens.push(token);
            token = {
                value: '',
                depth: 0,
                isGlob: false
            };
            if (finished === true) continue;
            if (prev === CHAR_DOT && index === start + 1) {
                start += 2;
                continue;
            }
            lastIndex = index + 1;
            continue;
        }
        if (opts.noext !== true) {
            const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
            if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
                isGlob = token.isGlob = true;
                isExtglob = token.isExtglob = true;
                finished = true;
                if (code === CHAR_EXCLAMATION_MARK && index === start) {
                    negatedExtglob = true;
                }
                if (scanToEnd === true) {
                    while(eos() !== true && (code = advance())){
                        if (code === CHAR_BACKWARD_SLASH) {
                            backslashes = token.backslashes = true;
                            code = advance();
                            continue;
                        }
                        if (code === CHAR_RIGHT_PARENTHESES) {
                            isGlob = token.isGlob = true;
                            finished = true;
                            break;
                        }
                    }
                    continue;
                }
                break;
            }
        }
        if (code === CHAR_ASTERISK) {
            if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
                continue;
            }
            break;
        }
        if (code === CHAR_QUESTION_MARK) {
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
                continue;
            }
            break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
            while(eos() !== true && (next = advance())){
                if (next === CHAR_BACKWARD_SLASH) {
                    backslashes = token.backslashes = true;
                    advance();
                    continue;
                }
                if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                    isBracket = token.isBracket = true;
                    isGlob = token.isGlob = true;
                    finished = true;
                    break;
                }
            }
            if (scanToEnd === true) {
                continue;
            }
            break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
            negated = token.negated = true;
            start++;
            continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            if (scanToEnd === true) {
                while(eos() !== true && (code = advance())){
                    if (code === CHAR_LEFT_PARENTHESES) {
                        backslashes = token.backslashes = true;
                        code = advance();
                        continue;
                    }
                    if (code === CHAR_RIGHT_PARENTHESES) {
                        finished = true;
                        break;
                    }
                }
                continue;
            }
            break;
        }
        if (isGlob === true) {
            finished = true;
            if (scanToEnd === true) {
                continue;
            }
            break;
        }
    }
    if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
    }
    let base = str;
    let prefix = '';
    let glob = '';
    if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
    }
    if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
    } else if (isGlob === true) {
        base = '';
        glob = str;
    } else {
        base = str;
    }
    if (base && base !== '' && base !== '/' && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
            base = base.slice(0, -1);
        }
    }
    if (opts.unescape === true) {
        if (glob) glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
            base = utils.removeBackslashes(base);
        }
    }
    const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
    };
    if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
            tokens.push(token);
        }
        state.tokens = tokens;
    }
    if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for(let idx = 0; idx < slashes.length; idx++){
            const n = prevIndex ? prevIndex + 1 : start;
            const i = slashes[idx];
            const value = input.slice(n, i);
            if (opts.tokens) {
                if (idx === 0 && start !== 0) {
                    tokens[idx].isPrefix = true;
                    tokens[idx].value = prefix;
                } else {
                    tokens[idx].value = value;
                }
                depth(tokens[idx]);
                state.maxDepth += tokens[idx].depth;
            }
            if (idx !== 0 || value !== '') {
                parts.push(value);
            }
            prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
            const value = input.slice(prevIndex + 1);
            parts.push(value);
            if (opts.tokens) {
                tokens[tokens.length - 1].value = value;
                depth(tokens[tokens.length - 1]);
                state.maxDepth += tokens[tokens.length - 1].depth;
            }
        }
        state.slashes = slashes;
        state.parts = parts;
    }
    return state;
};
module.exports = scan;
}),
"[project]/align/node_modules/picomatch/lib/parse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const constants = __turbopack_context__.r("[project]/align/node_modules/picomatch/lib/constants.js [app-route] (ecmascript)");
const utils = __turbopack_context__.r("[project]/align/node_modules/picomatch/lib/utils.js [app-route] (ecmascript)");
/**
 * Constants
 */ const { MAX_LENGTH, POSIX_REGEX_SOURCE, REGEX_NON_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_BACKREF, REPLACEMENTS } = constants;
/**
 * Helpers
 */ const expandRange = (args, options)=>{
    if (typeof options.expandRange === 'function') {
        return options.expandRange(...args, options);
    }
    args.sort();
    const value = `[${args.join('-')}]`;
    try {
        /* eslint-disable-next-line no-new */ new RegExp(value);
    } catch (ex) {
        return args.map((v)=>utils.escapeRegex(v)).join('..');
    }
    return value;
};
/**
 * Create the message for a syntax error
 */ const syntaxError = (type, char)=>{
    return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};
/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */ const parse = (input, options)=>{
    if (typeof input !== 'string') {
        throw new TypeError('Expected a string');
    }
    input = REPLACEMENTS[input] || input;
    const opts = {
        ...options
    };
    const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    let len = input.length;
    if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    }
    const bos = {
        type: 'bos',
        value: '',
        output: opts.prepend || ''
    };
    const tokens = [
        bos
    ];
    const capture = opts.capture ? '' : '?:';
    const win32 = utils.isWindows(options);
    // create constants based on platform, for windows or posix
    const PLATFORM_CHARS = constants.globChars(win32);
    const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
    const { DOT_LITERAL, PLUS_LITERAL, SLASH_LITERAL, ONE_CHAR, DOTS_SLASH, NO_DOT, NO_DOT_SLASH, NO_DOTS_SLASH, QMARK, QMARK_NO_DOT, STAR, START_ANCHOR } = PLATFORM_CHARS;
    const globstar = (opts)=>{
        return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const nodot = opts.dot ? '' : NO_DOT;
    const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
    let star = opts.bash === true ? globstar(opts) : STAR;
    if (opts.capture) {
        star = `(${star})`;
    }
    // minimatch options support
    if (typeof opts.noext === 'boolean') {
        opts.noextglob = opts.noext;
    }
    const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: '',
        output: '',
        prefix: '',
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
    };
    input = utils.removePrefix(input, state);
    len = input.length;
    const extglobs = [];
    const braces = [];
    const stack = [];
    let prev = bos;
    let value;
    /**
   * Tokenizing helpers
   */ const eos = ()=>state.index === len - 1;
    const peek = state.peek = (n = 1)=>input[state.index + n];
    const advance = state.advance = ()=>input[++state.index] || '';
    const remaining = ()=>input.slice(state.index + 1);
    const consume = (value = '', num = 0)=>{
        state.consumed += value;
        state.index += num;
    };
    const append = (token)=>{
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
    };
    const negate = ()=>{
        let count = 1;
        while(peek() === '!' && (peek(2) !== '(' || peek(3) === '?')){
            advance();
            state.start++;
            count++;
        }
        if (count % 2 === 0) {
            return false;
        }
        state.negated = true;
        state.start++;
        return true;
    };
    const increment = (type)=>{
        state[type]++;
        stack.push(type);
    };
    const decrement = (type)=>{
        state[type]--;
        stack.pop();
    };
    /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */ const push = (tok)=>{
        if (prev.type === 'globstar') {
            const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
            const isExtglob = tok.extglob === true || extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');
            if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
                state.output = state.output.slice(0, -prev.output.length);
                prev.type = 'star';
                prev.value = '*';
                prev.output = star;
                state.output += prev.output;
            }
        }
        if (extglobs.length && tok.type !== 'paren') {
            extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output) append(tok);
        if (prev && prev.type === 'text' && tok.type === 'text') {
            prev.value += tok.value;
            prev.output = (prev.output || '') + tok.value;
            return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
    };
    const extglobOpen = (type, value)=>{
        const token = {
            ...EXTGLOB_CHARS[value],
            conditions: 1,
            inner: ''
        };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? '(' : '') + token.open;
        increment('parens');
        push({
            type,
            value,
            output: state.output ? '' : ONE_CHAR
        });
        push({
            type: 'paren',
            extglob: true,
            value: advance(),
            output
        });
        extglobs.push(token);
    };
    const extglobClose = (token)=>{
        let output = token.close + (opts.capture ? ')' : '');
        let rest;
        if (token.type === 'negate') {
            let extglobStar = star;
            if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
                extglobStar = globstar(opts);
            }
            if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
                output = token.close = `)$))${extglobStar}`;
            }
            if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
                // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
                // In this case, we need to parse the string and use it in the output of the original pattern.
                // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
                //
                // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
                const expression = parse(rest, {
                    ...options,
                    fastpaths: false
                }).output;
                output = token.close = `)${expression})${extglobStar})`;
            }
            if (token.prev.type === 'bos') {
                state.negatedExtglob = true;
            }
        }
        push({
            type: 'paren',
            extglob: true,
            value,
            output
        });
        decrement('parens');
    };
    /**
   * Fast paths
   */ if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index)=>{
            if (first === '\\') {
                backslashes = true;
                return m;
            }
            if (first === '?') {
                if (esc) {
                    return esc + first + (rest ? QMARK.repeat(rest.length) : '');
                }
                if (index === 0) {
                    return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
                }
                return QMARK.repeat(chars.length);
            }
            if (first === '.') {
                return DOT_LITERAL.repeat(chars.length);
            }
            if (first === '*') {
                if (esc) {
                    return esc + first + (rest ? star : '');
                }
                return star;
            }
            return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
            if (opts.unescape === true) {
                output = output.replace(/\\/g, '');
            } else {
                output = output.replace(/\\+/g, (m)=>{
                    return m.length % 2 === 0 ? '\\\\' : m ? '\\' : '';
                });
            }
        }
        if (output === input && opts.contains === true) {
            state.output = input;
            return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
    }
    /**
   * Tokenize input until we reach end-of-string
   */ while(!eos()){
        value = advance();
        if (value === '\u0000') {
            continue;
        }
        /**
     * Escaped characters
     */ if (value === '\\') {
            const next = peek();
            if (next === '/' && opts.bash !== true) {
                continue;
            }
            if (next === '.' || next === ';') {
                continue;
            }
            if (!next) {
                value += '\\';
                push({
                    type: 'text',
                    value
                });
                continue;
            }
            // collapse slashes to reduce potential for exploits
            const match = /^\\+/.exec(remaining());
            let slashes = 0;
            if (match && match[0].length > 2) {
                slashes = match[0].length;
                state.index += slashes;
                if (slashes % 2 !== 0) {
                    value += '\\';
                }
            }
            if (opts.unescape === true) {
                value = advance();
            } else {
                value += advance();
            }
            if (state.brackets === 0) {
                push({
                    type: 'text',
                    value
                });
                continue;
            }
        }
        /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */ if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
            if (opts.posix !== false && value === ':') {
                const inner = prev.value.slice(1);
                if (inner.includes('[')) {
                    prev.posix = true;
                    if (inner.includes(':')) {
                        const idx = prev.value.lastIndexOf('[');
                        const pre = prev.value.slice(0, idx);
                        const rest = prev.value.slice(idx + 2);
                        const posix = POSIX_REGEX_SOURCE[rest];
                        if (posix) {
                            prev.value = pre + posix;
                            state.backtrack = true;
                            advance();
                            if (!bos.output && tokens.indexOf(prev) === 1) {
                                bos.output = ONE_CHAR;
                            }
                            continue;
                        }
                    }
                }
            }
            if (value === '[' && peek() !== ':' || value === '-' && peek() === ']') {
                value = `\\${value}`;
            }
            if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
                value = `\\${value}`;
            }
            if (opts.posix === true && value === '!' && prev.value === '[') {
                value = '^';
            }
            prev.value += value;
            append({
                value
            });
            continue;
        }
        /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */ if (state.quotes === 1 && value !== '"') {
            value = utils.escapeRegex(value);
            prev.value += value;
            append({
                value
            });
            continue;
        }
        /**
     * Double quotes
     */ if (value === '"') {
            state.quotes = state.quotes === 1 ? 0 : 1;
            if (opts.keepQuotes === true) {
                push({
                    type: 'text',
                    value
                });
            }
            continue;
        }
        /**
     * Parentheses
     */ if (value === '(') {
            increment('parens');
            push({
                type: 'paren',
                value
            });
            continue;
        }
        if (value === ')') {
            if (state.parens === 0 && opts.strictBrackets === true) {
                throw new SyntaxError(syntaxError('opening', '('));
            }
            const extglob = extglobs[extglobs.length - 1];
            if (extglob && state.parens === extglob.parens + 1) {
                extglobClose(extglobs.pop());
                continue;
            }
            push({
                type: 'paren',
                value,
                output: state.parens ? ')' : '\\)'
            });
            decrement('parens');
            continue;
        }
        /**
     * Square brackets
     */ if (value === '[') {
            if (opts.nobracket === true || !remaining().includes(']')) {
                if (opts.nobracket !== true && opts.strictBrackets === true) {
                    throw new SyntaxError(syntaxError('closing', ']'));
                }
                value = `\\${value}`;
            } else {
                increment('brackets');
            }
            push({
                type: 'bracket',
                value
            });
            continue;
        }
        if (value === ']') {
            if (opts.nobracket === true || prev && prev.type === 'bracket' && prev.value.length === 1) {
                push({
                    type: 'text',
                    value,
                    output: `\\${value}`
                });
                continue;
            }
            if (state.brackets === 0) {
                if (opts.strictBrackets === true) {
                    throw new SyntaxError(syntaxError('opening', '['));
                }
                push({
                    type: 'text',
                    value,
                    output: `\\${value}`
                });
                continue;
            }
            decrement('brackets');
            const prevValue = prev.value.slice(1);
            if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
                value = `/${value}`;
            }
            prev.value += value;
            append({
                value
            });
            // when literal brackets are explicitly disabled
            // assume we should match with a regex character class
            if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
                continue;
            }
            const escaped = utils.escapeRegex(prev.value);
            state.output = state.output.slice(0, -prev.value.length);
            // when literal brackets are explicitly enabled
            // assume we should escape the brackets to match literal characters
            if (opts.literalBrackets === true) {
                state.output += escaped;
                prev.value = escaped;
                continue;
            }
            // when the user specifies nothing, try to match both
            prev.value = `(${capture}${escaped}|${prev.value})`;
            state.output += prev.value;
            continue;
        }
        /**
     * Braces
     */ if (value === '{' && opts.nobrace !== true) {
            increment('braces');
            const open = {
                type: 'brace',
                value,
                output: '(',
                outputIndex: state.output.length,
                tokensIndex: state.tokens.length
            };
            braces.push(open);
            push(open);
            continue;
        }
        if (value === '}') {
            const brace = braces[braces.length - 1];
            if (opts.nobrace === true || !brace) {
                push({
                    type: 'text',
                    value,
                    output: value
                });
                continue;
            }
            let output = ')';
            if (brace.dots === true) {
                const arr = tokens.slice();
                const range = [];
                for(let i = arr.length - 1; i >= 0; i--){
                    tokens.pop();
                    if (arr[i].type === 'brace') {
                        break;
                    }
                    if (arr[i].type !== 'dots') {
                        range.unshift(arr[i].value);
                    }
                }
                output = expandRange(range, opts);
                state.backtrack = true;
            }
            if (brace.comma !== true && brace.dots !== true) {
                const out = state.output.slice(0, brace.outputIndex);
                const toks = state.tokens.slice(brace.tokensIndex);
                brace.value = brace.output = '\\{';
                value = output = '\\}';
                state.output = out;
                for (const t of toks){
                    state.output += t.output || t.value;
                }
            }
            push({
                type: 'brace',
                value,
                output
            });
            decrement('braces');
            braces.pop();
            continue;
        }
        /**
     * Pipes
     */ if (value === '|') {
            if (extglobs.length > 0) {
                extglobs[extglobs.length - 1].conditions++;
            }
            push({
                type: 'text',
                value
            });
            continue;
        }
        /**
     * Commas
     */ if (value === ',') {
            let output = value;
            const brace = braces[braces.length - 1];
            if (brace && stack[stack.length - 1] === 'braces') {
                brace.comma = true;
                output = '|';
            }
            push({
                type: 'comma',
                value,
                output
            });
            continue;
        }
        /**
     * Slashes
     */ if (value === '/') {
            // if the beginning of the glob is "./", advance the start
            // to the current index, and don't add the "./" characters
            // to the state. This greatly simplifies lookbehinds when
            // checking for BOS characters like "!" and "." (not "./")
            if (prev.type === 'dot' && state.index === state.start + 1) {
                state.start = state.index + 1;
                state.consumed = '';
                state.output = '';
                tokens.pop();
                prev = bos; // reset "prev" to the first token
                continue;
            }
            push({
                type: 'slash',
                value,
                output: SLASH_LITERAL
            });
            continue;
        }
        /**
     * Dots
     */ if (value === '.') {
            if (state.braces > 0 && prev.type === 'dot') {
                if (prev.value === '.') prev.output = DOT_LITERAL;
                const brace = braces[braces.length - 1];
                prev.type = 'dots';
                prev.output += value;
                prev.value += value;
                brace.dots = true;
                continue;
            }
            if (state.braces + state.parens === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
                push({
                    type: 'text',
                    value,
                    output: DOT_LITERAL
                });
                continue;
            }
            push({
                type: 'dot',
                value,
                output: DOT_LITERAL
            });
            continue;
        }
        /**
     * Question marks
     */ if (value === '?') {
            const isGroup = prev && prev.value === '(';
            if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
                extglobOpen('qmark', value);
                continue;
            }
            if (prev && prev.type === 'paren') {
                const next = peek();
                let output = value;
                if (next === '<' && !utils.supportsLookbehinds()) {
                    throw new Error('Node.js v10 or higher is required for regex lookbehinds');
                }
                if (prev.value === '(' && !/[!=<:]/.test(next) || next === '<' && !/<([!=]|\w+>)/.test(remaining())) {
                    output = `\\${value}`;
                }
                push({
                    type: 'text',
                    value,
                    output
                });
                continue;
            }
            if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
                push({
                    type: 'qmark',
                    value,
                    output: QMARK_NO_DOT
                });
                continue;
            }
            push({
                type: 'qmark',
                value,
                output: QMARK
            });
            continue;
        }
        /**
     * Exclamation
     */ if (value === '!') {
            if (opts.noextglob !== true && peek() === '(') {
                if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
                    extglobOpen('negate', value);
                    continue;
                }
            }
            if (opts.nonegate !== true && state.index === 0) {
                negate();
                continue;
            }
        }
        /**
     * Plus
     */ if (value === '+') {
            if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
                extglobOpen('plus', value);
                continue;
            }
            if (prev && prev.value === '(' || opts.regex === false) {
                push({
                    type: 'plus',
                    value,
                    output: PLUS_LITERAL
                });
                continue;
            }
            if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace') || state.parens > 0) {
                push({
                    type: 'plus',
                    value
                });
                continue;
            }
            push({
                type: 'plus',
                value: PLUS_LITERAL
            });
            continue;
        }
        /**
     * Plain text
     */ if (value === '@') {
            if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
                push({
                    type: 'at',
                    extglob: true,
                    value,
                    output: ''
                });
                continue;
            }
            push({
                type: 'text',
                value
            });
            continue;
        }
        /**
     * Plain text
     */ if (value !== '*') {
            if (value === '$' || value === '^') {
                value = `\\${value}`;
            }
            const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
            if (match) {
                value += match[0];
                state.index += match[0].length;
            }
            push({
                type: 'text',
                value
            });
            continue;
        }
        /**
     * Stars
     */ if (prev && (prev.type === 'globstar' || prev.star === true)) {
            prev.type = 'star';
            prev.star = true;
            prev.value += value;
            prev.output = star;
            state.backtrack = true;
            state.globstar = true;
            consume(value);
            continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
            extglobOpen('star', value);
            continue;
        }
        if (prev.type === 'star') {
            if (opts.noglobstar === true) {
                consume(value);
                continue;
            }
            const prior = prev.prev;
            const before = prior.prev;
            const isStart = prior.type === 'slash' || prior.type === 'bos';
            const afterStar = before && (before.type === 'star' || before.type === 'globstar');
            if (opts.bash === true && (!isStart || rest[0] && rest[0] !== '/')) {
                push({
                    type: 'star',
                    value,
                    output: ''
                });
                continue;
            }
            const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
            const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
            if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
                push({
                    type: 'star',
                    value,
                    output: ''
                });
                continue;
            }
            // strip consecutive `/**/`
            while(rest.slice(0, 3) === '/**'){
                const after = input[state.index + 4];
                if (after && after !== '/') {
                    break;
                }
                rest = rest.slice(3);
                consume('/**', 3);
            }
            if (prior.type === 'bos' && eos()) {
                prev.type = 'globstar';
                prev.value += value;
                prev.output = globstar(opts);
                state.output = prev.output;
                state.globstar = true;
                consume(value);
                continue;
            }
            if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
                state.output = state.output.slice(0, -(prior.output + prev.output).length);
                prior.output = `(?:${prior.output}`;
                prev.type = 'globstar';
                prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
                prev.value += value;
                state.globstar = true;
                state.output += prior.output + prev.output;
                consume(value);
                continue;
            }
            if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
                const end = rest[1] !== void 0 ? '|$' : '';
                state.output = state.output.slice(0, -(prior.output + prev.output).length);
                prior.output = `(?:${prior.output}`;
                prev.type = 'globstar';
                prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
                prev.value += value;
                state.output += prior.output + prev.output;
                state.globstar = true;
                consume(value + advance());
                push({
                    type: 'slash',
                    value: '/',
                    output: ''
                });
                continue;
            }
            if (prior.type === 'bos' && rest[0] === '/') {
                prev.type = 'globstar';
                prev.value += value;
                prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
                state.output = prev.output;
                state.globstar = true;
                consume(value + advance());
                push({
                    type: 'slash',
                    value: '/',
                    output: ''
                });
                continue;
            }
            // remove single star from output
            state.output = state.output.slice(0, -prev.output.length);
            // reset previous token to globstar
            prev.type = 'globstar';
            prev.output = globstar(opts);
            prev.value += value;
            // reset output with globstar
            state.output += prev.output;
            state.globstar = true;
            consume(value);
            continue;
        }
        const token = {
            type: 'star',
            value,
            output: star
        };
        if (opts.bash === true) {
            token.output = '.*?';
            if (prev.type === 'bos' || prev.type === 'slash') {
                token.output = nodot + token.output;
            }
            push(token);
            continue;
        }
        if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
            token.output = value;
            push(token);
            continue;
        }
        if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
            if (prev.type === 'dot') {
                state.output += NO_DOT_SLASH;
                prev.output += NO_DOT_SLASH;
            } else if (opts.dot === true) {
                state.output += NO_DOTS_SLASH;
                prev.output += NO_DOTS_SLASH;
            } else {
                state.output += nodot;
                prev.output += nodot;
            }
            if (peek() !== '*') {
                state.output += ONE_CHAR;
                prev.output += ONE_CHAR;
            }
        }
        push(token);
    }
    while(state.brackets > 0){
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
        state.output = utils.escapeLast(state.output, '[');
        decrement('brackets');
    }
    while(state.parens > 0){
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
        state.output = utils.escapeLast(state.output, '(');
        decrement('parens');
    }
    while(state.braces > 0){
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
        state.output = utils.escapeLast(state.output, '{');
        decrement('braces');
    }
    if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
        push({
            type: 'maybe_slash',
            value: '',
            output: `${SLASH_LITERAL}?`
        });
    }
    // rebuild the output if we had to backtrack at any point
    if (state.backtrack === true) {
        state.output = '';
        for (const token of state.tokens){
            state.output += token.output != null ? token.output : token.value;
            if (token.suffix) {
                state.output += token.suffix;
            }
        }
    }
    return state;
};
/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */ parse.fastpaths = (input, options)=>{
    const opts = {
        ...options
    };
    const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    const len = input.length;
    if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    }
    input = REPLACEMENTS[input] || input;
    const win32 = utils.isWindows(options);
    // create constants based on platform, for windows or posix
    const { DOT_LITERAL, SLASH_LITERAL, ONE_CHAR, DOTS_SLASH, NO_DOT, NO_DOTS, NO_DOTS_SLASH, STAR, START_ANCHOR } = constants.globChars(win32);
    const nodot = opts.dot ? NO_DOTS : NO_DOT;
    const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
    const capture = opts.capture ? '' : '?:';
    const state = {
        negated: false,
        prefix: ''
    };
    let star = opts.bash === true ? '.*?' : STAR;
    if (opts.capture) {
        star = `(${star})`;
    }
    const globstar = (opts)=>{
        if (opts.noglobstar === true) return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const create = (str)=>{
        switch(str){
            case '*':
                return `${nodot}${ONE_CHAR}${star}`;
            case '.*':
                return `${DOT_LITERAL}${ONE_CHAR}${star}`;
            case '*.*':
                return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
            case '*/*':
                return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
            case '**':
                return nodot + globstar(opts);
            case '**/*':
                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
            case '**/*.*':
                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
            case '**/.*':
                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
            default:
                {
                    const match = /^(.*?)\.(\w+)$/.exec(str);
                    if (!match) return;
                    const source = create(match[1]);
                    if (!source) return;
                    return source + DOT_LITERAL + match[2];
                }
        }
    };
    const output = utils.removePrefix(input, state);
    let source = create(output);
    if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
    }
    return source;
};
module.exports = parse;
}),
"[project]/align/node_modules/picomatch/lib/picomatch.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const scan = __turbopack_context__.r("[project]/align/node_modules/picomatch/lib/scan.js [app-route] (ecmascript)");
const parse = __turbopack_context__.r("[project]/align/node_modules/picomatch/lib/parse.js [app-route] (ecmascript)");
const utils = __turbopack_context__.r("[project]/align/node_modules/picomatch/lib/utils.js [app-route] (ecmascript)");
const constants = __turbopack_context__.r("[project]/align/node_modules/picomatch/lib/constants.js [app-route] (ecmascript)");
const isObject = (val)=>val && typeof val === 'object' && !Array.isArray(val);
/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 */ const picomatch = (glob, options, returnState = false)=>{
    if (Array.isArray(glob)) {
        const fns = glob.map((input)=>picomatch(input, options, returnState));
        const arrayMatcher = (str)=>{
            for (const isMatch of fns){
                const state = isMatch(str);
                if (state) return state;
            }
            return false;
        };
        return arrayMatcher;
    }
    const isState = isObject(glob) && glob.tokens && glob.input;
    if (glob === '' || typeof glob !== 'string' && !isState) {
        throw new TypeError('Expected pattern to be a non-empty string');
    }
    const opts = options || {};
    const posix = utils.isWindows(options);
    const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
    const state = regex.state;
    delete regex.state;
    let isIgnored = ()=>false;
    if (opts.ignore) {
        const ignoreOpts = {
            ...options,
            ignore: null,
            onMatch: null,
            onResult: null
        };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
    }
    const matcher = (input, returnObject = false)=>{
        const { isMatch, match, output } = picomatch.test(input, regex, options, {
            glob,
            posix
        });
        const result = {
            glob,
            state,
            regex,
            posix,
            input,
            output,
            match,
            isMatch
        };
        if (typeof opts.onResult === 'function') {
            opts.onResult(result);
        }
        if (isMatch === false) {
            result.isMatch = false;
            return returnObject ? result : false;
        }
        if (isIgnored(input)) {
            if (typeof opts.onIgnore === 'function') {
                opts.onIgnore(result);
            }
            result.isMatch = false;
            return returnObject ? result : false;
        }
        if (typeof opts.onMatch === 'function') {
            opts.onMatch(result);
        }
        return returnObject ? result : true;
    };
    if (returnState) {
        matcher.state = state;
    }
    return matcher;
};
/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 */ picomatch.test = (input, regex, options, { glob, posix } = {})=>{
    if (typeof input !== 'string') {
        throw new TypeError('Expected input to be a string');
    }
    if (input === '') {
        return {
            isMatch: false,
            output: ''
        };
    }
    const opts = options || {};
    const format = opts.format || (posix ? utils.toPosixSlashes : null);
    let match = input === glob;
    let output = match && format ? format(input) : input;
    if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
    }
    if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
            match = picomatch.matchBase(input, regex, options, posix);
        } else {
            match = regex.exec(output);
        }
    }
    return {
        isMatch: Boolean(match),
        match,
        output
    };
};
/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 */ picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options))=>{
    const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
    return regex.test(path.basename(input));
};
/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */ picomatch.isMatch = (str, patterns, options)=>picomatch(patterns, options)(str);
/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */ picomatch.parse = (pattern, options)=>{
    if (Array.isArray(pattern)) return pattern.map((p)=>picomatch.parse(p, options));
    return parse(pattern, {
        ...options,
        fastpaths: false
    });
};
/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * { prefix: '!./',
 *   input: '!./foo/*.js',
 *   start: 3,
 *   base: 'foo',
 *   glob: '*.js',
 *   isBrace: false,
 *   isBracket: false,
 *   isGlob: true,
 *   isExtglob: false,
 *   isGlobstar: false,
 *   negated: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */ picomatch.scan = (input, options)=>scan(input, options);
/**
 * Compile a regular expression from the `state` object returned by the
 * [parse()](#parse) method.
 *
 * @param {Object} `state`
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
 * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
 * @return {RegExp}
 * @api public
 */ picomatch.compileRe = (state, options, returnOutput = false, returnState = false)=>{
    if (returnOutput === true) {
        return state.output;
    }
    const opts = options || {};
    const prepend = opts.contains ? '' : '^';
    const append = opts.contains ? '' : '$';
    let source = `${prepend}(?:${state.output})${append}`;
    if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
    }
    const regex = picomatch.toRegex(source, options);
    if (returnState === true) {
        regex.state = state;
    }
    return regex;
};
/**
 * Create a regular expression from a parsed glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const state = picomatch.parse('*.js');
 * // picomatch.compileRe(state[, options]);
 *
 * console.log(picomatch.compileRe(state));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `state` The object returned from the `.parse` method.
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
 * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */ picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false)=>{
    if (!input || typeof input !== 'string') {
        throw new TypeError('Expected a non-empty string');
    }
    let parsed = {
        negated: false,
        fastpaths: true
    };
    if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
        parsed.output = parse.fastpaths(input, options);
    }
    if (!parsed.output) {
        parsed = parse(input, options);
    }
    return picomatch.compileRe(parsed, options, returnOutput, returnState);
};
/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */ picomatch.toRegex = (source, options)=>{
    try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
    } catch (err) {
        if (options && options.debug === true) throw err;
        return /$^/;
    }
};
/**
 * Picomatch constants.
 * @return {Object}
 */ picomatch.constants = constants;
/**
 * Expose "picomatch"
 */ module.exports = picomatch;
}),
"[project]/align/node_modules/picomatch/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/align/node_modules/picomatch/lib/picomatch.js [app-route] (ecmascript)");
}),
"[project]/align/node_modules/readdirp/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const { Readable } = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const sysPath = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const { promisify } = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const picomatch = __turbopack_context__.r("[project]/align/node_modules/picomatch/index.js [app-route] (ecmascript)");
const readdir = promisify(fs.readdir);
const stat = promisify(fs.stat);
const lstat = promisify(fs.lstat);
const realpath = promisify(fs.realpath);
/**
 * @typedef {Object} EntryInfo
 * @property {String} path
 * @property {String} fullPath
 * @property {fs.Stats=} stats
 * @property {fs.Dirent=} dirent
 * @property {String} basename
 */ const BANG = '!';
const RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';
const NORMAL_FLOW_ERRORS = new Set([
    'ENOENT',
    'EPERM',
    'EACCES',
    'ELOOP',
    RECURSIVE_ERROR_CODE
]);
const FILE_TYPE = 'files';
const DIR_TYPE = 'directories';
const FILE_DIR_TYPE = 'files_directories';
const EVERYTHING_TYPE = 'all';
const ALL_TYPES = [
    FILE_TYPE,
    DIR_TYPE,
    FILE_DIR_TYPE,
    EVERYTHING_TYPE
];
const isNormalFlowError = (error)=>NORMAL_FLOW_ERRORS.has(error.code);
const [maj, min] = process.versions.node.split('.').slice(0, 2).map((n)=>Number.parseInt(n, 10));
const wantBigintFsStats = process.platform === 'win32' && (maj > 10 || maj === 10 && min >= 5);
const normalizeFilter = (filter)=>{
    if (filter === undefined) return;
    if (typeof filter === 'function') return filter;
    if (typeof filter === 'string') {
        const glob = picomatch(filter.trim());
        return (entry)=>glob(entry.basename);
    }
    if (Array.isArray(filter)) {
        const positive = [];
        const negative = [];
        for (const item of filter){
            const trimmed = item.trim();
            if (trimmed.charAt(0) === BANG) {
                negative.push(picomatch(trimmed.slice(1)));
            } else {
                positive.push(picomatch(trimmed));
            }
        }
        if (negative.length > 0) {
            if (positive.length > 0) {
                return (entry)=>positive.some((f)=>f(entry.basename)) && !negative.some((f)=>f(entry.basename));
            }
            return (entry)=>!negative.some((f)=>f(entry.basename));
        }
        return (entry)=>positive.some((f)=>f(entry.basename));
    }
};
class ReaddirpStream extends Readable {
    static get defaultOptions() {
        return {
            root: '.',
            /* eslint-disable no-unused-vars */ fileFilter: (path)=>true,
            directoryFilter: (path)=>true,
            /* eslint-enable no-unused-vars */ type: FILE_TYPE,
            lstat: false,
            depth: 2147483648,
            alwaysStat: false
        };
    }
    constructor(options = {}){
        super({
            objectMode: true,
            autoDestroy: true,
            highWaterMark: options.highWaterMark || 4096
        });
        const opts = {
            ...ReaddirpStream.defaultOptions,
            ...options
        };
        const { root, type } = opts;
        this._fileFilter = normalizeFilter(opts.fileFilter);
        this._directoryFilter = normalizeFilter(opts.directoryFilter);
        const statMethod = opts.lstat ? lstat : stat;
        // Use bigint stats if it's windows and stat() supports options (node 10+).
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        else {
            this._stat = statMethod;
        }
        this._maxDepth = opts.depth;
        this._wantsDir = [
            DIR_TYPE,
            FILE_DIR_TYPE,
            EVERYTHING_TYPE
        ].includes(type);
        this._wantsFile = [
            FILE_TYPE,
            FILE_DIR_TYPE,
            EVERYTHING_TYPE
        ].includes(type);
        this._wantsEverything = type === EVERYTHING_TYPE;
        this._root = sysPath.resolve(root);
        this._isDirent = 'Dirent' in fs && !opts.alwaysStat;
        this._statsProp = this._isDirent ? 'dirent' : 'stats';
        this._rdOptions = {
            encoding: 'utf8',
            withFileTypes: this._isDirent
        };
        // Launch stream with one parent, the root dir.
        this.parents = [
            this._exploreDir(root, 1)
        ];
        this.reading = false;
        this.parent = undefined;
    }
    async _read(batch) {
        if (this.reading) return;
        this.reading = true;
        try {
            while(!this.destroyed && batch > 0){
                const { path, depth, files = [] } = this.parent || {};
                if (files.length > 0) {
                    const slice = files.splice(0, batch).map((dirent)=>this._formatEntry(dirent, path));
                    for (const entry of (await Promise.all(slice))){
                        if (this.destroyed) return;
                        const entryType = await this._getEntryType(entry);
                        if (entryType === 'directory' && this._directoryFilter(entry)) {
                            if (depth <= this._maxDepth) {
                                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));
                            }
                            if (this._wantsDir) {
                                this.push(entry);
                                batch--;
                            }
                        } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {
                            if (this._wantsFile) {
                                this.push(entry);
                                batch--;
                            }
                        }
                    }
                } else {
                    const parent = this.parents.pop();
                    if (!parent) {
                        this.push(null);
                        break;
                    }
                    this.parent = await parent;
                    if (this.destroyed) return;
                }
            }
        } catch (error) {
            this.destroy(error);
        } finally{
            this.reading = false;
        }
    }
    async _exploreDir(path, depth) {
        let files;
        try {
            files = await readdir(path, this._rdOptions);
        } catch (error) {
            this._onError(error);
        }
        return {
            files,
            depth,
            path
        };
    }
    async _formatEntry(dirent, path) {
        let entry;
        try {
            const basename = this._isDirent ? dirent.name : dirent;
            const fullPath = sysPath.resolve(sysPath.join(path, basename));
            entry = {
                path: sysPath.relative(this._root, fullPath),
                fullPath,
                basename
            };
            entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
        } catch (err) {
            this._onError(err);
        }
        return entry;
    }
    _onError(err) {
        if (isNormalFlowError(err) && !this.destroyed) {
            this.emit('warn', err);
        } else {
            this.destroy(err);
        }
    }
    async _getEntryType(entry) {
        // entry may be undefined, because a warning or an error were emitted
        // and the statsProp is undefined
        const stats = entry && entry[this._statsProp];
        if (!stats) {
            return;
        }
        if (stats.isFile()) {
            return 'file';
        }
        if (stats.isDirectory()) {
            return 'directory';
        }
        if (stats && stats.isSymbolicLink()) {
            const full = entry.fullPath;
            try {
                const entryRealPath = await realpath(full);
                const entryRealPathStats = await lstat(entryRealPath);
                if (entryRealPathStats.isFile()) {
                    return 'file';
                }
                if (entryRealPathStats.isDirectory()) {
                    const len = entryRealPath.length;
                    if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {
                        const recursiveError = new Error(`Circular symlink detected: "${full}" points to "${entryRealPath}"`);
                        recursiveError.code = RECURSIVE_ERROR_CODE;
                        return this._onError(recursiveError);
                    }
                    return 'directory';
                }
            } catch (error) {
                this._onError(error);
            }
        }
    }
    _includeAsFile(entry) {
        const stats = entry && entry[this._statsProp];
        return stats && this._wantsEverything && !stats.isDirectory();
    }
}
/**
 * @typedef {Object} ReaddirpArguments
 * @property {Function=} fileFilter
 * @property {Function=} directoryFilter
 * @property {String=} type
 * @property {Number=} depth
 * @property {String=} root
 * @property {Boolean=} lstat
 * @property {Boolean=} bigint
 */ /**
 * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.
 * @param {String} root Root directory
 * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth
 */ const readdirp = (root, options = {})=>{
    let type = options.entryType || options.type;
    if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility
    if (type) options.type = type;
    if (!root) {
        throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');
    } else if (typeof root !== 'string') {
        throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');
    } else if (type && !ALL_TYPES.includes(type)) {
        throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);
    }
    options.root = root;
    return new ReaddirpStream(options);
};
const readdirpPromise = (root, options = {})=>{
    return new Promise((resolve, reject)=>{
        const files = [];
        readdirp(root, options).on('data', (entry)=>files.push(entry)).on('end', ()=>resolve(files)).on('error', (error)=>reject(error));
    });
};
readdirp.promise = readdirpPromise;
readdirp.ReaddirpStream = ReaddirpStream;
readdirp.default = readdirp;
module.exports = readdirp;
}),
"[project]/align/node_modules/normalize-path/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */ module.exports = function(path, stripTrailing) {
    if (typeof path !== 'string') {
        throw new TypeError('expected path to be a string');
    }
    if (path === '\\' || path === '/') return '/';
    var len = path.length;
    if (len <= 1) return path;
    // ensure that win32 namespaces has two leading slashes, so that the path is
    // handled properly by the win32 version of path.parse() after being normalized
    // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces
    var prefix = '';
    if (len > 4 && path[3] === '\\') {
        var ch = path[2];
        if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\') {
            path = path.slice(2);
            prefix = '//';
        }
    }
    var segs = path.split(/[/\\]+/);
    if (stripTrailing !== false && segs[segs.length - 1] === '') {
        segs.pop();
    }
    return prefix + segs.join('/');
};
}),
"[project]/align/node_modules/anymatch/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
const picomatch = __turbopack_context__.r("[project]/align/node_modules/picomatch/index.js [app-route] (ecmascript)");
const normalizePath = __turbopack_context__.r("[project]/align/node_modules/normalize-path/index.js [app-route] (ecmascript)");
/**
 * @typedef {(testString: string) => boolean} AnymatchFn
 * @typedef {string|RegExp|AnymatchFn} AnymatchPattern
 * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher
 */ const BANG = '!';
const DEFAULT_OPTIONS = {
    returnIndex: false
};
const arrify = (item)=>Array.isArray(item) ? item : [
        item
    ];
/**
 * @param {AnymatchPattern} matcher
 * @param {object} options
 * @returns {AnymatchFn}
 */ const createPattern = (matcher, options)=>{
    if (typeof matcher === 'function') {
        return matcher;
    }
    if (typeof matcher === 'string') {
        const glob = picomatch(matcher, options);
        return (string)=>matcher === string || glob(string);
    }
    if (matcher instanceof RegExp) {
        return (string)=>matcher.test(string);
    }
    return (string)=>false;
};
/**
 * @param {Array<Function>} patterns
 * @param {Array<Function>} negPatterns
 * @param {String|Array} args
 * @param {Boolean} returnIndex
 * @returns {boolean|number}
 */ const matchPatterns = (patterns, negPatterns, args, returnIndex)=>{
    const isList = Array.isArray(args);
    const _path = isList ? args[0] : args;
    if (!isList && typeof _path !== 'string') {
        throw new TypeError('anymatch: second argument must be a string: got ' + Object.prototype.toString.call(_path));
    }
    const path = normalizePath(_path, false);
    for(let index = 0; index < negPatterns.length; index++){
        const nglob = negPatterns[index];
        if (nglob(path)) {
            return returnIndex ? -1 : false;
        }
    }
    const applied = isList && [
        path
    ].concat(args.slice(1));
    for(let index = 0; index < patterns.length; index++){
        const pattern = patterns[index];
        if (isList ? pattern(...applied) : pattern(path)) {
            return returnIndex ? index : true;
        }
    }
    return returnIndex ? -1 : false;
};
/**
 * @param {AnymatchMatcher} matchers
 * @param {Array|string} testString
 * @param {object} options
 * @returns {boolean|number|Function}
 */ const anymatch = (matchers, testString, options = DEFAULT_OPTIONS)=>{
    if (matchers == null) {
        throw new TypeError('anymatch: specify first argument');
    }
    const opts = typeof options === 'boolean' ? {
        returnIndex: options
    } : options;
    const returnIndex = opts.returnIndex || false;
    // Early cache for matchers.
    const mtchers = arrify(matchers);
    const negatedGlobs = mtchers.filter((item)=>typeof item === 'string' && item.charAt(0) === BANG).map((item)=>item.slice(1)).map((item)=>picomatch(item, opts));
    const patterns = mtchers.filter((item)=>typeof item !== 'string' || typeof item === 'string' && item.charAt(0) !== BANG).map((matcher)=>createPattern(matcher, opts));
    if (testString == null) {
        return (testString, ri = false)=>{
            const returnIndex = typeof ri === 'boolean' ? ri : false;
            return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
        };
    }
    return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
};
anymatch.default = anymatch;
module.exports = anymatch;
}),
"[project]/align/node_modules/is-extglob/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */ module.exports = function isExtglob(str) {
    if (typeof str !== 'string' || str === '') {
        return false;
    }
    var match;
    while(match = /(\\).|([@?!+*]\(.*\))/g.exec(str)){
        if (match[2]) return true;
        str = str.slice(match.index + match[0].length);
    }
    return false;
};
}),
"[project]/align/node_modules/is-glob/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */ var isExtglob = __turbopack_context__.r("[project]/align/node_modules/is-extglob/index.js [app-route] (ecmascript)");
var chars = {
    '{': '}',
    '(': ')',
    '[': ']'
};
var strictCheck = function(str) {
    if (str[0] === '!') {
        return true;
    }
    var index = 0;
    var pipeIndex = -2;
    var closeSquareIndex = -2;
    var closeCurlyIndex = -2;
    var closeParenIndex = -2;
    var backSlashIndex = -2;
    while(index < str.length){
        if (str[index] === '*') {
            return true;
        }
        if (str[index + 1] === '?' && /[\].+)]/.test(str[index])) {
            return true;
        }
        if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {
            if (closeSquareIndex < index) {
                closeSquareIndex = str.indexOf(']', index);
            }
            if (closeSquareIndex > index) {
                if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
                    return true;
                }
                backSlashIndex = str.indexOf('\\', index);
                if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
                    return true;
                }
            }
        }
        if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {
            closeCurlyIndex = str.indexOf('}', index);
            if (closeCurlyIndex > index) {
                backSlashIndex = str.indexOf('\\', index);
                if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
                    return true;
                }
            }
        }
        if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {
            closeParenIndex = str.indexOf(')', index);
            if (closeParenIndex > index) {
                backSlashIndex = str.indexOf('\\', index);
                if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                    return true;
                }
            }
        }
        if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {
            if (pipeIndex < index) {
                pipeIndex = str.indexOf('|', index);
            }
            if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {
                closeParenIndex = str.indexOf(')', pipeIndex);
                if (closeParenIndex > pipeIndex) {
                    backSlashIndex = str.indexOf('\\', pipeIndex);
                    if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                        return true;
                    }
                }
            }
        }
        if (str[index] === '\\') {
            var open = str[index + 1];
            index += 2;
            var close = chars[open];
            if (close) {
                var n = str.indexOf(close, index);
                if (n !== -1) {
                    index = n + 1;
                }
            }
            if (str[index] === '!') {
                return true;
            }
        } else {
            index++;
        }
    }
    return false;
};
var relaxedCheck = function(str) {
    if (str[0] === '!') {
        return true;
    }
    var index = 0;
    while(index < str.length){
        if (/[*?{}()[\]]/.test(str[index])) {
            return true;
        }
        if (str[index] === '\\') {
            var open = str[index + 1];
            index += 2;
            var close = chars[open];
            if (close) {
                var n = str.indexOf(close, index);
                if (n !== -1) {
                    index = n + 1;
                }
            }
            if (str[index] === '!') {
                return true;
            }
        } else {
            index++;
        }
    }
    return false;
};
module.exports = function isGlob(str, options) {
    if (typeof str !== 'string' || str === '') {
        return false;
    }
    if (isExtglob(str)) {
        return true;
    }
    var check = strictCheck;
    // optionally relax check
    if (options && options.strict === false) {
        check = relaxedCheck;
    }
    return check(str);
};
}),
"[project]/align/node_modules/chokidar/node_modules/glob-parent/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isGlob = __turbopack_context__.r("[project]/align/node_modules/is-glob/index.js [app-route] (ecmascript)");
var pathPosixDirname = __turbopack_context__.r("[externals]/path [external] (path, cjs)").posix.dirname;
var isWin32 = __turbopack_context__.r("[externals]/os [external] (os, cjs)").platform() === 'win32';
var slash = '/';
var backslash = /\\/g;
var enclosure = /[\{\[].*[\}\]]$/;
var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
/**
 * @param {string} str
 * @param {Object} opts
 * @param {boolean} [opts.flipBackslashes=true]
 * @returns {string}
 */ module.exports = function globParent(str, opts) {
    var options = Object.assign({
        flipBackslashes: true
    }, opts);
    // flip windows path separators
    if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) //TURBOPACK unreachable
    ;
    // special case for strings ending in enclosure containing path separator
    if (enclosure.test(str)) {
        str += slash;
    }
    // preserves full path in case of trailing path separator
    str += 'a';
    // remove path parts that are globby
    do {
        str = pathPosixDirname(str);
    }while (isGlob(str) || globby.test(str))
    // remove escape chars and return result
    return str.replace(escaped, '$1');
};
}),
"[project]/align/node_modules/chokidar/lib/constants.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { sep } = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const { platform } = process;
const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
exports.EV_ALL = 'all';
exports.EV_READY = 'ready';
exports.EV_ADD = 'add';
exports.EV_CHANGE = 'change';
exports.EV_ADD_DIR = 'addDir';
exports.EV_UNLINK = 'unlink';
exports.EV_UNLINK_DIR = 'unlinkDir';
exports.EV_RAW = 'raw';
exports.EV_ERROR = 'error';
exports.STR_DATA = 'data';
exports.STR_END = 'end';
exports.STR_CLOSE = 'close';
exports.FSEVENT_CREATED = 'created';
exports.FSEVENT_MODIFIED = 'modified';
exports.FSEVENT_DELETED = 'deleted';
exports.FSEVENT_MOVED = 'moved';
exports.FSEVENT_CLONED = 'cloned';
exports.FSEVENT_UNKNOWN = 'unknown';
exports.FSEVENT_FLAG_MUST_SCAN_SUBDIRS = 1;
exports.FSEVENT_TYPE_FILE = 'file';
exports.FSEVENT_TYPE_DIRECTORY = 'directory';
exports.FSEVENT_TYPE_SYMLINK = 'symlink';
exports.KEY_LISTENERS = 'listeners';
exports.KEY_ERR = 'errHandlers';
exports.KEY_RAW = 'rawEmitters';
exports.HANDLER_KEYS = [
    exports.KEY_LISTENERS,
    exports.KEY_ERR,
    exports.KEY_RAW
];
exports.DOT_SLASH = `.${sep}`;
exports.BACK_SLASH_RE = /\\/g;
exports.DOUBLE_SLASH_RE = /\/\//;
exports.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
exports.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
exports.REPLACER_RE = /^\.[/\\]/;
exports.SLASH = '/';
exports.SLASH_SLASH = '//';
exports.BRACE_START = '{';
exports.BANG = '!';
exports.ONE_DOT = '.';
exports.TWO_DOTS = '..';
exports.STAR = '*';
exports.GLOBSTAR = '**';
exports.ROOT_GLOBSTAR = '/**/*';
exports.SLASH_GLOBSTAR = '/**';
exports.DIR_SUFFIX = 'Dir';
exports.ANYMATCH_OPTS = {
    dot: true
};
exports.STRING_TYPE = 'string';
exports.FUNCTION_TYPE = 'function';
exports.EMPTY_STR = '';
exports.EMPTY_FN = ()=>{};
exports.IDENTITY_FN = (val)=>val;
exports.isWindows = platform === 'win32';
exports.isMacos = platform === 'darwin';
exports.isLinux = platform === 'linux';
exports.isIBMi = os.type() === 'OS400';
}),
"[project]/align/node_modules/chokidar/lib/nodefs-handler.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const sysPath = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const { promisify } = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const isBinaryPath = __turbopack_context__.r("[project]/align/node_modules/is-binary-path/index.js [app-route] (ecmascript)");
const { isWindows, isLinux, EMPTY_FN, EMPTY_STR, KEY_LISTENERS, KEY_ERR, KEY_RAW, HANDLER_KEYS, EV_CHANGE, EV_ADD, EV_ADD_DIR, EV_ERROR, STR_DATA, STR_END, BRACE_START, STAR } = __turbopack_context__.r("[project]/align/node_modules/chokidar/lib/constants.js [app-route] (ecmascript)");
const THROTTLE_MODE_WATCH = 'watch';
const open = promisify(fs.open);
const stat = promisify(fs.stat);
const lstat = promisify(fs.lstat);
const close = promisify(fs.close);
const fsrealpath = promisify(fs.realpath);
const statMethods = {
    lstat,
    stat
};
// TODO: emit errors properly. Example: EMFILE on Macos.
const foreach = (val, fn)=>{
    if (val instanceof Set) {
        val.forEach(fn);
    } else {
        fn(val);
    }
};
const addAndConvert = (main, prop, item)=>{
    let container = main[prop];
    if (!(container instanceof Set)) {
        main[prop] = container = new Set([
            container
        ]);
    }
    container.add(item);
};
const clearItem = (cont)=>(key)=>{
        const set = cont[key];
        if (set instanceof Set) {
            set.clear();
        } else {
            delete cont[key];
        }
    };
const delFromSet = (main, prop, item)=>{
    const container = main[prop];
    if (container instanceof Set) {
        container.delete(item);
    } else if (container === item) {
        delete main[prop];
    }
};
const isEmptySet = (val)=>val instanceof Set ? val.size === 0 : !val;
/**
 * @typedef {String} Path
 */ // fs_watch helpers
// object to hold per-process fs_watch instances
// (may be shared across chokidar FSWatcher instances)
/**
 * @typedef {Object} FsWatchContainer
 * @property {Set} listeners
 * @property {Set} errHandlers
 * @property {Set} rawEmitters
 * @property {fs.FSWatcher=} watcher
 * @property {Boolean=} watcherUnusable
 */ /**
 * @type {Map<String,FsWatchContainer>}
 */ const FsWatchInstances = new Map();
/**
 * Instantiates the fs_watch interface
 * @param {String} path to be watched
 * @param {Object} options to be passed to fs_watch
 * @param {Function} listener main event handler
 * @param {Function} errHandler emits info about errors
 * @param {Function} emitRaw emits raw event data
 * @returns {fs.FSWatcher} new fsevents instance
 */ function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
    const handleEvent = (rawEvent, evPath)=>{
        listener(path);
        emitRaw(rawEvent, evPath, {
            watchedPath: path
        });
        // emit based on events occurring for files from a directory's watcher in
        // case the file's watcher misses it (and rely on throttling to de-dupe)
        if (evPath && path !== evPath) {
            fsWatchBroadcast(sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath));
        }
    };
    try {
        return fs.watch(path, options, handleEvent);
    } catch (error) {
        errHandler(error);
    }
}
/**
 * Helper for passing fs_watch event data to a collection of listeners
 * @param {Path} fullPath absolute path bound to fs_watch instance
 * @param {String} type listener type
 * @param {*=} val1 arguments to be passed to listeners
 * @param {*=} val2
 * @param {*=} val3
 */ const fsWatchBroadcast = (fullPath, type, val1, val2, val3)=>{
    const cont = FsWatchInstances.get(fullPath);
    if (!cont) return;
    foreach(cont[type], (listener)=>{
        listener(val1, val2, val3);
    });
};
/**
 * Instantiates the fs_watch interface or binds listeners
 * to an existing one covering the same file system entry
 * @param {String} path
 * @param {String} fullPath absolute path
 * @param {Object} options to be passed to fs_watch
 * @param {Object} handlers container for event listener functions
 */ const setFsWatchListener = (path, fullPath, options, handlers)=>{
    const { listener, errHandler, rawEmitter } = handlers;
    let cont = FsWatchInstances.get(fullPath);
    /** @type {fs.FSWatcher=} */ let watcher;
    if (!options.persistent) {
        watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);
        return watcher.close.bind(watcher);
    }
    if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener);
        addAndConvert(cont, KEY_ERR, errHandler);
        addAndConvert(cont, KEY_RAW, rawEmitter);
    } else {
        watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, fsWatchBroadcast.bind(null, fullPath, KEY_RAW));
        if (!watcher) return;
        watcher.on(EV_ERROR, async (error)=>{
            const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
            cont.watcherUnusable = true; // documented since Node 10.4.1
            // Workaround for https://github.com/joyent/node/issues/4337
            if (isWindows && error.code === 'EPERM') {
                try {
                    const fd = await open(path, 'r');
                    await close(fd);
                    broadcastErr(error);
                } catch (err) {}
            } else {
                broadcastErr(error);
            }
        });
        cont = {
            listeners: listener,
            errHandlers: errHandler,
            rawEmitters: rawEmitter,
            watcher
        };
        FsWatchInstances.set(fullPath, cont);
    }
    // const index = cont.listeners.indexOf(listener);
    // removes this instance's listeners and closes the underlying fs_watch
    // instance if there are no more listeners left
    return ()=>{
        delFromSet(cont, KEY_LISTENERS, listener);
        delFromSet(cont, KEY_ERR, errHandler);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
            // Check to protect against issue gh-730.
            // if (cont.watcherUnusable) {
            cont.watcher.close();
            // }
            FsWatchInstances.delete(fullPath);
            HANDLER_KEYS.forEach(clearItem(cont));
            cont.watcher = undefined;
            Object.freeze(cont);
        }
    };
};
// fs_watchFile helpers
// object to hold per-process fs_watchFile instances
// (may be shared across chokidar FSWatcher instances)
const FsWatchFileInstances = new Map();
/**
 * Instantiates the fs_watchFile interface or binds listeners
 * to an existing one covering the same file system entry
 * @param {String} path to be watched
 * @param {String} fullPath absolute path
 * @param {Object} options options to be passed to fs_watchFile
 * @param {Object} handlers container for event listener functions
 * @returns {Function} closer
 */ const setFsWatchFileListener = (path, fullPath, options, handlers)=>{
    const { listener, rawEmitter } = handlers;
    let cont = FsWatchFileInstances.get(fullPath);
    /* eslint-disable no-unused-vars, prefer-destructuring */ let listeners = new Set();
    let rawEmitters = new Set();
    const copts = cont && cont.options;
    if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
        // "Upgrade" the watcher to persistence or a quicker interval.
        // This creates some unlikely edge case issues if the user mixes
        // settings in a very weird way, but solving for those cases
        // doesn't seem worthwhile for the added complexity.
        listeners = cont.listeners;
        rawEmitters = cont.rawEmitters;
        fs.unwatchFile(fullPath);
        cont = undefined;
    }
    /* eslint-enable no-unused-vars, prefer-destructuring */ if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener);
        addAndConvert(cont, KEY_RAW, rawEmitter);
    } else {
        // TODO
        // listeners.add(listener);
        // rawEmitters.add(rawEmitter);
        cont = {
            listeners: listener,
            rawEmitters: rawEmitter,
            options,
            watcher: fs.watchFile(fullPath, options, (curr, prev)=>{
                foreach(cont.rawEmitters, (rawEmitter)=>{
                    rawEmitter(EV_CHANGE, fullPath, {
                        curr,
                        prev
                    });
                });
                const currmtime = curr.mtimeMs;
                if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
                    foreach(cont.listeners, (listener)=>listener(path, curr));
                }
            })
        };
        FsWatchFileInstances.set(fullPath, cont);
    }
    // const index = cont.listeners.indexOf(listener);
    // Removes this instance's listeners and closes the underlying fs_watchFile
    // instance if there are no more listeners left.
    return ()=>{
        delFromSet(cont, KEY_LISTENERS, listener);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
            FsWatchFileInstances.delete(fullPath);
            fs.unwatchFile(fullPath);
            cont.options = cont.watcher = undefined;
            Object.freeze(cont);
        }
    };
};
/**
 * @mixin
 */ class NodeFsHandler {
    /**
 * @param {import("../index").FSWatcher} fsW
 */ constructor(fsW){
        this.fsw = fsW;
        this._boundHandleError = (error)=>fsW._handleError(error);
    }
    /**
 * Watch file for changes with fs_watchFile or fs_watch.
 * @param {String} path to file or dir
 * @param {Function} listener on fs change
 * @returns {Function} closer for the watcher instance
 */ _watchWithNodeFs(path, listener) {
        const opts = this.fsw.options;
        const directory = sysPath.dirname(path);
        const basename = sysPath.basename(path);
        const parent = this.fsw._getWatchedDir(directory);
        parent.add(basename);
        const absolutePath = sysPath.resolve(path);
        const options = {
            persistent: opts.persistent
        };
        if (!listener) listener = EMPTY_FN;
        let closer;
        if (opts.usePolling) {
            options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;
            closer = setFsWatchFileListener(path, absolutePath, options, {
                listener,
                rawEmitter: this.fsw._emitRaw
            });
        } else {
            closer = setFsWatchListener(path, absolutePath, options, {
                listener,
                errHandler: this._boundHandleError,
                rawEmitter: this.fsw._emitRaw
            });
        }
        return closer;
    }
    /**
 * Watch a file and emit add event if warranted.
 * @param {Path} file Path
 * @param {fs.Stats} stats result of fs_stat
 * @param {Boolean} initialAdd was the file added at watch instantiation?
 * @returns {Function} closer for the watcher instance
 */ _handleFile(file, stats, initialAdd) {
        if (this.fsw.closed) {
            return;
        }
        const dirname = sysPath.dirname(file);
        const basename = sysPath.basename(file);
        const parent = this.fsw._getWatchedDir(dirname);
        // stats is always present
        let prevStats = stats;
        // if the file is already being watched, do nothing
        if (parent.has(basename)) return;
        const listener = async (path, newStats)=>{
            if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;
            if (!newStats || newStats.mtimeMs === 0) {
                try {
                    const newStats = await stat(file);
                    if (this.fsw.closed) return;
                    // Check that change event was not fired because of changed only accessTime.
                    const at = newStats.atimeMs;
                    const mt = newStats.mtimeMs;
                    if (!at || at <= mt || mt !== prevStats.mtimeMs) {
                        this.fsw._emit(EV_CHANGE, file, newStats);
                    }
                    if (isLinux && prevStats.ino !== newStats.ino) {
                        this.fsw._closeFile(path);
                        prevStats = newStats;
                        this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));
                    } else {
                        prevStats = newStats;
                    }
                } catch (error) {
                    // Fix issues where mtime is null but file is still present
                    this.fsw._remove(dirname, basename);
                }
            // add is about to be emitted if file not already tracked in parent
            } else if (parent.has(basename)) {
                // Check that change event was not fired because of changed only accessTime.
                const at = newStats.atimeMs;
                const mt = newStats.mtimeMs;
                if (!at || at <= mt || mt !== prevStats.mtimeMs) {
                    this.fsw._emit(EV_CHANGE, file, newStats);
                }
                prevStats = newStats;
            }
        };
        // kick off the watcher
        const closer = this._watchWithNodeFs(file, listener);
        // emit an add event if we're supposed to
        if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
            if (!this.fsw._throttle(EV_ADD, file, 0)) return;
            this.fsw._emit(EV_ADD, file, stats);
        }
        return closer;
    }
    /**
 * Handle symlinks encountered while reading a dir.
 * @param {Object} entry returned by readdirp
 * @param {String} directory path of dir being read
 * @param {String} path of this item
 * @param {String} item basename of this item
 * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
 */ async _handleSymlink(entry, directory, path, item) {
        if (this.fsw.closed) {
            return;
        }
        const full = entry.fullPath;
        const dir = this.fsw._getWatchedDir(directory);
        if (!this.fsw.options.followSymlinks) {
            // watch symlink directly (don't follow) and detect changes
            this.fsw._incrReadyCount();
            let linkPath;
            try {
                linkPath = await fsrealpath(path);
            } catch (e) {
                this.fsw._emitReady();
                return true;
            }
            if (this.fsw.closed) return;
            if (dir.has(item)) {
                if (this.fsw._symlinkPaths.get(full) !== linkPath) {
                    this.fsw._symlinkPaths.set(full, linkPath);
                    this.fsw._emit(EV_CHANGE, path, entry.stats);
                }
            } else {
                dir.add(item);
                this.fsw._symlinkPaths.set(full, linkPath);
                this.fsw._emit(EV_ADD, path, entry.stats);
            }
            this.fsw._emitReady();
            return true;
        }
        // don't follow the same symlink more than once
        if (this.fsw._symlinkPaths.has(full)) {
            return true;
        }
        this.fsw._symlinkPaths.set(full, true);
    }
    _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
        // Normalize the directory name on Windows
        directory = sysPath.join(directory, EMPTY_STR);
        if (!wh.hasGlob) {
            throttler = this.fsw._throttle('readdir', directory, 1000);
            if (!throttler) return;
        }
        const previous = this.fsw._getWatchedDir(wh.path);
        const current = new Set();
        let stream = this.fsw._readdirp(directory, {
            fileFilter: (entry)=>wh.filterPath(entry),
            directoryFilter: (entry)=>wh.filterDir(entry),
            depth: 0
        }).on(STR_DATA, async (entry)=>{
            if (this.fsw.closed) {
                stream = undefined;
                return;
            }
            const item = entry.path;
            let path = sysPath.join(directory, item);
            current.add(item);
            if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {
                return;
            }
            if (this.fsw.closed) {
                stream = undefined;
                return;
            }
            // Files that present in current directory snapshot
            // but absent in previous are added to watch list and
            // emit `add` event.
            if (item === target || !target && !previous.has(item)) {
                this.fsw._incrReadyCount();
                // ensure relativeness of path is preserved in case of watcher reuse
                path = sysPath.join(dir, sysPath.relative(dir, path));
                this._addToNodeFs(path, initialAdd, wh, depth + 1);
            }
        }).on(EV_ERROR, this._boundHandleError);
        return new Promise((resolve)=>stream.once(STR_END, ()=>{
                if (this.fsw.closed) {
                    stream = undefined;
                    return;
                }
                const wasThrottled = throttler ? throttler.clear() : false;
                resolve();
                // Files that absent in current directory snapshot
                // but present in previous emit `remove` event
                // and are removed from @watched[directory].
                previous.getChildren().filter((item)=>{
                    return item !== directory && !current.has(item) && // in case of intersecting globs;
                    // a path may have been filtered out of this readdir, but
                    // shouldn't be removed because it matches a different glob
                    (!wh.hasGlob || wh.filterPath({
                        fullPath: sysPath.resolve(directory, item)
                    }));
                }).forEach((item)=>{
                    this.fsw._remove(directory, item);
                });
                stream = undefined;
                // one more time for any missed in case changes came in extremely quickly
                if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);
            }));
    }
    /**
 * Read directory to add / remove files from `@watched` list and re-read it on change.
 * @param {String} dir fs path
 * @param {fs.Stats} stats
 * @param {Boolean} initialAdd
 * @param {Number} depth relative to user-supplied path
 * @param {String} target child path targeted for watch
 * @param {Object} wh Common watch helpers for this path
 * @param {String} realpath
 * @returns {Promise<Function>} closer for the watcher instance.
 */ async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {
        const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));
        const tracked = parentDir.has(sysPath.basename(dir));
        if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
            if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);
        }
        // ensure dir is tracked (harmless if redundant)
        parentDir.add(sysPath.basename(dir));
        this.fsw._getWatchedDir(dir);
        let throttler;
        let closer;
        const oDepth = this.fsw.options.depth;
        if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {
            if (!target) {
                await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);
                if (this.fsw.closed) return;
            }
            closer = this._watchWithNodeFs(dir, (dirPath, stats)=>{
                // if current directory is removed, do nothing
                if (stats && stats.mtimeMs === 0) return;
                this._handleRead(dirPath, false, wh, target, dir, depth, throttler);
            });
        }
        return closer;
    }
    /**
 * Handle added file, directory, or glob pattern.
 * Delegates call to _handleFile / _handleDir after checks.
 * @param {String} path to file or ir
 * @param {Boolean} initialAdd was the file added at watch instantiation?
 * @param {Object} priorWh depth relative to user-supplied path
 * @param {Number} depth Child path actually targeted for watch
 * @param {String=} target Child path actually targeted for watch
 * @returns {Promise}
 */ async _addToNodeFs(path, initialAdd, priorWh, depth, target) {
        const ready = this.fsw._emitReady;
        if (this.fsw._isIgnored(path) || this.fsw.closed) {
            ready();
            return false;
        }
        const wh = this.fsw._getWatchHelpers(path, depth);
        if (!wh.hasGlob && priorWh) {
            wh.hasGlob = priorWh.hasGlob;
            wh.globFilter = priorWh.globFilter;
            wh.filterPath = (entry)=>priorWh.filterPath(entry);
            wh.filterDir = (entry)=>priorWh.filterDir(entry);
        }
        // evaluate what is at the path we're being asked to watch
        try {
            const stats = await statMethods[wh.statMethod](wh.watchPath);
            if (this.fsw.closed) return;
            if (this.fsw._isIgnored(wh.watchPath, stats)) {
                ready();
                return false;
            }
            const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);
            let closer;
            if (stats.isDirectory()) {
                const absPath = sysPath.resolve(path);
                const targetPath = follow ? await fsrealpath(path) : path;
                if (this.fsw.closed) return;
                closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);
                if (this.fsw.closed) return;
                // preserve this symlink's target path
                if (absPath !== targetPath && targetPath !== undefined) {
                    this.fsw._symlinkPaths.set(absPath, targetPath);
                }
            } else if (stats.isSymbolicLink()) {
                const targetPath = follow ? await fsrealpath(path) : path;
                if (this.fsw.closed) return;
                const parent = sysPath.dirname(wh.watchPath);
                this.fsw._getWatchedDir(parent).add(wh.watchPath);
                this.fsw._emit(EV_ADD, wh.watchPath, stats);
                closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);
                if (this.fsw.closed) return;
                // preserve this symlink's target path
                if (targetPath !== undefined) {
                    this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);
                }
            } else {
                closer = this._handleFile(wh.watchPath, stats, initialAdd);
            }
            ready();
            this.fsw._addPathCloser(path, closer);
            return false;
        } catch (error) {
            if (this.fsw._handleError(error)) {
                ready();
                return path;
            }
        }
    }
}
module.exports = NodeFsHandler;
}),
"[project]/align/node_modules/chokidar/lib/fsevents-handler.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const sysPath = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const { promisify } = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
let fsevents;
try {
    fsevents = __turbopack_context__.r("[project]/align/node_modules/fsevents/fsevents.js [app-route] (ecmascript)");
} catch (error) {
    if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);
}
if (fsevents) {
    // TODO: real check
    const mtch = process.version.match(/v(\d+)\.(\d+)/);
    if (mtch && mtch[1] && mtch[2]) {
        const maj = Number.parseInt(mtch[1], 10);
        const min = Number.parseInt(mtch[2], 10);
        if (maj === 8 && min < 16) {
            fsevents = undefined;
        }
    }
}
const { EV_ADD, EV_CHANGE, EV_ADD_DIR, EV_UNLINK, EV_ERROR, STR_DATA, STR_END, FSEVENT_CREATED, FSEVENT_MODIFIED, FSEVENT_DELETED, FSEVENT_MOVED, // FSEVENT_CLONED,
FSEVENT_UNKNOWN, FSEVENT_FLAG_MUST_SCAN_SUBDIRS, FSEVENT_TYPE_FILE, FSEVENT_TYPE_DIRECTORY, FSEVENT_TYPE_SYMLINK, ROOT_GLOBSTAR, DIR_SUFFIX, DOT_SLASH, FUNCTION_TYPE, EMPTY_FN, IDENTITY_FN } = __turbopack_context__.r("[project]/align/node_modules/chokidar/lib/constants.js [app-route] (ecmascript)");
const Depth = (value)=>isNaN(value) ? {} : {
        depth: value
    };
const stat = promisify(fs.stat);
const lstat = promisify(fs.lstat);
const realpath = promisify(fs.realpath);
const statMethods = {
    stat,
    lstat
};
/**
 * @typedef {String} Path
 */ /**
 * @typedef {Object} FsEventsWatchContainer
 * @property {Set<Function>} listeners
 * @property {Function} rawEmitter
 * @property {{stop: Function}} watcher
 */ // fsevents instance helper functions
/**
 * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)
 * @type {Map<Path,FsEventsWatchContainer>}
 */ const FSEventsWatchers = new Map();
// Threshold of duplicate path prefixes at which to start
// consolidating going forward
const consolidateThreshhold = 10;
const wrongEventFlags = new Set([
    69888,
    70400,
    71424,
    72704,
    73472,
    131328,
    131840,
    262912
]);
/**
 * Instantiates the fsevents interface
 * @param {Path} path path to be watched
 * @param {Function} callback called when fsevents is bound and ready
 * @returns {{stop: Function}} new fsevents instance
 */ const createFSEventsInstance = (path, callback)=>{
    const stop = fsevents.watch(path, callback);
    return {
        stop
    };
};
/**
 * Instantiates the fsevents interface or binds listeners to an existing one covering
 * the same file tree.
 * @param {Path} path           - to be watched
 * @param {Path} realPath       - real path for symlinks
 * @param {Function} listener   - called when fsevents emits events
 * @param {Function} rawEmitter - passes data to listeners of the 'raw' event
 * @returns {Function} closer
 */ function setFSEventsListener(path, realPath, listener, rawEmitter) {
    let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;
    const parentPath = sysPath.dirname(watchPath);
    let cont = FSEventsWatchers.get(watchPath);
    // If we've accumulated a substantial number of paths that
    // could have been consolidated by watching one directory
    // above the current one, create a watcher on the parent
    // path instead, so that we do consolidate going forward.
    if (couldConsolidate(parentPath)) {
        watchPath = parentPath;
    }
    const resolvedPath = sysPath.resolve(path);
    const hasSymlink = resolvedPath !== realPath;
    const filteredListener = (fullPath, flags, info)=>{
        if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);
        if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep)) listener(fullPath, flags, info);
    };
    // check if there is already a watcher on a parent path
    // modifies `watchPath` to the parent path when it finds a match
    let watchedParent = false;
    for (const watchedPath of FSEventsWatchers.keys()){
        if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {
            watchPath = watchedPath;
            cont = FSEventsWatchers.get(watchPath);
            watchedParent = true;
            break;
        }
    }
    if (cont || watchedParent) {
        cont.listeners.add(filteredListener);
    } else {
        cont = {
            listeners: new Set([
                filteredListener
            ]),
            rawEmitter,
            watcher: createFSEventsInstance(watchPath, (fullPath, flags)=>{
                if (!cont.listeners.size) return;
                if (flags & FSEVENT_FLAG_MUST_SCAN_SUBDIRS) return;
                const info = fsevents.getInfo(fullPath, flags);
                cont.listeners.forEach((list)=>{
                    list(fullPath, flags, info);
                });
                cont.rawEmitter(info.event, fullPath, info);
            })
        };
        FSEventsWatchers.set(watchPath, cont);
    }
    // removes this instance's listeners and closes the underlying fsevents
    // instance if there are no more listeners left
    return ()=>{
        const lst = cont.listeners;
        lst.delete(filteredListener);
        if (!lst.size) {
            FSEventsWatchers.delete(watchPath);
            if (cont.watcher) return cont.watcher.stop().then(()=>{
                cont.rawEmitter = cont.watcher = undefined;
                Object.freeze(cont);
            });
        }
    };
}
// Decide whether or not we should start a new higher-level
// parent watcher
const couldConsolidate = (path)=>{
    let count = 0;
    for (const watchPath of FSEventsWatchers.keys()){
        if (watchPath.indexOf(path) === 0) {
            count++;
            if (count >= consolidateThreshhold) {
                return true;
            }
        }
    }
    return false;
};
// returns boolean indicating whether fsevents can be used
const canUse = ()=>fsevents && FSEventsWatchers.size < 128;
// determines subdirectory traversal levels from root to path
const calcDepth = (path, root)=>{
    let i = 0;
    while(!path.indexOf(root) && (path = sysPath.dirname(path)) !== root)i++;
    return i;
};
// returns boolean indicating whether the fsevents' event info has the same type
// as the one returned by fs.stat
const sameTypes = (info, stats)=>info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();
/**
 * @mixin
 */ class FsEventsHandler {
    /**
 * @param {import('../index').FSWatcher} fsw
 */ constructor(fsw){
        this.fsw = fsw;
    }
    checkIgnored(path, stats) {
        const ipaths = this.fsw._ignoredPaths;
        if (this.fsw._isIgnored(path, stats)) {
            ipaths.add(path);
            if (stats && stats.isDirectory()) {
                ipaths.add(path + ROOT_GLOBSTAR);
            }
            return true;
        }
        ipaths.delete(path);
        ipaths.delete(path + ROOT_GLOBSTAR);
    }
    addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
        const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;
        this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);
    }
    async checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
        try {
            const stats = await stat(path);
            if (this.fsw.closed) return;
            if (sameTypes(info, stats)) {
                this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
            } else {
                this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
        } catch (error) {
            if (error.code === 'EACCES') {
                this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
            } else {
                this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
        }
    }
    handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {
        if (this.fsw.closed || this.checkIgnored(path)) return;
        if (event === EV_UNLINK) {
            const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;
            // suppress unlink events on never before seen files
            if (isDirectory || watchedDir.has(item)) {
                this.fsw._remove(parent, item, isDirectory);
            }
        } else {
            if (event === EV_ADD) {
                // track new directories
                if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);
                if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
                    // push symlinks back to the top of the stack to get handled
                    const curDepth = opts.depth === undefined ? undefined : calcDepth(fullPath, realPath) + 1;
                    return this._addToFsEvents(path, false, true, curDepth);
                }
                // track new paths
                // (other than symlinks being followed, which will be tracked soon)
                this.fsw._getWatchedDir(parent).add(item);
            }
            /**
     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}
     */ const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
            this.fsw._emit(eventName, path);
            if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);
        }
    }
    /**
 * Handle symlinks encountered during directory scan
 * @param {String} watchPath  - file/dir path to be watched with fsevents
 * @param {String} realPath   - real path (in case of symlinks)
 * @param {Function} transform  - path transformer
 * @param {Function} globFilter - path filter in case a glob pattern was provided
 * @returns {Function} closer for the watcher instance
*/ _watchWithFsEvents(watchPath, realPath, transform, globFilter) {
        if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;
        const opts = this.fsw.options;
        const watchCallback = async (fullPath, flags, info)=>{
            if (this.fsw.closed) return;
            if (opts.depth !== undefined && calcDepth(fullPath, realPath) > opts.depth) return;
            const path = transform(sysPath.join(watchPath, sysPath.relative(watchPath, fullPath)));
            if (globFilter && !globFilter(path)) return;
            // ensure directories are tracked
            const parent = sysPath.dirname(path);
            const item = sysPath.basename(path);
            const watchedDir = this.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path : parent);
            // correct for wrong events emitted
            if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {
                if (typeof opts.ignored === FUNCTION_TYPE) {
                    let stats;
                    try {
                        stats = await stat(path);
                    } catch (error) {}
                    if (this.fsw.closed) return;
                    if (this.checkIgnored(path, stats)) return;
                    if (sameTypes(info, stats)) {
                        this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
                    } else {
                        this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
                    }
                } else {
                    this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);
                }
            } else {
                switch(info.event){
                    case FSEVENT_CREATED:
                    case FSEVENT_MODIFIED:
                        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
                    case FSEVENT_DELETED:
                    case FSEVENT_MOVED:
                        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);
                }
            }
        };
        const closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw);
        this.fsw._emitReady();
        return closer;
    }
    /**
 * Handle symlinks encountered during directory scan
 * @param {String} linkPath path to symlink
 * @param {String} fullPath absolute path to the symlink
 * @param {Function} transform pre-existing path transformer
 * @param {Number} curDepth level of subdirectories traversed to where symlink is
 * @returns {Promise<void>}
 */ async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {
        // don't follow the same symlink more than once
        if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;
        this.fsw._symlinkPaths.set(fullPath, true);
        this.fsw._incrReadyCount();
        try {
            const linkTarget = await realpath(linkPath);
            if (this.fsw.closed) return;
            if (this.fsw._isIgnored(linkTarget)) {
                return this.fsw._emitReady();
            }
            this.fsw._incrReadyCount();
            // add the linkTarget for watching with a wrapper for transform
            // that causes emitted paths to incorporate the link's path
            this._addToFsEvents(linkTarget || linkPath, (path)=>{
                let aliasedPath = linkPath;
                if (linkTarget && linkTarget !== DOT_SLASH) {
                    aliasedPath = path.replace(linkTarget, linkPath);
                } else if (path !== DOT_SLASH) {
                    aliasedPath = sysPath.join(linkPath, path);
                }
                return transform(aliasedPath);
            }, false, curDepth);
        } catch (error) {
            if (this.fsw._handleError(error)) {
                return this.fsw._emitReady();
            }
        }
    }
    /**
 *
 * @param {Path} newPath
 * @param {fs.Stats} stats
 */ emitAdd(newPath, stats, processPath, opts, forceAdd) {
        const pp = processPath(newPath);
        const isDir = stats.isDirectory();
        const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));
        const base = sysPath.basename(pp);
        // ensure empty dirs get tracked
        if (isDir) this.fsw._getWatchedDir(pp);
        if (dirObj.has(base)) return;
        dirObj.add(base);
        if (!opts.ignoreInitial || forceAdd === true) {
            this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);
        }
    }
    initWatch(realPath, path, wh, processPath) {
        if (this.fsw.closed) return;
        const closer = this._watchWithFsEvents(wh.watchPath, sysPath.resolve(realPath || wh.watchPath), processPath, wh.globFilter);
        this.fsw._addPathCloser(path, closer);
    }
    /**
 * Handle added path with fsevents
 * @param {String} path file/dir path or glob pattern
 * @param {Function|Boolean=} transform converts working path to what the user expects
 * @param {Boolean=} forceAdd ensure add is emitted
 * @param {Number=} priorDepth Level of subdirectories already traversed.
 * @returns {Promise<void>}
 */ async _addToFsEvents(path, transform, forceAdd, priorDepth) {
        if (this.fsw.closed) {
            return;
        }
        const opts = this.fsw.options;
        const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;
        const wh = this.fsw._getWatchHelpers(path);
        // evaluate what is at the path we're being asked to watch
        try {
            const stats = await statMethods[wh.statMethod](wh.watchPath);
            if (this.fsw.closed) return;
            if (this.fsw._isIgnored(wh.watchPath, stats)) {
                throw null;
            }
            if (stats.isDirectory()) {
                // emit addDir unless this is a glob parent
                if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);
                // don't recurse further if it would exceed depth setting
                if (priorDepth && priorDepth > opts.depth) return;
                // scan the contents of the dir
                this.fsw._readdirp(wh.watchPath, {
                    fileFilter: (entry)=>wh.filterPath(entry),
                    directoryFilter: (entry)=>wh.filterDir(entry),
                    ...Depth(opts.depth - (priorDepth || 0))
                }).on(STR_DATA, (entry)=>{
                    // need to check filterPath on dirs b/c filterDir is less restrictive
                    if (this.fsw.closed) {
                        return;
                    }
                    if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;
                    const joinedPath = sysPath.join(wh.watchPath, entry.path);
                    const { fullPath } = entry;
                    if (wh.followSymlinks && entry.stats.isSymbolicLink()) {
                        // preserve the current depth here since it can't be derived from
                        // real paths past the symlink
                        const curDepth = opts.depth === undefined ? undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;
                        this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
                    } else {
                        this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);
                    }
                }).on(EV_ERROR, EMPTY_FN).on(STR_END, ()=>{
                    this.fsw._emitReady();
                });
            } else {
                this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);
                this.fsw._emitReady();
            }
        } catch (error) {
            if (!error || this.fsw._handleError(error)) {
                // TODO: Strange thing: "should not choke on an ignored watch path" will be failed without 2 ready calls -__-
                this.fsw._emitReady();
                this.fsw._emitReady();
            }
        }
        if (opts.persistent && forceAdd !== true) {
            if (typeof transform === FUNCTION_TYPE) {
                // realpath has already been resolved
                this.initWatch(undefined, path, wh, processPath);
            } else {
                let realPath;
                try {
                    realPath = await realpath(wh.watchPath);
                } catch (e) {}
                this.initWatch(realPath, path, wh, processPath);
            }
        }
    }
}
module.exports = FsEventsHandler;
module.exports.canUse = canUse;
}),
"[project]/align/node_modules/chokidar/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { EventEmitter } = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const sysPath = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const { promisify } = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const readdirp = __turbopack_context__.r("[project]/align/node_modules/readdirp/index.js [app-route] (ecmascript)");
const anymatch = __turbopack_context__.r("[project]/align/node_modules/anymatch/index.js [app-route] (ecmascript)").default;
const globParent = __turbopack_context__.r("[project]/align/node_modules/chokidar/node_modules/glob-parent/index.js [app-route] (ecmascript)");
const isGlob = __turbopack_context__.r("[project]/align/node_modules/is-glob/index.js [app-route] (ecmascript)");
const braces = __turbopack_context__.r("[project]/align/node_modules/braces/index.js [app-route] (ecmascript)");
const normalizePath = __turbopack_context__.r("[project]/align/node_modules/normalize-path/index.js [app-route] (ecmascript)");
const NodeFsHandler = __turbopack_context__.r("[project]/align/node_modules/chokidar/lib/nodefs-handler.js [app-route] (ecmascript)");
const FsEventsHandler = __turbopack_context__.r("[project]/align/node_modules/chokidar/lib/fsevents-handler.js [app-route] (ecmascript)");
const { EV_ALL, EV_READY, EV_ADD, EV_CHANGE, EV_UNLINK, EV_ADD_DIR, EV_UNLINK_DIR, EV_RAW, EV_ERROR, STR_CLOSE, STR_END, BACK_SLASH_RE, DOUBLE_SLASH_RE, SLASH_OR_BACK_SLASH_RE, DOT_RE, REPLACER_RE, SLASH, SLASH_SLASH, BRACE_START, BANG, ONE_DOT, TWO_DOTS, GLOBSTAR, SLASH_GLOBSTAR, ANYMATCH_OPTS, STRING_TYPE, FUNCTION_TYPE, EMPTY_STR, EMPTY_FN, isWindows, isMacos, isIBMi } = __turbopack_context__.r("[project]/align/node_modules/chokidar/lib/constants.js [app-route] (ecmascript)");
const stat = promisify(fs.stat);
const readdir = promisify(fs.readdir);
/**
 * @typedef {String} Path
 * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName
 * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType
 */ /**
 *
 * @typedef {Object} WatchHelpers
 * @property {Boolean} followSymlinks
 * @property {'stat'|'lstat'} statMethod
 * @property {Path} path
 * @property {Path} watchPath
 * @property {Function} entryPath
 * @property {Boolean} hasGlob
 * @property {Object} globFilter
 * @property {Function} filterPath
 * @property {Function} filterDir
 */ const arrify = (value = [])=>Array.isArray(value) ? value : [
        value
    ];
const flatten = (list, result = [])=>{
    list.forEach((item)=>{
        if (Array.isArray(item)) {
            flatten(item, result);
        } else {
            result.push(item);
        }
    });
    return result;
};
const unifyPaths = (paths_)=>{
    /**
   * @type {Array<String>}
   */ const paths = flatten(arrify(paths_));
    if (!paths.every((p)=>typeof p === STRING_TYPE)) {
        throw new TypeError(`Non-string provided as watch path: ${paths}`);
    }
    return paths.map(normalizePathToUnix);
};
// If SLASH_SLASH occurs at the beginning of path, it is not replaced
//     because "//StoragePC/DrivePool/Movies" is a valid network path
const toUnix = (string)=>{
    let str = string.replace(BACK_SLASH_RE, SLASH);
    let prepend = false;
    if (str.startsWith(SLASH_SLASH)) {
        prepend = true;
    }
    while(str.match(DOUBLE_SLASH_RE)){
        str = str.replace(DOUBLE_SLASH_RE, SLASH);
    }
    if (prepend) {
        str = SLASH + str;
    }
    return str;
};
// Our version of upath.normalize
// TODO: this is not equal to path-normalize module - investigate why
const normalizePathToUnix = (path)=>toUnix(sysPath.normalize(toUnix(path)));
const normalizeIgnored = (cwd = EMPTY_STR)=>(path)=>{
        if (typeof path !== STRING_TYPE) return path;
        return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));
    };
const getAbsolutePath = (path, cwd)=>{
    if (sysPath.isAbsolute(path)) {
        return path;
    }
    if (path.startsWith(BANG)) {
        return BANG + sysPath.join(cwd, path.slice(1));
    }
    return sysPath.join(cwd, path);
};
const undef = (opts, key)=>opts[key] === undefined;
/**
 * Directory entry.
 * @property {Path} path
 * @property {Set<Path>} items
 */ class DirEntry {
    /**
   * @param {Path} dir
   * @param {Function} removeWatcher
   */ constructor(dir, removeWatcher){
        this.path = dir;
        this._removeWatcher = removeWatcher;
        /** @type {Set<Path>} */ this.items = new Set();
    }
    add(item) {
        const { items } = this;
        if (!items) return;
        if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);
    }
    async remove(item) {
        const { items } = this;
        if (!items) return;
        items.delete(item);
        if (items.size > 0) return;
        const dir = this.path;
        try {
            await readdir(dir);
        } catch (err) {
            if (this._removeWatcher) {
                this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
            }
        }
    }
    has(item) {
        const { items } = this;
        if (!items) return;
        return items.has(item);
    }
    /**
   * @returns {Array<String>}
   */ getChildren() {
        const { items } = this;
        if (!items) return;
        return [
            ...items.values()
        ];
    }
    dispose() {
        this.items.clear();
        delete this.path;
        delete this._removeWatcher;
        delete this.items;
        Object.freeze(this);
    }
}
const STAT_METHOD_F = 'stat';
const STAT_METHOD_L = 'lstat';
class WatchHelper {
    constructor(path, watchPath, follow, fsw){
        this.fsw = fsw;
        this.path = path = path.replace(REPLACER_RE, EMPTY_STR);
        this.watchPath = watchPath;
        this.fullWatchPath = sysPath.resolve(watchPath);
        this.hasGlob = watchPath !== path;
        /** @type {object|boolean} */ if (path === EMPTY_STR) this.hasGlob = false;
        this.globSymlink = this.hasGlob && follow ? undefined : false;
        this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;
        this.dirParts = this.getDirParts(path);
        this.dirParts.forEach((parts)=>{
            if (parts.length > 1) parts.pop();
        });
        this.followSymlinks = follow;
        this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
    }
    checkGlobSymlink(entry) {
        // only need to resolve once
        // first entry should always have entry.parentDir === EMPTY_STR
        if (this.globSymlink === undefined) {
            this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : {
                realPath: entry.fullParentDir,
                linkPath: this.fullWatchPath
            };
        }
        if (this.globSymlink) {
            return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
        }
        return entry.fullPath;
    }
    entryPath(entry) {
        return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, this.checkGlobSymlink(entry)));
    }
    filterPath(entry) {
        const { stats } = entry;
        if (stats && stats.isSymbolicLink()) return this.filterDir(entry);
        const resolvedPath = this.entryPath(entry);
        const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;
        return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
    }
    getDirParts(path) {
        if (!this.hasGlob) return [];
        const parts = [];
        const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [
            path
        ];
        expandedPath.forEach((path)=>{
            parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));
        });
        return parts;
    }
    filterDir(entry) {
        if (this.hasGlob) {
            const entryParts = this.getDirParts(this.checkGlobSymlink(entry));
            let globstar = false;
            this.unmatchedGlob = !this.dirParts.some((parts)=>{
                return parts.every((part, i)=>{
                    if (part === GLOBSTAR) globstar = true;
                    return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);
                });
            });
        }
        return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
    }
}
/**
 * Watches files & directories for changes. Emitted events:
 * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
 *
 *     new FSWatcher()
 *       .add(directories)
 *       .on('add', path => log('File', path, 'was added'))
 */ class FSWatcher extends EventEmitter {
    // Not indenting methods for history sake; for now.
    constructor(_opts){
        super();
        const opts = {};
        if (_opts) Object.assign(opts, _opts); // for frozen objects
        /** @type {Map<String, DirEntry>} */ this._watched = new Map();
        /** @type {Map<String, Array>} */ this._closers = new Map();
        /** @type {Set<String>} */ this._ignoredPaths = new Set();
        /** @type {Map<ThrottleType, Map>} */ this._throttled = new Map();
        /** @type {Map<Path, String|Boolean>} */ this._symlinkPaths = new Map();
        this._streams = new Set();
        this.closed = false;
        // Set up default options.
        if (undef(opts, 'persistent')) opts.persistent = true;
        if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;
        if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;
        if (undef(opts, 'interval')) opts.interval = 100;
        if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;
        if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;
        opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;
        // Enable fsevents on OS X when polling isn't explicitly enabled.
        if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;
        // If we can't use fsevents, ensure the options reflect it's disabled.
        const canUseFsEvents = FsEventsHandler.canUse();
        if (!canUseFsEvents) opts.useFsEvents = false;
        // Use polling on Mac if not using fsevents.
        // Other platforms use non-polling fs_watch.
        if (undef(opts, 'usePolling') && !opts.useFsEvents) {
            opts.usePolling = isMacos;
        }
        // Always default to polling on IBM i because fs.watch() is not available on IBM i.
        if (isIBMi) {
            opts.usePolling = true;
        }
        // Global override (useful for end-developers that need to force polling for all
        // instances of chokidar, regardless of usage/dependency depth)
        const envPoll = process.env.CHOKIDAR_USEPOLLING;
        if (envPoll !== undefined) {
            const envLower = envPoll.toLowerCase();
            if (envLower === 'false' || envLower === '0') {
                opts.usePolling = false;
            } else if (envLower === 'true' || envLower === '1') {
                opts.usePolling = true;
            } else {
                opts.usePolling = !!envLower;
            }
        }
        const envInterval = process.env.CHOKIDAR_INTERVAL;
        if (envInterval) {
            opts.interval = Number.parseInt(envInterval, 10);
        }
        // Editor atomic write normalization enabled by default with fs.watch
        if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;
        if (opts.atomic) this._pendingUnlinks = new Map();
        if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;
        if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;
        if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};
        const awf = opts.awaitWriteFinish;
        if (awf) {
            if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;
            if (!awf.pollInterval) awf.pollInterval = 100;
            this._pendingWrites = new Map();
        }
        if (opts.ignored) opts.ignored = arrify(opts.ignored);
        let readyCalls = 0;
        this._emitReady = ()=>{
            readyCalls++;
            if (readyCalls >= this._readyCount) {
                this._emitReady = EMPTY_FN;
                this._readyEmitted = true;
                // use process.nextTick to allow time for listener to be bound
                process.nextTick(()=>this.emit(EV_READY));
            }
        };
        this._emitRaw = (...args)=>this.emit(EV_RAW, ...args);
        this._readyEmitted = false;
        this.options = opts;
        // Initialize with proper watcher.
        if (opts.useFsEvents) {
            this._fsEventsHandler = new FsEventsHandler(this);
        } else {
            this._nodeFsHandler = new NodeFsHandler(this);
        }
        // Youre frozen when your hearts not open.
        Object.freeze(opts);
    }
    // Public methods
    /**
 * Adds paths to be watched on an existing FSWatcher instance
 * @param {Path|Array<Path>} paths_
 * @param {String=} _origAdd private; for handling non-existent paths to be watched
 * @param {Boolean=} _internal private; indicates a non-user add
 * @returns {FSWatcher} for chaining
 */ add(paths_, _origAdd, _internal) {
        const { cwd, disableGlobbing } = this.options;
        this.closed = false;
        let paths = unifyPaths(paths_);
        if (cwd) {
            paths = paths.map((path)=>{
                const absPath = getAbsolutePath(path, cwd);
                // Check `path` instead of `absPath` because the cwd portion can't be a glob
                if (disableGlobbing || !isGlob(path)) {
                    return absPath;
                }
                return normalizePath(absPath);
            });
        }
        // set aside negated glob strings
        paths = paths.filter((path)=>{
            if (path.startsWith(BANG)) {
                this._ignoredPaths.add(path.slice(1));
                return false;
            }
            // if a path is being added that was previously ignored, stop ignoring it
            this._ignoredPaths.delete(path);
            this._ignoredPaths.delete(path + SLASH_GLOBSTAR);
            // reset the cached userIgnored anymatch fn
            // to make ignoredPaths changes effective
            this._userIgnored = undefined;
            return true;
        });
        if (this.options.useFsEvents && this._fsEventsHandler) {
            if (!this._readyCount) this._readyCount = paths.length;
            if (this.options.persistent) this._readyCount += paths.length;
            paths.forEach((path)=>this._fsEventsHandler._addToFsEvents(path));
        } else {
            if (!this._readyCount) this._readyCount = 0;
            this._readyCount += paths.length;
            Promise.all(paths.map(async (path)=>{
                const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);
                if (res) this._emitReady();
                return res;
            })).then((results)=>{
                if (this.closed) return;
                results.filter((item)=>item).forEach((item)=>{
                    this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
                });
            });
        }
        return this;
    }
    /**
 * Close watchers or start ignoring events from specified paths.
 * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
 * @returns {FSWatcher} for chaining
*/ unwatch(paths_) {
        if (this.closed) return this;
        const paths = unifyPaths(paths_);
        const { cwd } = this.options;
        paths.forEach((path)=>{
            // convert to absolute path unless relative path already matches
            if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {
                if (cwd) path = sysPath.join(cwd, path);
                path = sysPath.resolve(path);
            }
            this._closePath(path);
            this._ignoredPaths.add(path);
            if (this._watched.has(path)) {
                this._ignoredPaths.add(path + SLASH_GLOBSTAR);
            }
            // reset the cached userIgnored anymatch fn
            // to make ignoredPaths changes effective
            this._userIgnored = undefined;
        });
        return this;
    }
    /**
 * Close watchers and remove all listeners from watched paths.
 * @returns {Promise<void>}.
*/ close() {
        if (this.closed) return this._closePromise;
        this.closed = true;
        // Memory management.
        this.removeAllListeners();
        const closers = [];
        this._closers.forEach((closerList)=>closerList.forEach((closer)=>{
                const promise = closer();
                if (promise instanceof Promise) closers.push(promise);
            }));
        this._streams.forEach((stream)=>stream.destroy());
        this._userIgnored = undefined;
        this._readyCount = 0;
        this._readyEmitted = false;
        this._watched.forEach((dirent)=>dirent.dispose());
        [
            'closers',
            'watched',
            'streams',
            'symlinkPaths',
            'throttled'
        ].forEach((key)=>{
            this[`_${key}`].clear();
        });
        this._closePromise = closers.length ? Promise.all(closers).then(()=>undefined) : Promise.resolve();
        return this._closePromise;
    }
    /**
 * Expose list of watched paths
 * @returns {Object} for chaining
*/ getWatched() {
        const watchList = {};
        this._watched.forEach((entry, dir)=>{
            const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
            watchList[key || ONE_DOT] = entry.getChildren().sort();
        });
        return watchList;
    }
    emitWithAll(event, args) {
        this.emit(...args);
        if (event !== EV_ERROR) this.emit(EV_ALL, ...args);
    }
    // Common helpers
    // --------------
    /**
 * Normalize and emit events.
 * Calling _emit DOES NOT MEAN emit() would be called!
 * @param {EventName} event Type of event
 * @param {Path} path File or directory path
 * @param {*=} val1 arguments to be passed with event
 * @param {*=} val2
 * @param {*=} val3
 * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
 */ async _emit(event, path, val1, val2, val3) {
        if (this.closed) return;
        const opts = this.options;
        if (isWindows) path = sysPath.normalize(path);
        if (opts.cwd) path = sysPath.relative(opts.cwd, path);
        /** @type Array<any> */ const args = [
            event,
            path
        ];
        if (val3 !== undefined) args.push(val1, val2, val3);
        else if (val2 !== undefined) args.push(val1, val2);
        else if (val1 !== undefined) args.push(val1);
        const awf = opts.awaitWriteFinish;
        let pw;
        if (awf && (pw = this._pendingWrites.get(path))) {
            pw.lastChange = new Date();
            return this;
        }
        if (opts.atomic) {
            if (event === EV_UNLINK) {
                this._pendingUnlinks.set(path, args);
                setTimeout(()=>{
                    this._pendingUnlinks.forEach((entry, path)=>{
                        this.emit(...entry);
                        this.emit(EV_ALL, ...entry);
                        this._pendingUnlinks.delete(path);
                    });
                }, typeof opts.atomic === 'number' ? opts.atomic : 100);
                return this;
            }
            if (event === EV_ADD && this._pendingUnlinks.has(path)) {
                event = args[0] = EV_CHANGE;
                this._pendingUnlinks.delete(path);
            }
        }
        if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {
            const awfEmit = (err, stats)=>{
                if (err) {
                    event = args[0] = EV_ERROR;
                    args[1] = err;
                    this.emitWithAll(event, args);
                } else if (stats) {
                    // if stats doesn't exist the file must have been deleted
                    if (args.length > 2) {
                        args[2] = stats;
                    } else {
                        args.push(stats);
                    }
                    this.emitWithAll(event, args);
                }
            };
            this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);
            return this;
        }
        if (event === EV_CHANGE) {
            const isThrottled = !this._throttle(EV_CHANGE, path, 50);
            if (isThrottled) return this;
        }
        if (opts.alwaysStat && val1 === undefined && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {
            const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;
            let stats;
            try {
                stats = await stat(fullPath);
            } catch (err) {}
            // Suppress event when fs_stat fails, to avoid sending undefined 'stat'
            if (!stats || this.closed) return;
            args.push(stats);
        }
        this.emitWithAll(event, args);
        return this;
    }
    /**
 * Common handler for errors
 * @param {Error} error
 * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
 */ _handleError(error) {
        const code = error && error.code;
        if (error && code !== 'ENOENT' && code !== 'ENOTDIR' && (!this.options.ignorePermissionErrors || code !== 'EPERM' && code !== 'EACCES')) {
            this.emit(EV_ERROR, error);
        }
        return error || this.closed;
    }
    /**
 * Helper utility for throttling
 * @param {ThrottleType} actionType type being throttled
 * @param {Path} path being acted upon
 * @param {Number} timeout duration of time to suppress duplicate actions
 * @returns {Object|false} tracking object or false if action should be suppressed
 */ _throttle(actionType, path, timeout) {
        if (!this._throttled.has(actionType)) {
            this._throttled.set(actionType, new Map());
        }
        /** @type {Map<Path, Object>} */ const action = this._throttled.get(actionType);
        /** @type {Object} */ const actionPath = action.get(path);
        if (actionPath) {
            actionPath.count++;
            return false;
        }
        let timeoutObject;
        const clear = ()=>{
            const item = action.get(path);
            const count = item ? item.count : 0;
            action.delete(path);
            clearTimeout(timeoutObject);
            if (item) clearTimeout(item.timeoutObject);
            return count;
        };
        timeoutObject = setTimeout(clear, timeout);
        const thr = {
            timeoutObject,
            clear,
            count: 0
        };
        action.set(path, thr);
        return thr;
    }
    _incrReadyCount() {
        return this._readyCount++;
    }
    /**
 * Awaits write operation to finish.
 * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
 * @param {Path} path being acted upon
 * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
 * @param {EventName} event
 * @param {Function} awfEmit Callback to be called when ready for event to be emitted.
 */ _awaitWriteFinish(path, threshold, event, awfEmit) {
        let timeoutHandler;
        let fullPath = path;
        if (this.options.cwd && !sysPath.isAbsolute(path)) {
            fullPath = sysPath.join(this.options.cwd, path);
        }
        const now = new Date();
        const awaitWriteFinish = (prevStat)=>{
            fs.stat(fullPath, (err, curStat)=>{
                if (err || !this._pendingWrites.has(path)) {
                    if (err && err.code !== 'ENOENT') awfEmit(err);
                    return;
                }
                const now = Number(new Date());
                if (prevStat && curStat.size !== prevStat.size) {
                    this._pendingWrites.get(path).lastChange = now;
                }
                const pw = this._pendingWrites.get(path);
                const df = now - pw.lastChange;
                if (df >= threshold) {
                    this._pendingWrites.delete(path);
                    awfEmit(undefined, curStat);
                } else {
                    timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval, curStat);
                }
            });
        };
        if (!this._pendingWrites.has(path)) {
            this._pendingWrites.set(path, {
                lastChange: now,
                cancelWait: ()=>{
                    this._pendingWrites.delete(path);
                    clearTimeout(timeoutHandler);
                    return event;
                }
            });
            timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval);
        }
    }
    _getGlobIgnored() {
        return [
            ...this._ignoredPaths.values()
        ];
    }
    /**
 * Determines whether user has asked to ignore this path.
 * @param {Path} path filepath or dir
 * @param {fs.Stats=} stats result of fs.stat
 * @returns {Boolean}
 */ _isIgnored(path, stats) {
        if (this.options.atomic && DOT_RE.test(path)) return true;
        if (!this._userIgnored) {
            const { cwd } = this.options;
            const ign = this.options.ignored;
            const ignored = ign && ign.map(normalizeIgnored(cwd));
            const paths = arrify(ignored).filter((path)=>typeof path === STRING_TYPE && !isGlob(path)).map((path)=>path + SLASH_GLOBSTAR);
            const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);
            this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);
        }
        return this._userIgnored([
            path,
            stats
        ]);
    }
    _isntIgnored(path, stat) {
        return !this._isIgnored(path, stat);
    }
    /**
 * Provides a set of common helpers and properties relating to symlink and glob handling.
 * @param {Path} path file, directory, or glob pattern being watched
 * @param {Number=} depth at any depth > 0, this isn't a glob
 * @returns {WatchHelper} object containing helpers for this path
 */ _getWatchHelpers(path, depth) {
        const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);
        const follow = this.options.followSymlinks;
        return new WatchHelper(path, watchPath, follow, this);
    }
    // Directory helpers
    // -----------------
    /**
 * Provides directory tracking objects
 * @param {String} directory path of the directory
 * @returns {DirEntry} the directory's tracking object
 */ _getWatchedDir(directory) {
        if (!this._boundRemove) this._boundRemove = this._remove.bind(this);
        const dir = sysPath.resolve(directory);
        if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));
        return this._watched.get(dir);
    }
    // File helpers
    // ------------
    /**
 * Check for read permissions.
 * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
 * @param {fs.Stats} stats - object, result of fs_stat
 * @returns {Boolean} indicates whether the file can be read
*/ _hasReadPermissions(stats) {
        if (this.options.ignorePermissionErrors) return true;
        // stats.mode may be bigint
        const md = stats && Number.parseInt(stats.mode, 10);
        const st = md & 0o777;
        const it = Number.parseInt(st.toString(8)[0], 10);
        return Boolean(4 & it);
    }
    /**
 * Handles emitting unlink events for
 * files and directories, and via recursion, for
 * files and directories within directories that are unlinked
 * @param {String} directory within which the following item is located
 * @param {String} item      base path of item/directory
 * @returns {void}
*/ _remove(directory, item, isDirectory) {
        // if what is being deleted is a directory, get that directory's paths
        // for recursive deleting and cleaning of watched object
        // if it is not a directory, nestedDirectoryChildren will be empty array
        const path = sysPath.join(directory, item);
        const fullPath = sysPath.resolve(path);
        isDirectory = isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath);
        // prevent duplicate handling in case of arriving here nearly simultaneously
        // via multiple paths (such as _handleFile and _handleDir)
        if (!this._throttle('remove', path, 100)) return;
        // if the only watched file is removed, watch for its return
        if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {
            this.add(directory, item, true);
        }
        // This will create a new entry in the watched object in either case
        // so we got to do the directory check beforehand
        const wp = this._getWatchedDir(path);
        const nestedDirectoryChildren = wp.getChildren();
        // Recursively remove children directories / files.
        nestedDirectoryChildren.forEach((nested)=>this._remove(path, nested));
        // Check if item was on the watched list and remove it
        const parent = this._getWatchedDir(directory);
        const wasTracked = parent.has(item);
        parent.remove(item);
        // Fixes issue #1042 -> Relative paths were detected and added as symlinks
        // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),
        // but never removed from the map in case the path was deleted.
        // This leads to an incorrect state if the path was recreated:
        // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553
        if (this._symlinkPaths.has(fullPath)) {
            this._symlinkPaths.delete(fullPath);
        }
        // If we wait for this file to be fully written, cancel the wait.
        let relPath = path;
        if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);
        if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
            const event = this._pendingWrites.get(relPath).cancelWait();
            if (event === EV_ADD) return;
        }
        // The Entry will either be a directory that just got removed
        // or a bogus entry to a file, in either case we have to remove it
        this._watched.delete(path);
        this._watched.delete(fullPath);
        const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;
        if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);
        // Avoid conflicts if we later create another file with the same name
        if (!this.options.useFsEvents) {
            this._closePath(path);
        }
    }
    /**
 * Closes all watchers for a path
 * @param {Path} path
 */ _closePath(path) {
        this._closeFile(path);
        const dir = sysPath.dirname(path);
        this._getWatchedDir(dir).remove(sysPath.basename(path));
    }
    /**
 * Closes only file-specific watchers
 * @param {Path} path
 */ _closeFile(path) {
        const closers = this._closers.get(path);
        if (!closers) return;
        closers.forEach((closer)=>closer());
        this._closers.delete(path);
    }
    /**
 *
 * @param {Path} path
 * @param {Function} closer
 */ _addPathCloser(path, closer) {
        if (!closer) return;
        let list = this._closers.get(path);
        if (!list) {
            list = [];
            this._closers.set(path, list);
        }
        list.push(closer);
    }
    _readdirp(root, opts) {
        if (this.closed) return;
        const options = {
            type: EV_ALL,
            alwaysStat: true,
            lstat: true,
            ...opts
        };
        let stream = readdirp(root, options);
        this._streams.add(stream);
        stream.once(STR_CLOSE, ()=>{
            stream = undefined;
        });
        stream.once(STR_END, ()=>{
            if (stream) {
                this._streams.delete(stream);
                stream = undefined;
            }
        });
        return stream;
    }
}
// Export FSWatcher class
exports.FSWatcher = FSWatcher;
/**
 * Instantiates watcher with paths to be tracked.
 * @param {String|Array<String>} paths file/directory paths and/or globs
 * @param {Object=} options chokidar opts
 * @returns an instance of FSWatcher for chaining.
 */ const watch = (paths, options)=>{
    const watcher = new FSWatcher(options);
    watcher.add(paths);
    return watcher;
};
exports.watch = watch;
}),
"[project]/align/node_modules/braces/lib/utils.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.isInteger = (num)=>{
    if (typeof num === 'number') {
        return Number.isInteger(num);
    }
    if (typeof num === 'string' && num.trim() !== '') {
        return Number.isInteger(Number(num));
    }
    return false;
};
/**
 * Find a node of the given type
 */ exports.find = (node, type)=>node.nodes.find((node)=>node.type === type);
/**
 * Find a node of the given type
 */ exports.exceedsLimit = (min, max, step = 1, limit)=>{
    if (limit === false) return false;
    if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
    return (Number(max) - Number(min)) / Number(step) >= limit;
};
/**
 * Escape the given node with '\\' before node.value
 */ exports.escapeNode = (block, n = 0, type)=>{
    const node = block.nodes[n];
    if (!node) return;
    if (type && node.type === type || node.type === 'open' || node.type === 'close') {
        if (node.escaped !== true) {
            node.value = '\\' + node.value;
            node.escaped = true;
        }
    }
};
/**
 * Returns true if the given brace node should be enclosed in literal braces
 */ exports.encloseBrace = (node)=>{
    if (node.type !== 'brace') return false;
    if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
    }
    return false;
};
/**
 * Returns true if a brace node is invalid.
 */ exports.isInvalidBrace = (block)=>{
    if (block.type !== 'brace') return false;
    if (block.invalid === true || block.dollar) return true;
    if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
    }
    if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
    }
    return false;
};
/**
 * Returns true if a node is an open or close node
 */ exports.isOpenOrClose = (node)=>{
    if (node.type === 'open' || node.type === 'close') {
        return true;
    }
    return node.open === true || node.close === true;
};
/**
 * Reduce an array of text nodes.
 */ exports.reduce = (nodes)=>nodes.reduce((acc, node)=>{
        if (node.type === 'text') acc.push(node.value);
        if (node.type === 'range') node.type = 'text';
        return acc;
    }, []);
/**
 * Flatten an array
 */ exports.flatten = (...args)=>{
    const result = [];
    const flat = (arr)=>{
        for(let i = 0; i < arr.length; i++){
            const ele = arr[i];
            if (Array.isArray(ele)) {
                flat(ele);
                continue;
            }
            if (ele !== undefined) {
                result.push(ele);
            }
        }
        return result;
    };
    flat(args);
    return result;
};
}),
"[project]/align/node_modules/braces/lib/stringify.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const utils = __turbopack_context__.r("[project]/align/node_modules/braces/lib/utils.js [app-route] (ecmascript)");
module.exports = (ast, options = {})=>{
    const stringify = (node, parent = {})=>{
        const invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        const invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = '';
        if (node.value) {
            if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
                return '\\' + node.value;
            }
            return node.value;
        }
        if (node.value) {
            return node.value;
        }
        if (node.nodes) {
            for (const child of node.nodes){
                output += stringify(child);
            }
        }
        return output;
    };
    return stringify(ast);
};
}),
"[project]/align/node_modules/braces/lib/compile.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const fill = __turbopack_context__.r("[project]/align/node_modules/fill-range/index.js [app-route] (ecmascript)");
const utils = __turbopack_context__.r("[project]/align/node_modules/braces/lib/utils.js [app-route] (ecmascript)");
const compile = (ast, options = {})=>{
    const walk = (node, parent = {})=>{
        const invalidBlock = utils.isInvalidBrace(parent);
        const invalidNode = node.invalid === true && options.escapeInvalid === true;
        const invalid = invalidBlock === true || invalidNode === true;
        const prefix = options.escapeInvalid === true ? '\\' : '';
        let output = '';
        if (node.isOpen === true) {
            return prefix + node.value;
        }
        if (node.isClose === true) {
            console.log('node.isClose', prefix, node.value);
            return prefix + node.value;
        }
        if (node.type === 'open') {
            return invalid ? prefix + node.value : '(';
        }
        if (node.type === 'close') {
            return invalid ? prefix + node.value : ')';
        }
        if (node.type === 'comma') {
            return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';
        }
        if (node.value) {
            return node.value;
        }
        if (node.nodes && node.ranges > 0) {
            const args = utils.reduce(node.nodes);
            const range = fill(...args, {
                ...options,
                wrap: false,
                toRegex: true,
                strictZeros: true
            });
            if (range.length !== 0) {
                return args.length > 1 && range.length > 1 ? `(${range})` : range;
            }
        }
        if (node.nodes) {
            for (const child of node.nodes){
                output += walk(child, node);
            }
        }
        return output;
    };
    return walk(ast);
};
module.exports = compile;
}),
"[project]/align/node_modules/braces/lib/expand.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const fill = __turbopack_context__.r("[project]/align/node_modules/fill-range/index.js [app-route] (ecmascript)");
const stringify = __turbopack_context__.r("[project]/align/node_modules/braces/lib/stringify.js [app-route] (ecmascript)");
const utils = __turbopack_context__.r("[project]/align/node_modules/braces/lib/utils.js [app-route] (ecmascript)");
const append = (queue = '', stash = '', enclose = false)=>{
    const result = [];
    queue = [].concat(queue);
    stash = [].concat(stash);
    if (!stash.length) return queue;
    if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele)=>`{${ele}}`) : stash;
    }
    for (const item of queue){
        if (Array.isArray(item)) {
            for (const value of item){
                result.push(append(value, stash, enclose));
            }
        } else {
            for (let ele of stash){
                if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;
                result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
            }
        }
    }
    return utils.flatten(result);
};
const expand = (ast, options = {})=>{
    const rangeLimit = options.rangeLimit === undefined ? 1000 : options.rangeLimit;
    const walk = (node, parent = {})=>{
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while(p.type !== 'brace' && p.type !== 'root' && p.parent){
            p = p.parent;
            q = p.queue;
        }
        if (node.invalid || node.dollar) {
            q.push(append(q.pop(), stringify(node, options)));
            return;
        }
        if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {
            q.push(append(q.pop(), [
                '{}'
            ]));
            return;
        }
        if (node.nodes && node.ranges > 0) {
            const args = utils.reduce(node.nodes);
            if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
                throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
            }
            let range = fill(...args, options);
            if (range.length === 0) {
                range = stringify(node, options);
            }
            q.push(append(q.pop(), range));
            node.nodes = [];
            return;
        }
        const enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while(block.type !== 'brace' && block.type !== 'root' && block.parent){
            block = block.parent;
            queue = block.queue;
        }
        for(let i = 0; i < node.nodes.length; i++){
            const child = node.nodes[i];
            if (child.type === 'comma' && node.type === 'brace') {
                if (i === 1) queue.push('');
                queue.push('');
                continue;
            }
            if (child.type === 'close') {
                q.push(append(q.pop(), queue, enclose));
                continue;
            }
            if (child.value && child.type !== 'open') {
                queue.push(append(queue.pop(), child.value));
                continue;
            }
            if (child.nodes) {
                walk(child, node);
            }
        }
        return queue;
    };
    return utils.flatten(walk(ast));
};
module.exports = expand;
}),
"[project]/align/node_modules/braces/lib/constants.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {
    MAX_LENGTH: 10000,
    // Digits
    CHAR_0: '0',
    /* 0 */ CHAR_9: '9',
    /* 9 */ // Alphabet chars.
    CHAR_UPPERCASE_A: 'A',
    /* A */ CHAR_LOWERCASE_A: 'a',
    /* a */ CHAR_UPPERCASE_Z: 'Z',
    /* Z */ CHAR_LOWERCASE_Z: 'z',
    /* z */ CHAR_LEFT_PARENTHESES: '(',
    /* ( */ CHAR_RIGHT_PARENTHESES: ')',
    /* ) */ CHAR_ASTERISK: '*',
    /* * */ // Non-alphabetic chars.
    CHAR_AMPERSAND: '&',
    /* & */ CHAR_AT: '@',
    /* @ */ CHAR_BACKSLASH: '\\',
    /* \ */ CHAR_BACKTICK: '`',
    /* ` */ CHAR_CARRIAGE_RETURN: '\r',
    /* \r */ CHAR_CIRCUMFLEX_ACCENT: '^',
    /* ^ */ CHAR_COLON: ':',
    /* : */ CHAR_COMMA: ',',
    /* , */ CHAR_DOLLAR: '$',
    /* . */ CHAR_DOT: '.',
    /* . */ CHAR_DOUBLE_QUOTE: '"',
    /* " */ CHAR_EQUAL: '=',
    /* = */ CHAR_EXCLAMATION_MARK: '!',
    /* ! */ CHAR_FORM_FEED: '\f',
    /* \f */ CHAR_FORWARD_SLASH: '/',
    /* / */ CHAR_HASH: '#',
    /* # */ CHAR_HYPHEN_MINUS: '-',
    /* - */ CHAR_LEFT_ANGLE_BRACKET: '<',
    /* < */ CHAR_LEFT_CURLY_BRACE: '{',
    /* { */ CHAR_LEFT_SQUARE_BRACKET: '[',
    /* [ */ CHAR_LINE_FEED: '\n',
    /* \n */ CHAR_NO_BREAK_SPACE: '\u00A0',
    /* \u00A0 */ CHAR_PERCENT: '%',
    /* % */ CHAR_PLUS: '+',
    /* + */ CHAR_QUESTION_MARK: '?',
    /* ? */ CHAR_RIGHT_ANGLE_BRACKET: '>',
    /* > */ CHAR_RIGHT_CURLY_BRACE: '}',
    /* } */ CHAR_RIGHT_SQUARE_BRACKET: ']',
    /* ] */ CHAR_SEMICOLON: ';',
    /* ; */ CHAR_SINGLE_QUOTE: '\'',
    /* ' */ CHAR_SPACE: ' ',
    /*   */ CHAR_TAB: '\t',
    /* \t */ CHAR_UNDERSCORE: '_',
    /* _ */ CHAR_VERTICAL_LINE: '|',
    /* | */ CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\uFEFF' /* \uFEFF */ 
};
}),
"[project]/align/node_modules/braces/lib/parse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const stringify = __turbopack_context__.r("[project]/align/node_modules/braces/lib/stringify.js [app-route] (ecmascript)");
/**
 * Constants
 */ const { MAX_LENGTH, CHAR_BACKSLASH, /* \ */ CHAR_BACKTICK, /* ` */ CHAR_COMMA, /* , */ CHAR_DOT, /* . */ CHAR_LEFT_PARENTHESES, /* ( */ CHAR_RIGHT_PARENTHESES, /* ) */ CHAR_LEFT_CURLY_BRACE, /* { */ CHAR_RIGHT_CURLY_BRACE, /* } */ CHAR_LEFT_SQUARE_BRACKET, /* [ */ CHAR_RIGHT_SQUARE_BRACKET, /* ] */ CHAR_DOUBLE_QUOTE, /* " */ CHAR_SINGLE_QUOTE, /* ' */ CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_NOBREAK_SPACE } = __turbopack_context__.r("[project]/align/node_modules/braces/lib/constants.js [app-route] (ecmascript)");
/**
 * parse
 */ const parse = (input, options = {})=>{
    if (typeof input !== 'string') {
        throw new TypeError('Expected a string');
    }
    const opts = options || {};
    const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
    }
    const ast = {
        type: 'root',
        input,
        nodes: []
    };
    const stack = [
        ast
    ];
    let block = ast;
    let prev = ast;
    let brackets = 0;
    const length = input.length;
    let index = 0;
    let depth = 0;
    let value;
    /**
   * Helpers
   */ const advance = ()=>input[index++];
    const push = (node)=>{
        if (node.type === 'text' && prev.type === 'dot') {
            prev.type = 'text';
        }
        if (prev && prev.type === 'text' && node.type === 'text') {
            prev.value += node.value;
            return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
    };
    push({
        type: 'bos'
    });
    while(index < length){
        block = stack[stack.length - 1];
        value = advance();
        /**
     * Invalid chars
     */ if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
            continue;
        }
        /**
     * Escaped chars
     */ if (value === CHAR_BACKSLASH) {
            push({
                type: 'text',
                value: (options.keepEscaping ? value : '') + advance()
            });
            continue;
        }
        /**
     * Right square bracket (literal): ']'
     */ if (value === CHAR_RIGHT_SQUARE_BRACKET) {
            push({
                type: 'text',
                value: '\\' + value
            });
            continue;
        }
        /**
     * Left square bracket: '['
     */ if (value === CHAR_LEFT_SQUARE_BRACKET) {
            brackets++;
            let next;
            while(index < length && (next = advance())){
                value += next;
                if (next === CHAR_LEFT_SQUARE_BRACKET) {
                    brackets++;
                    continue;
                }
                if (next === CHAR_BACKSLASH) {
                    value += advance();
                    continue;
                }
                if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                    brackets--;
                    if (brackets === 0) {
                        break;
                    }
                }
            }
            push({
                type: 'text',
                value
            });
            continue;
        }
        /**
     * Parentheses
     */ if (value === CHAR_LEFT_PARENTHESES) {
            block = push({
                type: 'paren',
                nodes: []
            });
            stack.push(block);
            push({
                type: 'text',
                value
            });
            continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
            if (block.type !== 'paren') {
                push({
                    type: 'text',
                    value
                });
                continue;
            }
            block = stack.pop();
            push({
                type: 'text',
                value
            });
            block = stack[stack.length - 1];
            continue;
        }
        /**
     * Quotes: '|"|`
     */ if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
            const open = value;
            let next;
            if (options.keepQuotes !== true) {
                value = '';
            }
            while(index < length && (next = advance())){
                if (next === CHAR_BACKSLASH) {
                    value += next + advance();
                    continue;
                }
                if (next === open) {
                    if (options.keepQuotes === true) value += next;
                    break;
                }
                value += next;
            }
            push({
                type: 'text',
                value
            });
            continue;
        }
        /**
     * Left curly brace: '{'
     */ if (value === CHAR_LEFT_CURLY_BRACE) {
            depth++;
            const dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;
            const brace = {
                type: 'brace',
                open: true,
                close: false,
                dollar,
                depth,
                commas: 0,
                ranges: 0,
                nodes: []
            };
            block = push(brace);
            stack.push(block);
            push({
                type: 'open',
                value
            });
            continue;
        }
        /**
     * Right curly brace: '}'
     */ if (value === CHAR_RIGHT_CURLY_BRACE) {
            if (block.type !== 'brace') {
                push({
                    type: 'text',
                    value
                });
                continue;
            }
            const type = 'close';
            block = stack.pop();
            block.close = true;
            push({
                type,
                value
            });
            depth--;
            block = stack[stack.length - 1];
            continue;
        }
        /**
     * Comma: ','
     */ if (value === CHAR_COMMA && depth > 0) {
            if (block.ranges > 0) {
                block.ranges = 0;
                const open = block.nodes.shift();
                block.nodes = [
                    open,
                    {
                        type: 'text',
                        value: stringify(block)
                    }
                ];
            }
            push({
                type: 'comma',
                value
            });
            block.commas++;
            continue;
        }
        /**
     * Dot: '.'
     */ if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
            const siblings = block.nodes;
            if (depth === 0 || siblings.length === 0) {
                push({
                    type: 'text',
                    value
                });
                continue;
            }
            if (prev.type === 'dot') {
                block.range = [];
                prev.value += value;
                prev.type = 'range';
                if (block.nodes.length !== 3 && block.nodes.length !== 5) {
                    block.invalid = true;
                    block.ranges = 0;
                    prev.type = 'text';
                    continue;
                }
                block.ranges++;
                block.args = [];
                continue;
            }
            if (prev.type === 'range') {
                siblings.pop();
                const before = siblings[siblings.length - 1];
                before.value += prev.value + value;
                prev = before;
                block.ranges--;
                continue;
            }
            push({
                type: 'dot',
                value
            });
            continue;
        }
        /**
     * Text
     */ push({
            type: 'text',
            value
        });
    }
    // Mark imbalanced braces and brackets as invalid
    do {
        block = stack.pop();
        if (block.type !== 'root') {
            block.nodes.forEach((node)=>{
                if (!node.nodes) {
                    if (node.type === 'open') node.isOpen = true;
                    if (node.type === 'close') node.isClose = true;
                    if (!node.nodes) node.type = 'text';
                    node.invalid = true;
                }
            });
            // get the location of the block on parent.nodes (block's siblings)
            const parent = stack[stack.length - 1];
            const index = parent.nodes.indexOf(block);
            // replace the (invalid) block with it's nodes
            parent.nodes.splice(index, 1, ...block.nodes);
        }
    }while (stack.length > 0)
    push({
        type: 'eos'
    });
    return ast;
};
module.exports = parse;
}),
"[project]/align/node_modules/braces/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const stringify = __turbopack_context__.r("[project]/align/node_modules/braces/lib/stringify.js [app-route] (ecmascript)");
const compile = __turbopack_context__.r("[project]/align/node_modules/braces/lib/compile.js [app-route] (ecmascript)");
const expand = __turbopack_context__.r("[project]/align/node_modules/braces/lib/expand.js [app-route] (ecmascript)");
const parse = __turbopack_context__.r("[project]/align/node_modules/braces/lib/parse.js [app-route] (ecmascript)");
/**
 * Expand the given pattern or create a regex-compatible string.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
 * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */ const braces = (input, options = {})=>{
    let output = [];
    if (Array.isArray(input)) {
        for (const pattern of input){
            const result = braces.create(pattern, options);
            if (Array.isArray(result)) {
                output.push(...result);
            } else {
                output.push(result);
            }
        }
    } else {
        output = [].concat(braces.create(input, options));
    }
    if (options && options.expand === true && options.nodupes === true) {
        output = [
            ...new Set(output)
        ];
    }
    return output;
};
/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * // braces.parse(pattern, [, options]);
 * const ast = braces.parse('a/{b,c}/d');
 * console.log(ast);
 * ```
 * @param {String} pattern Brace pattern to parse
 * @param {Object} options
 * @return {Object} Returns an AST
 * @api public
 */ braces.parse = (input, options = {})=>parse(input, options);
/**
 * Creates a braces string from an AST, or an AST node.
 *
 * ```js
 * const braces = require('braces');
 * let ast = braces.parse('foo/{a,b}/bar');
 * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */ braces.stringify = (input, options = {})=>{
    if (typeof input === 'string') {
        return stringify(braces.parse(input, options), options);
    }
    return stringify(input, options);
};
/**
 * Compiles a brace pattern into a regex-compatible, optimized string.
 * This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.compile('a/{b,c}/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */ braces.compile = (input, options = {})=>{
    if (typeof input === 'string') {
        input = braces.parse(input, options);
    }
    return compile(input, options);
};
/**
 * Expands a brace pattern into an array. This method is called by the
 * main [braces](#braces) function when `options.expand` is true. Before
 * using this method it's recommended that you read the [performance notes](#performance))
 * and advantages of using [.compile](#compile) instead.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */ braces.expand = (input, options = {})=>{
    if (typeof input === 'string') {
        input = braces.parse(input, options);
    }
    let result = expand(input, options);
    // filter out empty strings if specified
    if (options.noempty === true) {
        result = result.filter(Boolean);
    }
    // filter out duplicates if specified
    if (options.nodupes === true) {
        result = [
            ...new Set(result)
        ];
    }
    return result;
};
/**
 * Processes a brace pattern and returns either an expanded array
 * (if `options.expand` is true), a highly optimized regex-compatible string.
 * This method is called by the main [braces](#braces) function.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */ braces.create = (input, options = {})=>{
    if (input === '' || input.length < 3) {
        return [
            input
        ];
    }
    return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
};
/**
 * Expose "braces"
 */ module.exports = braces;
}),
"[project]/align/node_modules/is-number/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */ module.exports = function(num) {
    if (typeof num === 'number') {
        return num - num === 0;
    }
    if (typeof num === 'string' && num.trim() !== '') {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
    }
    return false;
};
}),
"[project]/align/node_modules/to-regex-range/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */ const isNumber = __turbopack_context__.r("[project]/align/node_modules/is-number/index.js [app-route] (ecmascript)");
const toRegexRange = (min, max, options)=>{
    if (isNumber(min) === false) {
        throw new TypeError('toRegexRange: expected the first argument to be a number');
    }
    if (max === void 0 || min === max) {
        return String(min);
    }
    if (isNumber(max) === false) {
        throw new TypeError('toRegexRange: expected the second argument to be a number.');
    }
    let opts = {
        relaxZeros: true,
        ...options
    };
    if (typeof opts.strictZeros === 'boolean') {
        opts.relaxZeros = opts.strictZeros === false;
    }
    let relax = String(opts.relaxZeros);
    let shorthand = String(opts.shorthand);
    let capture = String(opts.capture);
    let wrap = String(opts.wrap);
    let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;
    if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
    }
    let a = Math.min(min, max);
    let b = Math.max(min, max);
    if (Math.abs(a - b) === 1) {
        let result = min + '|' + max;
        if (opts.capture) {
            return `(${result})`;
        }
        if (opts.wrap === false) {
            return result;
        }
        return `(?:${result})`;
    }
    let isPadded = hasPadding(min) || hasPadding(max);
    let state = {
        min,
        max,
        a,
        b
    };
    let positives = [];
    let negatives = [];
    if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
    }
    if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
    }
    if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
    }
    state.negatives = negatives;
    state.positives = positives;
    state.result = collatePatterns(negatives, positives, opts);
    if (opts.capture === true) {
        state.result = `(${state.result})`;
    } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
    }
    toRegexRange.cache[cacheKey] = state;
    return state.result;
};
function collatePatterns(neg, pos, options) {
    let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];
    let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];
    let intersected = filterPatterns(neg, pos, '-?', true, options) || [];
    let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
    return subpatterns.join('|');
}
function splitToRanges(min, max) {
    let nines = 1;
    let zeros = 1;
    let stop = countNines(min, nines);
    let stops = new Set([
        max
    ]);
    while(min <= stop && stop <= max){
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
    }
    stop = countZeros(max + 1, zeros) - 1;
    while(min < stop && stop <= max){
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
    }
    stops = [
        ...stops
    ];
    stops.sort(compare);
    return stops;
}
/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */ function rangeToPattern(start, stop, options) {
    if (start === stop) {
        return {
            pattern: start,
            count: [],
            digits: 0
        };
    }
    let zipped = zip(start, stop);
    let digits = zipped.length;
    let pattern = '';
    let count = 0;
    for(let i = 0; i < digits; i++){
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
            pattern += startDigit;
        } else if (startDigit !== '0' || stopDigit !== '9') {
            pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
            count++;
        }
    }
    if (count) {
        pattern += options.shorthand === true ? '\\d' : '[0-9]';
    }
    return {
        pattern,
        count: [
            count
        ],
        digits
    };
}
function splitToPatterns(min, max, tok, options) {
    let ranges = splitToRanges(min, max);
    let tokens = [];
    let start = min;
    let prev;
    for(let i = 0; i < ranges.length; i++){
        let max = ranges[i];
        let obj = rangeToPattern(String(start), String(max), options);
        let zeros = '';
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
            if (prev.count.length > 1) {
                prev.count.pop();
            }
            prev.count.push(obj.count[0]);
            prev.string = prev.pattern + toQuantifier(prev.count);
            start = max + 1;
            continue;
        }
        if (tok.isPadded) {
            zeros = padZeros(max, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max + 1;
        prev = obj;
    }
    return tokens;
}
function filterPatterns(arr, comparison, prefix, intersection, options) {
    let result = [];
    for (let ele of arr){
        let { string } = ele;
        // only push if _both_ are negative...
        if (!intersection && !contains(comparison, 'string', string)) {
            result.push(prefix + string);
        }
        // or _both_ are positive
        if (intersection && contains(comparison, 'string', string)) {
            result.push(prefix + string);
        }
    }
    return result;
}
/**
 * Zip strings
 */ function zip(a, b) {
    let arr = [];
    for(let i = 0; i < a.length; i++)arr.push([
        a[i],
        b[i]
    ]);
    return arr;
}
function compare(a, b) {
    return a > b ? 1 : b > a ? -1 : 0;
}
function contains(arr, key, val) {
    return arr.some((ele)=>ele[key] === val);
}
function countNines(min, len) {
    return Number(String(min).slice(0, -len) + '9'.repeat(len));
}
function countZeros(integer, zeros) {
    return integer - integer % Math.pow(10, zeros);
}
function toQuantifier(digits) {
    let [start = 0, stop = ''] = digits;
    if (stop || start > 1) {
        return `{${start + (stop ? ',' + stop : '')}}`;
    }
    return '';
}
function toCharacterClass(a, b, options) {
    return `[${a}${b - a === 1 ? '' : '-'}${b}]`;
}
function hasPadding(str) {
    return /^-?(0+)\d/.test(str);
}
function padZeros(value, tok, options) {
    if (!tok.isPadded) {
        return value;
    }
    let diff = Math.abs(tok.maxLen - String(value).length);
    let relax = options.relaxZeros !== false;
    switch(diff){
        case 0:
            return '';
        case 1:
            return relax ? '0?' : '0';
        case 2:
            return relax ? '0{0,2}' : '00';
        default:
            {
                return relax ? `0{0,${diff}}` : `0{${diff}}`;
            }
    }
}
/**
 * Cache
 */ toRegexRange.cache = {};
toRegexRange.clearCache = ()=>toRegexRange.cache = {};
/**
 * Expose `toRegexRange`
 */ module.exports = toRegexRange;
}),
"[project]/align/node_modules/fill-range/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */ const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const toRegexRange = __turbopack_context__.r("[project]/align/node_modules/to-regex-range/index.js [app-route] (ecmascript)");
const isObject = (val)=>val !== null && typeof val === 'object' && !Array.isArray(val);
const transform = (toNumber)=>{
    return (value)=>toNumber === true ? Number(value) : String(value);
};
const isValidValue = (value)=>{
    return typeof value === 'number' || typeof value === 'string' && value !== '';
};
const isNumber = (num)=>Number.isInteger(+num);
const zeros = (input)=>{
    let value = `${input}`;
    let index = -1;
    if (value[0] === '-') value = value.slice(1);
    if (value === '0') return false;
    while(value[++index] === '0');
    return index > 0;
};
const stringify = (start, end, options)=>{
    if (typeof start === 'string' || typeof end === 'string') {
        return true;
    }
    return options.stringify === true;
};
const pad = (input, maxLength, toNumber)=>{
    if (maxLength > 0) {
        let dash = input[0] === '-' ? '-' : '';
        if (dash) input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, '0');
    }
    if (toNumber === false) {
        return String(input);
    }
    return input;
};
const toMaxLen = (input, maxLength)=>{
    let negative = input[0] === '-' ? '-' : '';
    if (negative) {
        input = input.slice(1);
        maxLength--;
    }
    while(input.length < maxLength)input = '0' + input;
    return negative ? '-' + input : input;
};
const toSequence = (parts, options, maxLen)=>{
    parts.negatives.sort((a, b)=>a < b ? -1 : a > b ? 1 : 0);
    parts.positives.sort((a, b)=>a < b ? -1 : a > b ? 1 : 0);
    let prefix = options.capture ? '' : '?:';
    let positives = '';
    let negatives = '';
    let result;
    if (parts.positives.length) {
        positives = parts.positives.map((v)=>toMaxLen(String(v), maxLen)).join('|');
    }
    if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.map((v)=>toMaxLen(String(v), maxLen)).join('|')})`;
    }
    if (positives && negatives) {
        result = `${positives}|${negatives}`;
    } else {
        result = positives || negatives;
    }
    if (options.wrap) {
        return `(${prefix}${result})`;
    }
    return result;
};
const toRange = (a, b, isNumbers, options)=>{
    if (isNumbers) {
        return toRegexRange(a, b, {
            wrap: false,
            ...options
        });
    }
    let start = String.fromCharCode(a);
    if (a === b) return start;
    let stop = String.fromCharCode(b);
    return `[${start}-${stop}]`;
};
const toRegex = (start, end, options)=>{
    if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? '' : '?:';
        return wrap ? `(${prefix}${start.join('|')})` : start.join('|');
    }
    return toRegexRange(start, end, options);
};
const rangeError = (...args)=>{
    return new RangeError('Invalid range arguments: ' + util.inspect(...args));
};
const invalidRange = (start, end, options)=>{
    if (options.strictRanges === true) throw rangeError([
        start,
        end
    ]);
    return [];
};
const invalidStep = (step, options)=>{
    if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
    }
    return [];
};
const fillNumbers = (start, end, step = 1, options = {})=>{
    let a = Number(start);
    let b = Number(end);
    if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true) throw rangeError([
            start,
            end
        ]);
        return [];
    }
    // fix negative zero
    if (a === 0) a = 0;
    if (b === 0) b = 0;
    let descending = a > b;
    let startString = String(start);
    let endString = String(end);
    let stepString = String(step);
    step = Math.max(Math.abs(step), 1);
    let padded = zeros(startString) || zeros(endString) || zeros(stepString);
    let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
    let toNumber = padded === false && stringify(start, end, options) === false;
    let format = options.transform || transform(toNumber);
    if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
    }
    let parts = {
        negatives: [],
        positives: []
    };
    let push = (num)=>parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));
    let range = [];
    let index = 0;
    while(descending ? a >= b : a <= b){
        if (options.toRegex === true && step > 1) {
            push(a);
        } else {
            range.push(pad(format(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
    }
    if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options, maxLen) : toRegex(range, null, {
            wrap: false,
            ...options
        });
    }
    return range;
};
const fillLetters = (start, end, step = 1, options = {})=>{
    if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
    }
    let format = options.transform || ((val)=>String.fromCharCode(val));
    let a = `${start}`.charCodeAt(0);
    let b = `${end}`.charCodeAt(0);
    let descending = a > b;
    let min = Math.min(a, b);
    let max = Math.max(a, b);
    if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
    }
    let range = [];
    let index = 0;
    while(descending ? a >= b : a <= b){
        range.push(format(a, index));
        a = descending ? a - step : a + step;
        index++;
    }
    if (options.toRegex === true) {
        return toRegex(range, null, {
            wrap: false,
            options
        });
    }
    return range;
};
const fill = (start, end, step, options = {})=>{
    if (end == null && isValidValue(start)) {
        return [
            start
        ];
    }
    if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
    }
    if (typeof step === 'function') {
        return fill(start, end, 1, {
            transform: step
        });
    }
    if (isObject(step)) {
        return fill(start, end, 0, step);
    }
    let opts = {
        ...options
    };
    if (opts.capture === true) opts.wrap = true;
    step = step || opts.step || 1;
    if (!isNumber(step)) {
        if (step != null && !isObject(step)) return invalidStep(step, opts);
        return fill(start, end, 1, step);
    }
    if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
    }
    return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
};
module.exports = fill;
}),
"[project]/align/node_modules/binary-extensions/binary-extensions.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v(["3dm","3ds","3g2","3gp","7z","a","aac","adp","afdesign","afphoto","afpub","ai","aif","aiff","alz","ape","apk","appimage","ar","arj","asf","au","avi","bak","baml","bh","bin","bk","bmp","btif","bz2","bzip2","cab","caf","cgm","class","cmx","cpio","cr2","cur","dat","dcm","deb","dex","djvu","dll","dmg","dng","doc","docm","docx","dot","dotm","dra","DS_Store","dsk","dts","dtshd","dvb","dwg","dxf","ecelp4800","ecelp7470","ecelp9600","egg","eol","eot","epub","exe","f4v","fbs","fh","fla","flac","flatpak","fli","flv","fpx","fst","fvt","g3","gh","gif","graffle","gz","gzip","h261","h263","h264","icns","ico","ief","img","ipa","iso","jar","jpeg","jpg","jpgv","jpm","jxr","key","ktx","lha","lib","lvp","lz","lzh","lzma","lzo","m3u","m4a","m4v","mar","mdi","mht","mid","midi","mj2","mka","mkv","mmr","mng","mobi","mov","movie","mp3","mp4","mp4a","mpeg","mpg","mpga","mxu","nef","npx","numbers","nupkg","o","odp","ods","odt","oga","ogg","ogv","otf","ott","pages","pbm","pcx","pdb","pdf","pea","pgm","pic","png","pnm","pot","potm","potx","ppa","ppam","ppm","pps","ppsm","ppsx","ppt","pptm","pptx","psd","pya","pyc","pyo","pyv","qt","rar","ras","raw","resources","rgb","rip","rlc","rmf","rmvb","rpm","rtf","rz","s3m","s7z","scpt","sgi","shar","snap","sil","sketch","slk","smv","snk","so","stl","suo","sub","swf","tar","tbz","tbz2","tga","tgz","thmx","tif","tiff","tlz","ttc","ttf","txz","udf","uvh","uvi","uvm","uvp","uvs","uvu","viv","vob","war","wav","wax","wbmp","wdp","weba","webm","webp","whl","wim","wm","wma","wmv","wmx","woff","woff2","wrm","wvx","xbm","xif","xla","xlam","xls","xlsb","xlsm","xlsx","xlt","xltm","xltx","xm","xmind","xpi","xpm","xwd","xz","z","zip","zipx"]);}),
"[project]/align/node_modules/binary-extensions/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = __turbopack_context__.r("[project]/align/node_modules/binary-extensions/binary-extensions.json (json)");
}),
"[project]/align/node_modules/is-binary-path/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const binaryExtensions = __turbopack_context__.r("[project]/align/node_modules/binary-extensions/index.js [app-route] (ecmascript)");
const extensions = new Set(binaryExtensions);
module.exports = (filePath)=>extensions.has(path.extname(filePath).slice(1).toLowerCase());
}),
"[project]/align/node_modules/fsevents/fsevents.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 **  2020 by Philipp Dunkel, Ben Noordhuis, Elan Shankar, Paul Miller
 ** Licensed under MIT License.
 */ /* jshint node:true */ if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
const Native = (()=>{
    throw new Error('could not resolve "' + "./fsevents.node" + '" into a module');
})();
const events = Native.constants;
function watch(path, since, handler) {
    if (typeof path !== "string") {
        throw new TypeError(`fsevents argument 1 must be a string and not a ${typeof path}`);
    }
    if ("function" === typeof since && "undefined" === typeof handler) {
        handler = since;
        since = Native.flags.SinceNow;
    }
    if (typeof since !== "number") {
        throw new TypeError(`fsevents argument 2 must be a number and not a ${typeof since}`);
    }
    if (typeof handler !== "function") {
        throw new TypeError(`fsevents argument 3 must be a function and not a ${typeof handler}`);
    }
    let instance = Native.start(Native.global, path, since, handler);
    if (!instance) throw new Error(`could not watch: ${path}`);
    return ()=>{
        const result = instance ? Promise.resolve(instance).then(Native.stop) : Promise.resolve(undefined);
        instance = undefined;
        return result;
    };
}
function getInfo(path, flags) {
    return {
        path,
        flags,
        event: getEventType(flags),
        type: getFileType(flags),
        changes: getFileChanges(flags)
    };
}
function getFileType(flags) {
    if (events.ItemIsFile & flags) return "file";
    if (events.ItemIsDir & flags) return "directory";
    if (events.MustScanSubDirs & flags) return "directory";
    if (events.ItemIsSymlink & flags) return "symlink";
}
function anyIsTrue(obj) {
    for(let key in obj){
        if (obj[key]) return true;
    }
    return false;
}
function getEventType(flags) {
    if (events.ItemRemoved & flags) return "deleted";
    if (events.ItemRenamed & flags) return "moved";
    if (events.ItemCreated & flags) return "created";
    if (events.ItemModified & flags) return "modified";
    if (events.RootChanged & flags) return "root-changed";
    if (events.ItemCloned & flags) return "cloned";
    if (anyIsTrue(flags)) return "modified";
    return "unknown";
}
function getFileChanges(flags) {
    return {
        inode: !!(events.ItemInodeMetaMod & flags),
        finder: !!(events.ItemFinderInfoMod & flags),
        access: !!(events.ItemChangeOwner & flags),
        xattrs: !!(events.ItemXattrMod & flags)
    };
}
exports.watch = watch;
exports.getInfo = getInfo;
exports.constants = events;
}),
"[project]/align/node_modules/date-fns/constructFrom.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @name constructFrom
 * @category Generic Helpers
 * @summary Constructs a date using the reference date and the value
 *
 * @description
 * The function constructs a new date using the constructor from the reference
 * date and the given value. It helps to build generic functions that accept
 * date extensions.
 *
 * It defaults to `Date` if the passed reference date is a number or a string.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The reference date to take constructor from
 * @param value - The value to create the date
 *
 * @returns Date initialized using the given date and value
 *
 * @example
 * import { constructFrom } from 'date-fns'
 *
 * // A function that clones a date preserving the original type
 * function cloneDate<DateType extends Date(date: DateType): DateType {
 *   return constructFrom(
 *     date, // Use contrustor from the given date
 *     date.getTime() // Use the date value to create a new date
 *   )
 * }
 */ __turbopack_context__.s([
    "constructFrom",
    ()=>constructFrom,
    "default",
    ()=>__TURBOPACK__default__export__
]);
function constructFrom(date, value) {
    if (date instanceof Date) {
        return new date.constructor(value);
    } else {
        return new Date(value);
    }
}
const __TURBOPACK__default__export__ = constructFrom;
}),
"[project]/align/node_modules/date-fns/constructNow.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "constructNow",
    ()=>constructNow,
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$constructFrom$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/constructFrom.mjs [app-route] (ecmascript)");
;
function constructNow(date) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$constructFrom$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["constructFrom"])(date, Date.now());
}
const __TURBOPACK__default__export__ = constructNow;
}),
"[project]/align/node_modules/date-fns/toDate.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param argument - The value to convert
 *
 * @returns The parsed date in the local time zone
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "toDate",
    ()=>toDate
]);
function toDate(argument) {
    const argStr = Object.prototype.toString.call(argument);
    // Clone the date
    if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
        // Prevent the date to lose the milliseconds when passed to new Date() in IE10
        return new argument.constructor(+argument);
    } else if (typeof argument === "number" || argStr === "[object Number]" || typeof argument === "string" || argStr === "[object String]") {
        // TODO: Can we get rid of as?
        return new Date(argument);
    } else {
        // TODO: Can we get rid of as?
        return new Date(NaN);
    }
}
const __TURBOPACK__default__export__ = toDate;
}),
"[project]/align/node_modules/date-fns/compareAsc.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "compareAsc",
    ()=>compareAsc,
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/toDate.mjs [app-route] (ecmascript)");
;
function compareAsc(dateLeft, dateRight) {
    const _dateLeft = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toDate"])(dateLeft);
    const _dateRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toDate"])(dateRight);
    const diff = _dateLeft.getTime() - _dateRight.getTime();
    if (diff < 0) {
        return -1;
    } else if (diff > 0) {
        return 1;
    // Return 0 if diff is 0; return NaN if diff is NaN
    } else {
        return diff;
    }
}
const __TURBOPACK__default__export__ = compareAsc;
}),
"[project]/align/node_modules/date-fns/constants.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @module constants
 * @summary Useful constants
 * @description
 * Collection of useful date constants.
 *
 * The constants could be imported from `date-fns/constants`:
 *
 * ```ts
 * import { maxTime, minTime } from "./constants/date-fns/constants";
 *
 * function isAllowedTime(time) {
 *   return time <= maxTime && time >= minTime;
 * }
 * ```
 */ /**
 * @constant
 * @name daysInWeek
 * @summary Days in 1 week.
 */ __turbopack_context__.s([
    "daysInWeek",
    ()=>daysInWeek,
    "daysInYear",
    ()=>daysInYear,
    "maxTime",
    ()=>maxTime,
    "millisecondsInDay",
    ()=>millisecondsInDay,
    "millisecondsInHour",
    ()=>millisecondsInHour,
    "millisecondsInMinute",
    ()=>millisecondsInMinute,
    "millisecondsInSecond",
    ()=>millisecondsInSecond,
    "millisecondsInWeek",
    ()=>millisecondsInWeek,
    "minTime",
    ()=>minTime,
    "minutesInDay",
    ()=>minutesInDay,
    "minutesInHour",
    ()=>minutesInHour,
    "minutesInMonth",
    ()=>minutesInMonth,
    "minutesInYear",
    ()=>minutesInYear,
    "monthsInQuarter",
    ()=>monthsInQuarter,
    "monthsInYear",
    ()=>monthsInYear,
    "quartersInYear",
    ()=>quartersInYear,
    "secondsInDay",
    ()=>secondsInDay,
    "secondsInHour",
    ()=>secondsInHour,
    "secondsInMinute",
    ()=>secondsInMinute,
    "secondsInMonth",
    ()=>secondsInMonth,
    "secondsInQuarter",
    ()=>secondsInQuarter,
    "secondsInWeek",
    ()=>secondsInWeek,
    "secondsInYear",
    ()=>secondsInYear
]);
const daysInWeek = 7;
const daysInYear = 365.2425;
const maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1000;
const minTime = -maxTime;
const millisecondsInWeek = 604800000;
const millisecondsInDay = 86400000;
const millisecondsInMinute = 60000;
const millisecondsInHour = 3600000;
const millisecondsInSecond = 1000;
const minutesInYear = 525600;
const minutesInMonth = 43200;
const minutesInDay = 1440;
const minutesInHour = 60;
const monthsInQuarter = 3;
const monthsInYear = 12;
const quartersInYear = 4;
const secondsInHour = 3600;
const secondsInMinute = 60;
const secondsInDay = secondsInHour * 24;
const secondsInWeek = secondsInDay * 7;
const secondsInYear = secondsInDay * daysInYear;
const secondsInMonth = secondsInYear / 12;
const secondsInQuarter = secondsInMonth * 3;
}),
"[project]/align/node_modules/date-fns/differenceInCalendarMonths.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "differenceInCalendarMonths",
    ()=>differenceInCalendarMonths
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/toDate.mjs [app-route] (ecmascript)");
;
function differenceInCalendarMonths(dateLeft, dateRight) {
    const _dateLeft = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toDate"])(dateLeft);
    const _dateRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toDate"])(dateRight);
    const yearDiff = _dateLeft.getFullYear() - _dateRight.getFullYear();
    const monthDiff = _dateLeft.getMonth() - _dateRight.getMonth();
    return yearDiff * 12 + monthDiff;
}
const __TURBOPACK__default__export__ = differenceInCalendarMonths;
}),
"[project]/align/node_modules/date-fns/endOfDay.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "endOfDay",
    ()=>endOfDay
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/toDate.mjs [app-route] (ecmascript)");
;
function endOfDay(date) {
    const _date = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toDate"])(date);
    _date.setHours(23, 59, 59, 999);
    return _date;
}
const __TURBOPACK__default__export__ = endOfDay;
}),
"[project]/align/node_modules/date-fns/endOfMonth.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "endOfMonth",
    ()=>endOfMonth
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/toDate.mjs [app-route] (ecmascript)");
;
function endOfMonth(date) {
    const _date = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toDate"])(date);
    const month = _date.getMonth();
    _date.setFullYear(_date.getFullYear(), month + 1, 0);
    _date.setHours(23, 59, 59, 999);
    return _date;
}
const __TURBOPACK__default__export__ = endOfMonth;
}),
"[project]/align/node_modules/date-fns/isLastDayOfMonth.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "isLastDayOfMonth",
    ()=>isLastDayOfMonth
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$endOfDay$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/endOfDay.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$endOfMonth$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/endOfMonth.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/toDate.mjs [app-route] (ecmascript)");
;
;
;
function isLastDayOfMonth(date) {
    const _date = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toDate"])(date);
    return +(0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$endOfDay$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["endOfDay"])(_date) === +(0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$endOfMonth$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["endOfMonth"])(_date);
}
const __TURBOPACK__default__export__ = isLastDayOfMonth;
}),
"[project]/align/node_modules/date-fns/differenceInMonths.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "differenceInMonths",
    ()=>differenceInMonths
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$compareAsc$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/compareAsc.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$differenceInCalendarMonths$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/differenceInCalendarMonths.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$isLastDayOfMonth$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/isLastDayOfMonth.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/toDate.mjs [app-route] (ecmascript)");
;
;
;
;
function differenceInMonths(dateLeft, dateRight) {
    const _dateLeft = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toDate"])(dateLeft);
    const _dateRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toDate"])(dateRight);
    const sign = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$compareAsc$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["compareAsc"])(_dateLeft, _dateRight);
    const difference = Math.abs((0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$differenceInCalendarMonths$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["differenceInCalendarMonths"])(_dateLeft, _dateRight));
    let result;
    // Check for the difference of less than month
    if (difference < 1) {
        result = 0;
    } else {
        if (_dateLeft.getMonth() === 1 && _dateLeft.getDate() > 27) {
            // This will check if the date is end of Feb and assign a higher end of month date
            // to compare it with Jan
            _dateLeft.setDate(30);
        }
        _dateLeft.setMonth(_dateLeft.getMonth() - sign * difference);
        // Math.abs(diff in full months - diff in calendar months) === 1 if last calendar month is not full
        // If so, result must be decreased by 1 in absolute value
        let isLastMonthNotFull = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$compareAsc$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["compareAsc"])(_dateLeft, _dateRight) === -sign;
        // Check for cases of one full calendar month
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$isLastDayOfMonth$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isLastDayOfMonth"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toDate"])(dateLeft)) && difference === 1 && (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$compareAsc$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["compareAsc"])(dateLeft, _dateRight) === 1) {
            isLastMonthNotFull = false;
        }
        result = sign * (difference - Number(isLastMonthNotFull));
    }
    // Prevent negative zero
    return result === 0 ? 0 : result;
}
const __TURBOPACK__default__export__ = differenceInMonths;
}),
"[project]/align/node_modules/date-fns/_lib/getRoundingMethod.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getRoundingMethod",
    ()=>getRoundingMethod
]);
function getRoundingMethod(method) {
    return (number)=>{
        const round = method ? Math[method] : Math.trunc;
        const result = round(number);
        // Prevent negative zero
        return result === 0 ? 0 : result;
    };
}
}),
"[project]/align/node_modules/date-fns/differenceInMilliseconds.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "differenceInMilliseconds",
    ()=>differenceInMilliseconds
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/toDate.mjs [app-route] (ecmascript)");
;
function differenceInMilliseconds(dateLeft, dateRight) {
    return +(0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toDate"])(dateLeft) - +(0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toDate"])(dateRight);
}
const __TURBOPACK__default__export__ = differenceInMilliseconds;
}),
"[project]/align/node_modules/date-fns/differenceInSeconds.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "differenceInSeconds",
    ()=>differenceInSeconds
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$_lib$2f$getRoundingMethod$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/_lib/getRoundingMethod.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$differenceInMilliseconds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/differenceInMilliseconds.mjs [app-route] (ecmascript)");
;
;
function differenceInSeconds(dateLeft, dateRight, options) {
    const diff = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$differenceInMilliseconds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["differenceInMilliseconds"])(dateLeft, dateRight) / 1000;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$_lib$2f$getRoundingMethod$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRoundingMethod"])(options?.roundingMethod)(diff);
}
const __TURBOPACK__default__export__ = differenceInSeconds;
}),
"[project]/align/node_modules/date-fns/locale/en-US/_lib/formatDistance.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "formatDistance",
    ()=>formatDistance
]);
const formatDistanceLocale = {
    lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
    },
    xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
    },
    xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
    },
    aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
    },
    xHours: {
        one: "1 hour",
        other: "{{count}} hours"
    },
    xDays: {
        one: "1 day",
        other: "{{count}} days"
    },
    aboutXWeeks: {
        one: "about 1 week",
        other: "about {{count}} weeks"
    },
    xWeeks: {
        one: "1 week",
        other: "{{count}} weeks"
    },
    aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
    },
    xMonths: {
        one: "1 month",
        other: "{{count}} months"
    },
    aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
    },
    xYears: {
        one: "1 year",
        other: "{{count}} years"
    },
    overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
    },
    almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
    }
};
const formatDistance = (token, count, options)=>{
    let result;
    const tokenValue = formatDistanceLocale[token];
    if (typeof tokenValue === "string") {
        result = tokenValue;
    } else if (count === 1) {
        result = tokenValue.one;
    } else {
        result = tokenValue.other.replace("{{count}}", count.toString());
    }
    if (options?.addSuffix) {
        if (options.comparison && options.comparison > 0) {
            return "in " + result;
        } else {
            return result + " ago";
        }
    }
    return result;
};
}),
"[project]/align/node_modules/date-fns/locale/_lib/buildFormatLongFn.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "buildFormatLongFn",
    ()=>buildFormatLongFn
]);
function buildFormatLongFn(args) {
    return (options = {})=>{
        // TODO: Remove String()
        const width = options.width ? String(options.width) : args.defaultWidth;
        const format = args.formats[width] || args.formats[args.defaultWidth];
        return format;
    };
}
}),
"[project]/align/node_modules/date-fns/locale/en-US/_lib/formatLong.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "formatLong",
    ()=>formatLong
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$_lib$2f$buildFormatLongFn$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/locale/_lib/buildFormatLongFn.mjs [app-route] (ecmascript)");
;
const dateFormats = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
};
const timeFormats = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
};
const dateTimeFormats = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong = {
    date: (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$_lib$2f$buildFormatLongFn$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildFormatLongFn"])({
        formats: dateFormats,
        defaultWidth: "full"
    }),
    time: (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$_lib$2f$buildFormatLongFn$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildFormatLongFn"])({
        formats: timeFormats,
        defaultWidth: "full"
    }),
    dateTime: (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$_lib$2f$buildFormatLongFn$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildFormatLongFn"])({
        formats: dateTimeFormats,
        defaultWidth: "full"
    })
};
}),
"[project]/align/node_modules/date-fns/locale/en-US/_lib/formatRelative.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "formatRelative",
    ()=>formatRelative
]);
const formatRelativeLocale = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
};
const formatRelative = (token, _date, _baseDate, _options)=>formatRelativeLocale[token];
}),
"[project]/align/node_modules/date-fns/locale/_lib/buildLocalizeFn.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-disable no-unused-vars */ /**
 * The localize function argument callback which allows to convert raw value to
 * the actual type.
 *
 * @param value - The value to convert
 *
 * @returns The converted value
 */ /**
 * The map of localized values for each width.
 */ /**
 * The index type of the locale unit value. It types conversion of units of
 * values that don't start at 0 (i.e. quarters).
 */ /**
 * Converts the unit value to the tuple of values.
 */ /**
 * The tuple of localized era values. The first element represents BC,
 * the second element represents AD.
 */ /**
 * The tuple of localized quarter values. The first element represents Q1.
 */ /**
 * The tuple of localized day values. The first element represents Sunday.
 */ /**
 * The tuple of localized month values. The first element represents January.
 */ __turbopack_context__.s([
    "buildLocalizeFn",
    ()=>buildLocalizeFn
]);
function buildLocalizeFn(args) {
    return (value, options)=>{
        const context = options?.context ? String(options.context) : "standalone";
        let valuesArray;
        if (context === "formatting" && args.formattingValues) {
            const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
            const width = options?.width ? String(options.width) : defaultWidth;
            valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
        } else {
            const defaultWidth = args.defaultWidth;
            const width = options?.width ? String(options.width) : args.defaultWidth;
            valuesArray = args.values[width] || args.values[defaultWidth];
        }
        const index = args.argumentCallback ? args.argumentCallback(value) : value;
        // @ts-expect-error - For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!
        return valuesArray[index];
    };
}
}),
"[project]/align/node_modules/date-fns/locale/en-US/_lib/localize.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "localize",
    ()=>localize
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$_lib$2f$buildLocalizeFn$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/locale/_lib/buildLocalizeFn.mjs [app-route] (ecmascript)");
;
const eraValues = {
    narrow: [
        "B",
        "A"
    ],
    abbreviated: [
        "BC",
        "AD"
    ],
    wide: [
        "Before Christ",
        "Anno Domini"
    ]
};
const quarterValues = {
    narrow: [
        "1",
        "2",
        "3",
        "4"
    ],
    abbreviated: [
        "Q1",
        "Q2",
        "Q3",
        "Q4"
    ],
    wide: [
        "1st quarter",
        "2nd quarter",
        "3rd quarter",
        "4th quarter"
    ]
};
// Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
const monthValues = {
    narrow: [
        "J",
        "F",
        "M",
        "A",
        "M",
        "J",
        "J",
        "A",
        "S",
        "O",
        "N",
        "D"
    ],
    abbreviated: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
    ],
    wide: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
    ]
};
const dayValues = {
    narrow: [
        "S",
        "M",
        "T",
        "W",
        "T",
        "F",
        "S"
    ],
    short: [
        "Su",
        "Mo",
        "Tu",
        "We",
        "Th",
        "Fr",
        "Sa"
    ],
    abbreviated: [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
    ],
    wide: [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
    ]
};
const dayPeriodValues = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    }
};
const formattingDayPeriodValues = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    }
};
const ordinalNumber = (dirtyNumber, _options)=>{
    const number = Number(dirtyNumber);
    // If ordinal numbers depend on context, for example,
    // if they are different for different grammatical genders,
    // use `options.unit`.
    //
    // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
    // 'day', 'hour', 'minute', 'second'.
    const rem100 = number % 100;
    if (rem100 > 20 || rem100 < 10) {
        switch(rem100 % 10){
            case 1:
                return number + "st";
            case 2:
                return number + "nd";
            case 3:
                return number + "rd";
        }
    }
    return number + "th";
};
const localize = {
    ordinalNumber,
    era: (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$_lib$2f$buildLocalizeFn$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildLocalizeFn"])({
        values: eraValues,
        defaultWidth: "wide"
    }),
    quarter: (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$_lib$2f$buildLocalizeFn$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildLocalizeFn"])({
        values: quarterValues,
        defaultWidth: "wide",
        argumentCallback: (quarter)=>quarter - 1
    }),
    month: (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$_lib$2f$buildLocalizeFn$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildLocalizeFn"])({
        values: monthValues,
        defaultWidth: "wide"
    }),
    day: (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$_lib$2f$buildLocalizeFn$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildLocalizeFn"])({
        values: dayValues,
        defaultWidth: "wide"
    }),
    dayPeriod: (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$_lib$2f$buildLocalizeFn$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildLocalizeFn"])({
        values: dayPeriodValues,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: "wide"
    })
};
}),
"[project]/align/node_modules/date-fns/locale/_lib/buildMatchFn.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "buildMatchFn",
    ()=>buildMatchFn
]);
function buildMatchFn(args) {
    return (string, options = {})=>{
        const width = options.width;
        const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
        const matchResult = string.match(matchPattern);
        if (!matchResult) {
            return null;
        }
        const matchedString = matchResult[0];
        const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
        const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern)=>pattern.test(matchedString)) : findKey(parsePatterns, (pattern)=>pattern.test(matchedString));
        let value;
        value = args.valueCallback ? args.valueCallback(key) : key;
        value = options.valueCallback ? options.valueCallback(value) : value;
        const rest = string.slice(matchedString.length);
        return {
            value,
            rest
        };
    };
}
function findKey(object, predicate) {
    for(const key in object){
        if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
            return key;
        }
    }
    return undefined;
}
function findIndex(array, predicate) {
    for(let key = 0; key < array.length; key++){
        if (predicate(array[key])) {
            return key;
        }
    }
    return undefined;
}
}),
"[project]/align/node_modules/date-fns/locale/_lib/buildMatchPatternFn.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "buildMatchPatternFn",
    ()=>buildMatchPatternFn
]);
function buildMatchPatternFn(args) {
    return (string, options = {})=>{
        const matchResult = string.match(args.matchPattern);
        if (!matchResult) return null;
        const matchedString = matchResult[0];
        const parseResult = string.match(args.parsePattern);
        if (!parseResult) return null;
        let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
        value = options.valueCallback ? options.valueCallback(value) : value;
        const rest = string.slice(matchedString.length);
        return {
            value,
            rest
        };
    };
}
}),
"[project]/align/node_modules/date-fns/locale/en-US/_lib/match.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "match",
    ()=>match
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$_lib$2f$buildMatchFn$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/locale/_lib/buildMatchFn.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$_lib$2f$buildMatchPatternFn$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/locale/_lib/buildMatchPatternFn.mjs [app-route] (ecmascript)");
;
;
const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern = /\d+/i;
const matchEraPatterns = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
};
const parseEraPatterns = {
    any: [
        /^b/i,
        /^(a|c)/i
    ]
};
const matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
};
const parseQuarterPatterns = {
    any: [
        /1/i,
        /2/i,
        /3/i,
        /4/i
    ]
};
const matchMonthPatterns = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
const parseMonthPatterns = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^may/i,
        /^jun/i,
        /^jul/i,
        /^au/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
const parseDayPatterns = {
    narrow: [
        /^s/i,
        /^m/i,
        /^t/i,
        /^w/i,
        /^t/i,
        /^f/i,
        /^s/i
    ],
    any: [
        /^su/i,
        /^m/i,
        /^tu/i,
        /^w/i,
        /^th/i,
        /^f/i,
        /^sa/i
    ]
};
const matchDayPeriodPatterns = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
const parseDayPeriodPatterns = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
    }
};
const match = {
    ordinalNumber: (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$_lib$2f$buildMatchPatternFn$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildMatchPatternFn"])({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: (value)=>parseInt(value, 10)
    }),
    era: (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$_lib$2f$buildMatchFn$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildMatchFn"])({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns,
        defaultParseWidth: "any"
    }),
    quarter: (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$_lib$2f$buildMatchFn$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildMatchFn"])({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: "any",
        valueCallback: (index)=>index + 1
    }),
    month: (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$_lib$2f$buildMatchFn$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildMatchFn"])({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: "any"
    }),
    day: (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$_lib$2f$buildMatchFn$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildMatchFn"])({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns,
        defaultParseWidth: "any"
    }),
    dayPeriod: (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$_lib$2f$buildMatchFn$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildMatchFn"])({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: "any"
    })
};
}),
"[project]/align/node_modules/date-fns/locale/en-US.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "enUS",
    ()=>enUS
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$en$2d$US$2f$_lib$2f$formatDistance$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/locale/en-US/_lib/formatDistance.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$en$2d$US$2f$_lib$2f$formatLong$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/locale/en-US/_lib/formatLong.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$en$2d$US$2f$_lib$2f$formatRelative$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/locale/en-US/_lib/formatRelative.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$en$2d$US$2f$_lib$2f$localize$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/locale/en-US/_lib/localize.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$en$2d$US$2f$_lib$2f$match$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/locale/en-US/_lib/match.mjs [app-route] (ecmascript)");
;
;
;
;
;
const enUS = {
    code: "en-US",
    formatDistance: __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$en$2d$US$2f$_lib$2f$formatDistance$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatDistance"],
    formatLong: __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$en$2d$US$2f$_lib$2f$formatLong$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatLong"],
    formatRelative: __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$en$2d$US$2f$_lib$2f$formatRelative$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatRelative"],
    localize: __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$en$2d$US$2f$_lib$2f$localize$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["localize"],
    match: __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$en$2d$US$2f$_lib$2f$match$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["match"],
    options: {
        weekStartsOn: 0 /* Sunday */ ,
        firstWeekContainsDate: 1
    }
};
const __TURBOPACK__default__export__ = enUS;
}),
"[project]/align/node_modules/date-fns/locale/en-US.mjs [app-route] (ecmascript) <export enUS as defaultLocale>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "defaultLocale",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$en$2d$US$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["enUS"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$en$2d$US$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/locale/en-US.mjs [app-route] (ecmascript)");
}),
"[project]/align/node_modules/date-fns/_lib/defaultOptions.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getDefaultOptions",
    ()=>getDefaultOptions,
    "setDefaultOptions",
    ()=>setDefaultOptions
]);
let defaultOptions = {};
function getDefaultOptions() {
    return defaultOptions;
}
function setDefaultOptions(newOptions) {
    defaultOptions = newOptions;
}
}),
"[project]/align/node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getTimezoneOffsetInMilliseconds",
    ()=>getTimezoneOffsetInMilliseconds
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/toDate.mjs [app-route] (ecmascript)");
;
function getTimezoneOffsetInMilliseconds(date) {
    const _date = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toDate"])(date);
    const utcDate = new Date(Date.UTC(_date.getFullYear(), _date.getMonth(), _date.getDate(), _date.getHours(), _date.getMinutes(), _date.getSeconds(), _date.getMilliseconds()));
    utcDate.setUTCFullYear(_date.getFullYear());
    return +date - +utcDate;
}
}),
"[project]/align/node_modules/date-fns/formatDistance.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "formatDistance",
    ()=>formatDistance
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$compareAsc$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/compareAsc.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$constants$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/constants.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$differenceInMonths$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/differenceInMonths.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$differenceInSeconds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/differenceInSeconds.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/toDate.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$en$2d$US$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__enUS__as__defaultLocale$3e$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/locale/en-US.mjs [app-route] (ecmascript) <export enUS as defaultLocale>");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$_lib$2f$defaultOptions$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/_lib/defaultOptions.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$_lib$2f$getTimezoneOffsetInMilliseconds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.mjs [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
function formatDistance(date, baseDate, options) {
    const defaultOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$_lib$2f$defaultOptions$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getDefaultOptions"])();
    const locale = options?.locale ?? defaultOptions.locale ?? __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$locale$2f$en$2d$US$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__enUS__as__defaultLocale$3e$__["defaultLocale"];
    const minutesInAlmostTwoDays = 2520;
    const comparison = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$compareAsc$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["compareAsc"])(date, baseDate);
    if (isNaN(comparison)) {
        throw new RangeError("Invalid time value");
    }
    const localizeOptions = Object.assign({}, options, {
        addSuffix: options?.addSuffix,
        comparison: comparison
    });
    let dateLeft;
    let dateRight;
    if (comparison > 0) {
        dateLeft = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toDate"])(baseDate);
        dateRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toDate"])(date);
    } else {
        dateLeft = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toDate"])(date);
        dateRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$toDate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toDate"])(baseDate);
    }
    const seconds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$differenceInSeconds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["differenceInSeconds"])(dateRight, dateLeft);
    const offsetInSeconds = ((0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$_lib$2f$getTimezoneOffsetInMilliseconds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getTimezoneOffsetInMilliseconds"])(dateRight) - (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$_lib$2f$getTimezoneOffsetInMilliseconds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getTimezoneOffsetInMilliseconds"])(dateLeft)) / 1000;
    const minutes = Math.round((seconds - offsetInSeconds) / 60);
    let months;
    // 0 up to 2 mins
    if (minutes < 2) {
        if (options?.includeSeconds) {
            if (seconds < 5) {
                return locale.formatDistance("lessThanXSeconds", 5, localizeOptions);
            } else if (seconds < 10) {
                return locale.formatDistance("lessThanXSeconds", 10, localizeOptions);
            } else if (seconds < 20) {
                return locale.formatDistance("lessThanXSeconds", 20, localizeOptions);
            } else if (seconds < 40) {
                return locale.formatDistance("halfAMinute", 0, localizeOptions);
            } else if (seconds < 60) {
                return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
            } else {
                return locale.formatDistance("xMinutes", 1, localizeOptions);
            }
        } else {
            if (minutes === 0) {
                return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
            } else {
                return locale.formatDistance("xMinutes", minutes, localizeOptions);
            }
        }
    // 2 mins up to 0.75 hrs
    } else if (minutes < 45) {
        return locale.formatDistance("xMinutes", minutes, localizeOptions);
    // 0.75 hrs up to 1.5 hrs
    } else if (minutes < 90) {
        return locale.formatDistance("aboutXHours", 1, localizeOptions);
    // 1.5 hrs up to 24 hrs
    } else if (minutes < __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$constants$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["minutesInDay"]) {
        const hours = Math.round(minutes / 60);
        return locale.formatDistance("aboutXHours", hours, localizeOptions);
    // 1 day up to 1.75 days
    } else if (minutes < minutesInAlmostTwoDays) {
        return locale.formatDistance("xDays", 1, localizeOptions);
    // 1.75 days up to 30 days
    } else if (minutes < __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$constants$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["minutesInMonth"]) {
        const days = Math.round(minutes / __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$constants$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["minutesInDay"]);
        return locale.formatDistance("xDays", days, localizeOptions);
    // 1 month up to 2 months
    } else if (minutes < __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$constants$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["minutesInMonth"] * 2) {
        months = Math.round(minutes / __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$constants$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["minutesInMonth"]);
        return locale.formatDistance("aboutXMonths", months, localizeOptions);
    }
    months = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$differenceInMonths$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["differenceInMonths"])(dateRight, dateLeft);
    // 2 months up to 12 months
    if (months < 12) {
        const nearestMonth = Math.round(minutes / __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$constants$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["minutesInMonth"]);
        return locale.formatDistance("xMonths", nearestMonth, localizeOptions);
    // 1 year up to max Date
    } else {
        const monthsSinceStartOfYear = months % 12;
        const years = Math.trunc(months / 12);
        // N years up to 1 years 3 months
        if (monthsSinceStartOfYear < 3) {
            return locale.formatDistance("aboutXYears", years, localizeOptions);
        // N years 3 months up to N years 9 months
        } else if (monthsSinceStartOfYear < 9) {
            return locale.formatDistance("overXYears", years, localizeOptions);
        // N years 9 months up to N year 12 months
        } else {
            return locale.formatDistance("almostXYears", years + 1, localizeOptions);
        }
    }
}
const __TURBOPACK__default__export__ = formatDistance;
}),
"[project]/align/node_modules/date-fns/formatDistanceToNow.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "formatDistanceToNow",
    ()=>formatDistanceToNow
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$constructNow$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/constructNow.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$formatDistance$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/date-fns/formatDistance.mjs [app-route] (ecmascript)");
;
;
function formatDistanceToNow(date, options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$formatDistance$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatDistance"])(date, (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$date$2d$fns$2f$constructNow$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["constructNow"])(date), options);
}
const __TURBOPACK__default__export__ = formatDistanceToNow;
}),
"[project]/align/node_modules/chalk/source/templates.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
const ESCAPES = new Map([
    [
        'n',
        '\n'
    ],
    [
        'r',
        '\r'
    ],
    [
        't',
        '\t'
    ],
    [
        'b',
        '\b'
    ],
    [
        'f',
        '\f'
    ],
    [
        'v',
        '\v'
    ],
    [
        '0',
        '\0'
    ],
    [
        '\\',
        '\\'
    ],
    [
        'e',
        '\u001B'
    ],
    [
        'a',
        '\u0007'
    ]
]);
function unescape(c) {
    const u = c[0] === 'u';
    const bracket = c[1] === '{';
    if (u && !bracket && c.length === 5 || c[0] === 'x' && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
    }
    if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
    }
    return ESCAPES.get(c) || c;
}
function parseArguments(name, arguments_) {
    const results = [];
    const chunks = arguments_.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks){
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
            results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
            results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character)=>escape ? unescape(escape) : character));
        } else {
            throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
    }
    return results;
}
function parseStyle(style) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while((matches = STYLE_REGEX.exec(style)) !== null){
        const name = matches[1];
        if (matches[2]) {
            const args = parseArguments(name, matches[2]);
            results.push([
                name
            ].concat(args));
        } else {
            results.push([
                name
            ]);
        }
    }
    return results;
}
function buildStyle(chalk, styles) {
    const enabled = {};
    for (const layer of styles){
        for (const style of layer.styles){
            enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
    }
    let current = chalk;
    for (const [styleName, styles] of Object.entries(enabled)){
        if (!Array.isArray(styles)) {
            continue;
        }
        if (!(styleName in current)) {
            throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
    }
    return current;
}
module.exports = (chalk, temporary)=>{
    const styles = [];
    const chunks = [];
    let chunk = [];
    // eslint-disable-next-line max-params
    temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character)=>{
        if (escapeCharacter) {
            chunk.push(unescape(escapeCharacter));
        } else if (style) {
            const string = chunk.join('');
            chunk = [];
            chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
            styles.push({
                inverse,
                styles: parseStyle(style)
            });
        } else if (close) {
            if (styles.length === 0) {
                throw new Error('Found extraneous } in Chalk template literal');
            }
            chunks.push(buildStyle(chalk, styles)(chunk.join('')));
            chunk = [];
            styles.pop();
        } else {
            chunk.push(character);
        }
    });
    chunks.push(chunk.join(''));
    if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
        throw new Error(errMessage);
    }
    return chunks.join('');
};
}),
"[project]/align/node_modules/chalk/source/util.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const stringReplaceAll = (string, substring, replacer)=>{
    let index = string.indexOf(substring);
    if (index === -1) {
        return string;
    }
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = '';
    do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
    }while (index !== -1)
    returnValue += string.substr(endIndex);
    return returnValue;
};
const stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index)=>{
    let endIndex = 0;
    let returnValue = '';
    do {
        const gotCR = string[index - 1] === '\r';
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
        endIndex = index + 1;
        index = string.indexOf('\n', endIndex);
    }while (index !== -1)
    returnValue += string.substr(endIndex);
    return returnValue;
};
module.exports = {
    stringReplaceAll,
    stringEncaseCRLFWithFirstIndex
};
}),
"[project]/align/node_modules/chalk/source/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const ansiStyles = __turbopack_context__.r("[project]/align/node_modules/ansi-styles/index.js [app-route] (ecmascript)");
const { stdout: stdoutColor, stderr: stderrColor } = __turbopack_context__.r("[project]/align/node_modules/supports-color/index.js [app-route] (ecmascript)");
const { stringReplaceAll, stringEncaseCRLFWithFirstIndex } = __turbopack_context__.r("[project]/align/node_modules/chalk/source/util.js [app-route] (ecmascript)");
const { isArray } = Array;
// `supportsColor.level`  `ansiStyles.color[name]` mapping
const levelMapping = [
    'ansi',
    'ansi',
    'ansi256',
    'ansi16m'
];
const styles = Object.create(null);
const applyOptions = (object, options = {})=>{
    if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error('The `level` option should be an integer from 0 to 3');
    }
    // Detect level if not set manually
    const colorLevel = stdoutColor ? stdoutColor.level : 0;
    object.level = options.level === undefined ? colorLevel : options.level;
};
class ChalkClass {
    constructor(options){
        // eslint-disable-next-line no-constructor-return
        return chalkFactory(options);
    }
}
const chalkFactory = (options)=>{
    const chalk = {};
    applyOptions(chalk, options);
    chalk.template = (...arguments_)=>chalkTag(chalk.template, ...arguments_);
    Object.setPrototypeOf(chalk, Chalk.prototype);
    Object.setPrototypeOf(chalk.template, chalk);
    chalk.template.constructor = ()=>{
        throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
    };
    chalk.template.Instance = ChalkClass;
    return chalk.template;
};
function Chalk(options) {
    return chalkFactory(options);
}
for (const [styleName, style] of Object.entries(ansiStyles)){
    styles[styleName] = {
        get () {
            const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
            Object.defineProperty(this, styleName, {
                value: builder
            });
            return builder;
        }
    };
}
styles.visible = {
    get () {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, 'visible', {
            value: builder
        });
        return builder;
    }
};
const usedModels = [
    'rgb',
    'hex',
    'keyword',
    'hsl',
    'hsv',
    'hwb',
    'ansi',
    'ansi256'
];
for (const model of usedModels){
    styles[model] = {
        get () {
            const { level } = this;
            return function(...arguments_) {
                const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
                return createBuilder(this, styler, this._isEmpty);
            };
        }
    };
}
for (const model of usedModels){
    const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
        get () {
            const { level } = this;
            return function(...arguments_) {
                const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
                return createBuilder(this, styler, this._isEmpty);
            };
        }
    };
}
const proto = Object.defineProperties(()=>{}, {
    ...styles,
    level: {
        enumerable: true,
        get () {
            return this._generator.level;
        },
        set (level) {
            this._generator.level = level;
        }
    }
});
const createStyler = (open, close, parent)=>{
    let openAll;
    let closeAll;
    if (parent === undefined) {
        openAll = open;
        closeAll = close;
    } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
    }
    return {
        open,
        close,
        openAll,
        closeAll,
        parent
    };
};
const createBuilder = (self, _styler, _isEmpty)=>{
    const builder = (...arguments_)=>{
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
            // Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`
            return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        // Single argument is hot path, implicit coercion is faster than anything
        // eslint-disable-next-line no-implicit-coercion
        return applyStyle(builder, arguments_.length === 1 ? '' + arguments_[0] : arguments_.join(' '));
    };
    // We alter the prototype because we must return a function, but there is
    // no way to create a function with a different prototype
    Object.setPrototypeOf(builder, proto);
    builder._generator = self;
    builder._styler = _styler;
    builder._isEmpty = _isEmpty;
    return builder;
};
const applyStyle = (self, string)=>{
    if (self.level <= 0 || !string) {
        return self._isEmpty ? '' : string;
    }
    let styler = self._styler;
    if (styler === undefined) {
        return string;
    }
    const { openAll, closeAll } = styler;
    if (string.indexOf('\u001B') !== -1) {
        while(styler !== undefined){
            // Replace any instances already present with a re-opening code
            // otherwise only the part of the string until said closing code
            // will be colored, and the rest will simply be 'plain'.
            string = stringReplaceAll(string, styler.close, styler.open);
            styler = styler.parent;
        }
    }
    // We can move both next actions out of loop, because remaining actions in loop won't have
    // any/visible effect on parts we add here. Close the styling before a linebreak and reopen
    // after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
    const lfIndex = string.indexOf('\n');
    if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
    }
    return openAll + string + closeAll;
};
let template;
const chalkTag = (chalk, ...strings)=>{
    const [firstString] = strings;
    if (!isArray(firstString) || !isArray(firstString.raw)) {
        // If chalk() was called by itself or with a string,
        // return the string itself as a string.
        return strings.join(' ');
    }
    const arguments_ = strings.slice(1);
    const parts = [
        firstString.raw[0]
    ];
    for(let i = 1; i < firstString.length; i++){
        parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'), String(firstString.raw[i]));
    }
    if (template === undefined) {
        template = __turbopack_context__.r("[project]/align/node_modules/chalk/source/templates.js [app-route] (ecmascript)");
    }
    return template(chalk, parts.join(''));
};
Object.defineProperties(Chalk.prototype, styles);
const chalk = Chalk(); // eslint-disable-line new-cap
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({
    level: stderrColor ? stderrColor.level : 0
}); // eslint-disable-line new-cap
chalk.stderr.supportsColor = stderrColor;
module.exports = chalk;
}),
"[project]/align/node_modules/opik/node_modules/chalk/source/vendor/ansi-styles/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "backgroundColorNames",
    ()=>backgroundColorNames,
    "colorNames",
    ()=>colorNames,
    "default",
    ()=>__TURBOPACK__default__export__,
    "foregroundColorNames",
    ()=>foregroundColorNames,
    "modifierNames",
    ()=>modifierNames
]);
const ANSI_BACKGROUND_OFFSET = 10;
const wrapAnsi16 = (offset = 0)=>(code)=>`\u001B[${code + offset}m`;
const wrapAnsi256 = (offset = 0)=>(code)=>`\u001B[${38 + offset};5;${code}m`;
const wrapAnsi16m = (offset = 0)=>(red, green, blue)=>`\u001B[${38 + offset};2;${red};${green};${blue}m`;
const styles = {
    modifier: {
        reset: [
            0,
            0
        ],
        // 21 isn't widely supported and 22 does the same thing
        bold: [
            1,
            22
        ],
        dim: [
            2,
            22
        ],
        italic: [
            3,
            23
        ],
        underline: [
            4,
            24
        ],
        overline: [
            53,
            55
        ],
        inverse: [
            7,
            27
        ],
        hidden: [
            8,
            28
        ],
        strikethrough: [
            9,
            29
        ]
    },
    color: {
        black: [
            30,
            39
        ],
        red: [
            31,
            39
        ],
        green: [
            32,
            39
        ],
        yellow: [
            33,
            39
        ],
        blue: [
            34,
            39
        ],
        magenta: [
            35,
            39
        ],
        cyan: [
            36,
            39
        ],
        white: [
            37,
            39
        ],
        // Bright color
        blackBright: [
            90,
            39
        ],
        gray: [
            90,
            39
        ],
        grey: [
            90,
            39
        ],
        redBright: [
            91,
            39
        ],
        greenBright: [
            92,
            39
        ],
        yellowBright: [
            93,
            39
        ],
        blueBright: [
            94,
            39
        ],
        magentaBright: [
            95,
            39
        ],
        cyanBright: [
            96,
            39
        ],
        whiteBright: [
            97,
            39
        ]
    },
    bgColor: {
        bgBlack: [
            40,
            49
        ],
        bgRed: [
            41,
            49
        ],
        bgGreen: [
            42,
            49
        ],
        bgYellow: [
            43,
            49
        ],
        bgBlue: [
            44,
            49
        ],
        bgMagenta: [
            45,
            49
        ],
        bgCyan: [
            46,
            49
        ],
        bgWhite: [
            47,
            49
        ],
        // Bright color
        bgBlackBright: [
            100,
            49
        ],
        bgGray: [
            100,
            49
        ],
        bgGrey: [
            100,
            49
        ],
        bgRedBright: [
            101,
            49
        ],
        bgGreenBright: [
            102,
            49
        ],
        bgYellowBright: [
            103,
            49
        ],
        bgBlueBright: [
            104,
            49
        ],
        bgMagentaBright: [
            105,
            49
        ],
        bgCyanBright: [
            106,
            49
        ],
        bgWhiteBright: [
            107,
            49
        ]
    }
};
const modifierNames = Object.keys(styles.modifier);
const foregroundColorNames = Object.keys(styles.color);
const backgroundColorNames = Object.keys(styles.bgColor);
const colorNames = [
    ...foregroundColorNames,
    ...backgroundColorNames
];
function assembleStyles() {
    const codes = new Map();
    for (const [groupName, group] of Object.entries(styles)){
        for (const [styleName, style] of Object.entries(group)){
            styles[styleName] = {
                open: `\u001B[${style[0]}m`,
                close: `\u001B[${style[1]}m`
            };
            group[styleName] = styles[styleName];
            codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
            value: group,
            enumerable: false
        });
    }
    Object.defineProperty(styles, 'codes', {
        value: codes,
        enumerable: false
    });
    styles.color.close = '\u001B[39m';
    styles.bgColor.close = '\u001B[49m';
    styles.color.ansi = wrapAnsi16();
    styles.color.ansi256 = wrapAnsi256();
    styles.color.ansi16m = wrapAnsi16m();
    styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
    styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
    styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
    // From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
    Object.defineProperties(styles, {
        rgbToAnsi256: {
            value (red, green, blue) {
                // We use the extended greyscale palette here, with the exception of
                // black and white. normal palette only has 4 greyscale shades.
                if (red === green && green === blue) {
                    if (red < 8) {
                        return 16;
                    }
                    if (red > 248) {
                        return 231;
                    }
                    return Math.round((red - 8) / 247 * 24) + 232;
                }
                return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
            },
            enumerable: false
        },
        hexToRgb: {
            value (hex) {
                const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
                if (!matches) {
                    return [
                        0,
                        0,
                        0
                    ];
                }
                let [colorString] = matches;
                if (colorString.length === 3) {
                    colorString = [
                        ...colorString
                    ].map((character)=>character + character).join('');
                }
                const integer = Number.parseInt(colorString, 16);
                return [
                    /* eslint-disable no-bitwise */ integer >> 16 & 0xFF,
                    integer >> 8 & 0xFF,
                    integer & 0xFF
                ];
            },
            enumerable: false
        },
        hexToAnsi256: {
            value: (hex)=>styles.rgbToAnsi256(...styles.hexToRgb(hex)),
            enumerable: false
        },
        ansi256ToAnsi: {
            value (code) {
                if (code < 8) {
                    return 30 + code;
                }
                if (code < 16) {
                    return 90 + (code - 8);
                }
                let red;
                let green;
                let blue;
                if (code >= 232) {
                    red = ((code - 232) * 10 + 8) / 255;
                    green = red;
                    blue = red;
                } else {
                    code -= 16;
                    const remainder = code % 36;
                    red = Math.floor(code / 36) / 5;
                    green = Math.floor(remainder / 6) / 5;
                    blue = remainder % 6 / 5;
                }
                const value = Math.max(red, green, blue) * 2;
                if (value === 0) {
                    return 30;
                }
                // eslint-disable-next-line no-bitwise
                let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
                if (value === 2) {
                    result += 60;
                }
                return result;
            },
            enumerable: false
        },
        rgbToAnsi: {
            value: (red, green, blue)=>styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
            enumerable: false
        },
        hexToAnsi: {
            value: (hex)=>styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
            enumerable: false
        }
    });
    return styles;
}
const ansiStyles = assembleStyles();
const __TURBOPACK__default__export__ = ansiStyles;
}),
"[project]/align/node_modules/opik/node_modules/chalk/source/vendor/supports-color/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createSupportsColor",
    ()=>createSupportsColor,
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:os [external] (node:os, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$tty__$5b$external$5d$__$28$node$3a$tty$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:tty [external] (node:tty, cjs)");
;
;
;
// From: https://github.com/sindresorhus/has-flag/blob/main/index.js
/// function hasFlag(flag, argv = globalThis.Deno?.args ?? process.argv) {
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].argv) {
    const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf('--');
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
const { env } = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"];
let flagForceColor;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
    flagForceColor = 0;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
    flagForceColor = 1;
}
function envForceColor() {
    if ('FORCE_COLOR' in env) {
        if (env.FORCE_COLOR === 'true') {
            return 1;
        }
        if (env.FORCE_COLOR === 'false') {
            return 0;
        }
        return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
    }
}
function translateLevel(level) {
    if (level === 0) {
        return false;
    }
    return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
    };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
    const noFlagForceColor = envForceColor();
    if (noFlagForceColor !== undefined) {
        flagForceColor = noFlagForceColor;
    }
    const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
    if (forceColor === 0) {
        return 0;
    }
    if (sniffFlags) {
        if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
            return 3;
        }
        if (hasFlag('color=256')) {
            return 2;
        }
    }
    // Check for Azure DevOps pipelines.
    // Has to be above the `!streamIsTTY` check.
    if ('TF_BUILD' in env && 'AGENT_NAME' in env) {
        return 1;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
        return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === 'dumb') {
        return min;
    }
    if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].platform === 'win32') {
        // Windows 10 build 10586 is the first Windows release that supports 256 colors.
        // Windows 10 build 14931 is the first release that supports 16m/TrueColor.
        const osRelease = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["default"].release().split('.');
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10_586) {
            return Number(osRelease[2]) >= 14_931 ? 3 : 2;
        }
        return 1;
    }
    if ('CI' in env) {
        if ([
            'GITHUB_ACTIONS',
            'GITEA_ACTIONS',
            'CIRCLECI'
        ].some((key)=>key in env)) {
            return 3;
        }
        if ([
            'TRAVIS',
            'APPVEYOR',
            'GITLAB_CI',
            'BUILDKITE',
            'DRONE'
        ].some((sign)=>sign in env) || env.CI_NAME === 'codeship') {
            return 1;
        }
        return min;
    }
    if ('TEAMCITY_VERSION' in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === 'truecolor') {
        return 3;
    }
    if (env.TERM === 'xterm-kitty') {
        return 3;
    }
    if (env.TERM === 'xterm-ghostty') {
        return 3;
    }
    if (env.TERM === 'wezterm') {
        return 3;
    }
    if ('TERM_PROGRAM' in env) {
        const version = Number.parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
        switch(env.TERM_PROGRAM){
            case 'iTerm.app':
                {
                    return version >= 3 ? 3 : 2;
                }
            case 'Apple_Terminal':
                {
                    return 2;
                }
        }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
    }
    if ('COLORTERM' in env) {
        return 1;
    }
    return min;
}
function createSupportsColor(stream, options = {}) {
    const level = _supportsColor(stream, {
        streamIsTTY: stream && stream.isTTY,
        ...options
    });
    return translateLevel(level);
}
const supportsColor = {
    stdout: createSupportsColor({
        isTTY: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$tty__$5b$external$5d$__$28$node$3a$tty$2c$__cjs$29$__["default"].isatty(1)
    }),
    stderr: createSupportsColor({
        isTTY: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$tty__$5b$external$5d$__$28$node$3a$tty$2c$__cjs$29$__["default"].isatty(2)
    })
};
const __TURBOPACK__default__export__ = supportsColor;
}),
"[project]/align/node_modules/opik/node_modules/chalk/source/utilities.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// TODO: When targeting Node.js 16, use `String.prototype.replaceAll`.
__turbopack_context__.s([
    "stringEncaseCRLFWithFirstIndex",
    ()=>stringEncaseCRLFWithFirstIndex,
    "stringReplaceAll",
    ()=>stringReplaceAll
]);
function stringReplaceAll(string, substring, replacer) {
    let index = string.indexOf(substring);
    if (index === -1) {
        return string;
    }
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = '';
    do {
        returnValue += string.slice(endIndex, index) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
    }while (index !== -1)
    returnValue += string.slice(endIndex);
    return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
    let endIndex = 0;
    let returnValue = '';
    do {
        const gotCR = string[index - 1] === '\r';
        returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
        endIndex = index + 1;
        index = string.indexOf('\n', endIndex);
    }while (index !== -1)
    returnValue += string.slice(endIndex);
    return returnValue;
}
}),
"[project]/align/node_modules/opik/node_modules/chalk/source/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Chalk",
    ()=>Chalk,
    "chalkStderr",
    ()=>chalkStderr,
    "default",
    ()=>__TURBOPACK__default__export__,
    "supportsColor",
    ()=>stdoutColor,
    "supportsColorStderr",
    ()=>stderrColor
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$opik$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/opik/node_modules/chalk/source/vendor/ansi-styles/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$opik$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$supports$2d$color$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/opik/node_modules/chalk/source/vendor/supports-color/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$opik$2f$node_modules$2f$chalk$2f$source$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/opik/node_modules/chalk/source/utilities.js [app-route] (ecmascript)");
;
;
;
const { stdout: stdoutColor, stderr: stderrColor } = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$opik$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$supports$2d$color$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"];
const GENERATOR = Symbol('GENERATOR');
const STYLER = Symbol('STYLER');
const IS_EMPTY = Symbol('IS_EMPTY');
// `supportsColor.level`  `ansiStyles.color[name]` mapping
const levelMapping = [
    'ansi',
    'ansi',
    'ansi256',
    'ansi16m'
];
const styles = Object.create(null);
const applyOptions = (object, options = {})=>{
    if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error('The `level` option should be an integer from 0 to 3');
    }
    // Detect level if not set manually
    const colorLevel = stdoutColor ? stdoutColor.level : 0;
    object.level = options.level === undefined ? colorLevel : options.level;
};
class Chalk {
    constructor(options){
        // eslint-disable-next-line no-constructor-return
        return chalkFactory(options);
    }
}
const chalkFactory = (options)=>{
    const chalk = (...strings)=>strings.join(' ');
    applyOptions(chalk, options);
    Object.setPrototypeOf(chalk, createChalk.prototype);
    return chalk;
};
function createChalk(options) {
    return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$opik$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])){
    styles[styleName] = {
        get () {
            const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
            Object.defineProperty(this, styleName, {
                value: builder
            });
            return builder;
        }
    };
}
styles.visible = {
    get () {
        const builder = createBuilder(this, this[STYLER], true);
        Object.defineProperty(this, 'visible', {
            value: builder
        });
        return builder;
    }
};
const getModelAnsi = (model, level, type, ...arguments_)=>{
    if (model === 'rgb') {
        if (level === 'ansi16m') {
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$opik$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"][type].ansi16m(...arguments_);
        }
        if (level === 'ansi256') {
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$opik$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"][type].ansi256(__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$opik$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].rgbToAnsi256(...arguments_));
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$opik$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"][type].ansi(__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$opik$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].rgbToAnsi(...arguments_));
    }
    if (model === 'hex') {
        return getModelAnsi('rgb', level, type, ...__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$opik$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].hexToRgb(...arguments_));
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$opik$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"][type][model](...arguments_);
};
const usedModels = [
    'rgb',
    'hex',
    'ansi256'
];
for (const model of usedModels){
    styles[model] = {
        get () {
            const { level } = this;
            return function(...arguments_) {
                const styler = createStyler(getModelAnsi(model, levelMapping[level], 'color', ...arguments_), __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$opik$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].color.close, this[STYLER]);
                return createBuilder(this, styler, this[IS_EMPTY]);
            };
        }
    };
    const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
        get () {
            const { level } = this;
            return function(...arguments_) {
                const styler = createStyler(getModelAnsi(model, levelMapping[level], 'bgColor', ...arguments_), __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$opik$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].bgColor.close, this[STYLER]);
                return createBuilder(this, styler, this[IS_EMPTY]);
            };
        }
    };
}
const proto = Object.defineProperties(()=>{}, {
    ...styles,
    level: {
        enumerable: true,
        get () {
            return this[GENERATOR].level;
        },
        set (level) {
            this[GENERATOR].level = level;
        }
    }
});
const createStyler = (open, close, parent)=>{
    let openAll;
    let closeAll;
    if (parent === undefined) {
        openAll = open;
        closeAll = close;
    } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
    }
    return {
        open,
        close,
        openAll,
        closeAll,
        parent
    };
};
const createBuilder = (self, _styler, _isEmpty)=>{
    // Single argument is hot path, implicit coercion is faster than anything
    // eslint-disable-next-line no-implicit-coercion
    const builder = (...arguments_)=>applyStyle(builder, arguments_.length === 1 ? '' + arguments_[0] : arguments_.join(' '));
    // We alter the prototype because we must return a function, but there is
    // no way to create a function with a different prototype
    Object.setPrototypeOf(builder, proto);
    builder[GENERATOR] = self;
    builder[STYLER] = _styler;
    builder[IS_EMPTY] = _isEmpty;
    return builder;
};
const applyStyle = (self, string)=>{
    if (self.level <= 0 || !string) {
        return self[IS_EMPTY] ? '' : string;
    }
    let styler = self[STYLER];
    if (styler === undefined) {
        return string;
    }
    const { openAll, closeAll } = styler;
    if (string.includes('\u001B')) {
        while(styler !== undefined){
            // Replace any instances already present with a re-opening code
            // otherwise only the part of the string until said closing code
            // will be colored, and the rest will simply be 'plain'.
            string = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$opik$2f$node_modules$2f$chalk$2f$source$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringReplaceAll"])(string, styler.close, styler.open);
            styler = styler.parent;
        }
    }
    // We can move both next actions out of loop, because remaining actions in loop won't have
    // any/visible effect on parts we add here. Close the styling before a linebreak and reopen
    // after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
    const lfIndex = string.indexOf('\n');
    if (lfIndex !== -1) {
        string = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$opik$2f$node_modules$2f$chalk$2f$source$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringEncaseCRLFWithFirstIndex"])(string, closeAll, openAll, lfIndex);
    }
    return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles);
const chalk = createChalk();
const chalkStderr = createChalk({
    level: stderrColor ? stderrColor.level : 0
});
;
;
const __TURBOPACK__default__export__ = chalk;
}),
"[project]/align/node_modules/boxen/node_modules/chalk/source/vendor/ansi-styles/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "backgroundColorNames",
    ()=>backgroundColorNames,
    "colorNames",
    ()=>colorNames,
    "default",
    ()=>__TURBOPACK__default__export__,
    "foregroundColorNames",
    ()=>foregroundColorNames,
    "modifierNames",
    ()=>modifierNames
]);
const ANSI_BACKGROUND_OFFSET = 10;
const wrapAnsi16 = (offset = 0)=>(code)=>`\u001B[${code + offset}m`;
const wrapAnsi256 = (offset = 0)=>(code)=>`\u001B[${38 + offset};5;${code}m`;
const wrapAnsi16m = (offset = 0)=>(red, green, blue)=>`\u001B[${38 + offset};2;${red};${green};${blue}m`;
const styles = {
    modifier: {
        reset: [
            0,
            0
        ],
        // 21 isn't widely supported and 22 does the same thing
        bold: [
            1,
            22
        ],
        dim: [
            2,
            22
        ],
        italic: [
            3,
            23
        ],
        underline: [
            4,
            24
        ],
        overline: [
            53,
            55
        ],
        inverse: [
            7,
            27
        ],
        hidden: [
            8,
            28
        ],
        strikethrough: [
            9,
            29
        ]
    },
    color: {
        black: [
            30,
            39
        ],
        red: [
            31,
            39
        ],
        green: [
            32,
            39
        ],
        yellow: [
            33,
            39
        ],
        blue: [
            34,
            39
        ],
        magenta: [
            35,
            39
        ],
        cyan: [
            36,
            39
        ],
        white: [
            37,
            39
        ],
        // Bright color
        blackBright: [
            90,
            39
        ],
        gray: [
            90,
            39
        ],
        grey: [
            90,
            39
        ],
        redBright: [
            91,
            39
        ],
        greenBright: [
            92,
            39
        ],
        yellowBright: [
            93,
            39
        ],
        blueBright: [
            94,
            39
        ],
        magentaBright: [
            95,
            39
        ],
        cyanBright: [
            96,
            39
        ],
        whiteBright: [
            97,
            39
        ]
    },
    bgColor: {
        bgBlack: [
            40,
            49
        ],
        bgRed: [
            41,
            49
        ],
        bgGreen: [
            42,
            49
        ],
        bgYellow: [
            43,
            49
        ],
        bgBlue: [
            44,
            49
        ],
        bgMagenta: [
            45,
            49
        ],
        bgCyan: [
            46,
            49
        ],
        bgWhite: [
            47,
            49
        ],
        // Bright color
        bgBlackBright: [
            100,
            49
        ],
        bgGray: [
            100,
            49
        ],
        bgGrey: [
            100,
            49
        ],
        bgRedBright: [
            101,
            49
        ],
        bgGreenBright: [
            102,
            49
        ],
        bgYellowBright: [
            103,
            49
        ],
        bgBlueBright: [
            104,
            49
        ],
        bgMagentaBright: [
            105,
            49
        ],
        bgCyanBright: [
            106,
            49
        ],
        bgWhiteBright: [
            107,
            49
        ]
    }
};
const modifierNames = Object.keys(styles.modifier);
const foregroundColorNames = Object.keys(styles.color);
const backgroundColorNames = Object.keys(styles.bgColor);
const colorNames = [
    ...foregroundColorNames,
    ...backgroundColorNames
];
function assembleStyles() {
    const codes = new Map();
    for (const [groupName, group] of Object.entries(styles)){
        for (const [styleName, style] of Object.entries(group)){
            styles[styleName] = {
                open: `\u001B[${style[0]}m`,
                close: `\u001B[${style[1]}m`
            };
            group[styleName] = styles[styleName];
            codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
            value: group,
            enumerable: false
        });
    }
    Object.defineProperty(styles, 'codes', {
        value: codes,
        enumerable: false
    });
    styles.color.close = '\u001B[39m';
    styles.bgColor.close = '\u001B[49m';
    styles.color.ansi = wrapAnsi16();
    styles.color.ansi256 = wrapAnsi256();
    styles.color.ansi16m = wrapAnsi16m();
    styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
    styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
    styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
    // From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
    Object.defineProperties(styles, {
        rgbToAnsi256: {
            value (red, green, blue) {
                // We use the extended greyscale palette here, with the exception of
                // black and white. normal palette only has 4 greyscale shades.
                if (red === green && green === blue) {
                    if (red < 8) {
                        return 16;
                    }
                    if (red > 248) {
                        return 231;
                    }
                    return Math.round((red - 8) / 247 * 24) + 232;
                }
                return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
            },
            enumerable: false
        },
        hexToRgb: {
            value (hex) {
                const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
                if (!matches) {
                    return [
                        0,
                        0,
                        0
                    ];
                }
                let [colorString] = matches;
                if (colorString.length === 3) {
                    colorString = [
                        ...colorString
                    ].map((character)=>character + character).join('');
                }
                const integer = Number.parseInt(colorString, 16);
                return [
                    /* eslint-disable no-bitwise */ integer >> 16 & 0xFF,
                    integer >> 8 & 0xFF,
                    integer & 0xFF
                ];
            },
            enumerable: false
        },
        hexToAnsi256: {
            value: (hex)=>styles.rgbToAnsi256(...styles.hexToRgb(hex)),
            enumerable: false
        },
        ansi256ToAnsi: {
            value (code) {
                if (code < 8) {
                    return 30 + code;
                }
                if (code < 16) {
                    return 90 + (code - 8);
                }
                let red;
                let green;
                let blue;
                if (code >= 232) {
                    red = ((code - 232) * 10 + 8) / 255;
                    green = red;
                    blue = red;
                } else {
                    code -= 16;
                    const remainder = code % 36;
                    red = Math.floor(code / 36) / 5;
                    green = Math.floor(remainder / 6) / 5;
                    blue = remainder % 6 / 5;
                }
                const value = Math.max(red, green, blue) * 2;
                if (value === 0) {
                    return 30;
                }
                // eslint-disable-next-line no-bitwise
                let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
                if (value === 2) {
                    result += 60;
                }
                return result;
            },
            enumerable: false
        },
        rgbToAnsi: {
            value: (red, green, blue)=>styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
            enumerable: false
        },
        hexToAnsi: {
            value: (hex)=>styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
            enumerable: false
        }
    });
    return styles;
}
const ansiStyles = assembleStyles();
const __TURBOPACK__default__export__ = ansiStyles;
}),
"[project]/align/node_modules/boxen/node_modules/chalk/source/vendor/supports-color/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createSupportsColor",
    ()=>createSupportsColor,
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:os [external] (node:os, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$tty__$5b$external$5d$__$28$node$3a$tty$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:tty [external] (node:tty, cjs)");
;
;
;
// From: https://github.com/sindresorhus/has-flag/blob/main/index.js
/// function hasFlag(flag, argv = globalThis.Deno?.args ?? process.argv) {
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].argv) {
    const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf('--');
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
const { env } = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"];
let flagForceColor;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
    flagForceColor = 0;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
    flagForceColor = 1;
}
function envForceColor() {
    if ('FORCE_COLOR' in env) {
        if (env.FORCE_COLOR === 'true') {
            return 1;
        }
        if (env.FORCE_COLOR === 'false') {
            return 0;
        }
        return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
    }
}
function translateLevel(level) {
    if (level === 0) {
        return false;
    }
    return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
    };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
    const noFlagForceColor = envForceColor();
    if (noFlagForceColor !== undefined) {
        flagForceColor = noFlagForceColor;
    }
    const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
    if (forceColor === 0) {
        return 0;
    }
    if (sniffFlags) {
        if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
            return 3;
        }
        if (hasFlag('color=256')) {
            return 2;
        }
    }
    // Check for Azure DevOps pipelines.
    // Has to be above the `!streamIsTTY` check.
    if ('TF_BUILD' in env && 'AGENT_NAME' in env) {
        return 1;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
        return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === 'dumb') {
        return min;
    }
    if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].platform === 'win32') {
        // Windows 10 build 10586 is the first Windows release that supports 256 colors.
        // Windows 10 build 14931 is the first release that supports 16m/TrueColor.
        const osRelease = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["default"].release().split('.');
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10_586) {
            return Number(osRelease[2]) >= 14_931 ? 3 : 2;
        }
        return 1;
    }
    if ('CI' in env) {
        if ([
            'GITHUB_ACTIONS',
            'GITEA_ACTIONS',
            'CIRCLECI'
        ].some((key)=>key in env)) {
            return 3;
        }
        if ([
            'TRAVIS',
            'APPVEYOR',
            'GITLAB_CI',
            'BUILDKITE',
            'DRONE'
        ].some((sign)=>sign in env) || env.CI_NAME === 'codeship') {
            return 1;
        }
        return min;
    }
    if ('TEAMCITY_VERSION' in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === 'truecolor') {
        return 3;
    }
    if (env.TERM === 'xterm-kitty') {
        return 3;
    }
    if (env.TERM === 'xterm-ghostty') {
        return 3;
    }
    if (env.TERM === 'wezterm') {
        return 3;
    }
    if ('TERM_PROGRAM' in env) {
        const version = Number.parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
        switch(env.TERM_PROGRAM){
            case 'iTerm.app':
                {
                    return version >= 3 ? 3 : 2;
                }
            case 'Apple_Terminal':
                {
                    return 2;
                }
        }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
    }
    if ('COLORTERM' in env) {
        return 1;
    }
    return min;
}
function createSupportsColor(stream, options = {}) {
    const level = _supportsColor(stream, {
        streamIsTTY: stream && stream.isTTY,
        ...options
    });
    return translateLevel(level);
}
const supportsColor = {
    stdout: createSupportsColor({
        isTTY: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$tty__$5b$external$5d$__$28$node$3a$tty$2c$__cjs$29$__["default"].isatty(1)
    }),
    stderr: createSupportsColor({
        isTTY: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$tty__$5b$external$5d$__$28$node$3a$tty$2c$__cjs$29$__["default"].isatty(2)
    })
};
const __TURBOPACK__default__export__ = supportsColor;
}),
"[project]/align/node_modules/boxen/node_modules/chalk/source/utilities.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// TODO: When targeting Node.js 16, use `String.prototype.replaceAll`.
__turbopack_context__.s([
    "stringEncaseCRLFWithFirstIndex",
    ()=>stringEncaseCRLFWithFirstIndex,
    "stringReplaceAll",
    ()=>stringReplaceAll
]);
function stringReplaceAll(string, substring, replacer) {
    let index = string.indexOf(substring);
    if (index === -1) {
        return string;
    }
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = '';
    do {
        returnValue += string.slice(endIndex, index) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
    }while (index !== -1)
    returnValue += string.slice(endIndex);
    return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
    let endIndex = 0;
    let returnValue = '';
    do {
        const gotCR = string[index - 1] === '\r';
        returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
        endIndex = index + 1;
        index = string.indexOf('\n', endIndex);
    }while (index !== -1)
    returnValue += string.slice(endIndex);
    return returnValue;
}
}),
"[project]/align/node_modules/boxen/node_modules/chalk/source/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Chalk",
    ()=>Chalk,
    "chalkStderr",
    ()=>chalkStderr,
    "default",
    ()=>__TURBOPACK__default__export__,
    "supportsColor",
    ()=>stdoutColor,
    "supportsColorStderr",
    ()=>stderrColor
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$boxen$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/boxen/node_modules/chalk/source/vendor/ansi-styles/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$boxen$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$supports$2d$color$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/boxen/node_modules/chalk/source/vendor/supports-color/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$boxen$2f$node_modules$2f$chalk$2f$source$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/boxen/node_modules/chalk/source/utilities.js [app-route] (ecmascript)");
;
;
;
const { stdout: stdoutColor, stderr: stderrColor } = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$boxen$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$supports$2d$color$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"];
const GENERATOR = Symbol('GENERATOR');
const STYLER = Symbol('STYLER');
const IS_EMPTY = Symbol('IS_EMPTY');
// `supportsColor.level`  `ansiStyles.color[name]` mapping
const levelMapping = [
    'ansi',
    'ansi',
    'ansi256',
    'ansi16m'
];
const styles = Object.create(null);
const applyOptions = (object, options = {})=>{
    if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error('The `level` option should be an integer from 0 to 3');
    }
    // Detect level if not set manually
    const colorLevel = stdoutColor ? stdoutColor.level : 0;
    object.level = options.level === undefined ? colorLevel : options.level;
};
class Chalk {
    constructor(options){
        // eslint-disable-next-line no-constructor-return
        return chalkFactory(options);
    }
}
const chalkFactory = (options)=>{
    const chalk = (...strings)=>strings.join(' ');
    applyOptions(chalk, options);
    Object.setPrototypeOf(chalk, createChalk.prototype);
    return chalk;
};
function createChalk(options) {
    return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$boxen$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])){
    styles[styleName] = {
        get () {
            const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
            Object.defineProperty(this, styleName, {
                value: builder
            });
            return builder;
        }
    };
}
styles.visible = {
    get () {
        const builder = createBuilder(this, this[STYLER], true);
        Object.defineProperty(this, 'visible', {
            value: builder
        });
        return builder;
    }
};
const getModelAnsi = (model, level, type, ...arguments_)=>{
    if (model === 'rgb') {
        if (level === 'ansi16m') {
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$boxen$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"][type].ansi16m(...arguments_);
        }
        if (level === 'ansi256') {
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$boxen$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"][type].ansi256(__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$boxen$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].rgbToAnsi256(...arguments_));
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$boxen$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"][type].ansi(__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$boxen$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].rgbToAnsi(...arguments_));
    }
    if (model === 'hex') {
        return getModelAnsi('rgb', level, type, ...__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$boxen$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].hexToRgb(...arguments_));
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$boxen$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"][type][model](...arguments_);
};
const usedModels = [
    'rgb',
    'hex',
    'ansi256'
];
for (const model of usedModels){
    styles[model] = {
        get () {
            const { level } = this;
            return function(...arguments_) {
                const styler = createStyler(getModelAnsi(model, levelMapping[level], 'color', ...arguments_), __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$boxen$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].color.close, this[STYLER]);
                return createBuilder(this, styler, this[IS_EMPTY]);
            };
        }
    };
    const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
        get () {
            const { level } = this;
            return function(...arguments_) {
                const styler = createStyler(getModelAnsi(model, levelMapping[level], 'bgColor', ...arguments_), __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$boxen$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].bgColor.close, this[STYLER]);
                return createBuilder(this, styler, this[IS_EMPTY]);
            };
        }
    };
}
const proto = Object.defineProperties(()=>{}, {
    ...styles,
    level: {
        enumerable: true,
        get () {
            return this[GENERATOR].level;
        },
        set (level) {
            this[GENERATOR].level = level;
        }
    }
});
const createStyler = (open, close, parent)=>{
    let openAll;
    let closeAll;
    if (parent === undefined) {
        openAll = open;
        closeAll = close;
    } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
    }
    return {
        open,
        close,
        openAll,
        closeAll,
        parent
    };
};
const createBuilder = (self, _styler, _isEmpty)=>{
    // Single argument is hot path, implicit coercion is faster than anything
    // eslint-disable-next-line no-implicit-coercion
    const builder = (...arguments_)=>applyStyle(builder, arguments_.length === 1 ? '' + arguments_[0] : arguments_.join(' '));
    // We alter the prototype because we must return a function, but there is
    // no way to create a function with a different prototype
    Object.setPrototypeOf(builder, proto);
    builder[GENERATOR] = self;
    builder[STYLER] = _styler;
    builder[IS_EMPTY] = _isEmpty;
    return builder;
};
const applyStyle = (self, string)=>{
    if (self.level <= 0 || !string) {
        return self[IS_EMPTY] ? '' : string;
    }
    let styler = self[STYLER];
    if (styler === undefined) {
        return string;
    }
    const { openAll, closeAll } = styler;
    if (string.includes('\u001B')) {
        while(styler !== undefined){
            // Replace any instances already present with a re-opening code
            // otherwise only the part of the string until said closing code
            // will be colored, and the rest will simply be 'plain'.
            string = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$boxen$2f$node_modules$2f$chalk$2f$source$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringReplaceAll"])(string, styler.close, styler.open);
            styler = styler.parent;
        }
    }
    // We can move both next actions out of loop, because remaining actions in loop won't have
    // any/visible effect on parts we add here. Close the styling before a linebreak and reopen
    // after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
    const lfIndex = string.indexOf('\n');
    if (lfIndex !== -1) {
        string = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$boxen$2f$node_modules$2f$chalk$2f$source$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringEncaseCRLFWithFirstIndex"])(string, closeAll, openAll, lfIndex);
    }
    return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles);
const chalk = createChalk();
const chalkStderr = createChalk({
    level: stderrColor ? stderrColor.level : 0
});
;
;
const __TURBOPACK__default__export__ = chalk;
}),
"[project]/align/node_modules/boxen/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>boxen
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$string$2d$width$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/string-width/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$boxen$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/align/node_modules/boxen/node_modules/chalk/source/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$widest$2d$line$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/widest-line/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$cli$2d$boxes$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/cli-boxes/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$camelcase$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/camelcase/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$ansi$2d$align$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/ansi-align/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$wrap$2d$ansi$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/wrap-ansi/index.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
const NEWLINE = '\n';
const PAD = ' ';
const NONE = 'none';
const terminalColumns = ()=>{
    const { env, stdout, stderr } = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"];
    if (stdout?.columns) {
        return stdout.columns;
    }
    if (stderr?.columns) {
        return stderr.columns;
    }
    if (env.COLUMNS) {
        return Number.parseInt(env.COLUMNS, 10);
    }
    return 80;
};
const getObject = (detail)=>typeof detail === 'number' ? {
        top: detail,
        right: detail * 3,
        bottom: detail,
        left: detail * 3
    } : {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...detail
    };
const getBorderWidth = (borderStyle)=>borderStyle === NONE ? 0 : 2;
const getBorderChars = (borderStyle)=>{
    const sides = [
        'topLeft',
        'topRight',
        'bottomRight',
        'bottomLeft',
        'left',
        'right',
        'top',
        'bottom'
    ];
    let characters;
    // Create empty border style
    if (borderStyle === NONE) {
        borderStyle = {};
        for (const side of sides){
            borderStyle[side] = '';
        }
    }
    if (typeof borderStyle === 'string') {
        characters = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$cli$2d$boxes$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"][borderStyle];
        if (!characters) {
            throw new TypeError(`Invalid border style: ${borderStyle}`);
        }
    } else {
        // Ensure retro-compatibility
        if (typeof borderStyle?.vertical === 'string') {
            borderStyle.left = borderStyle.vertical;
            borderStyle.right = borderStyle.vertical;
        }
        // Ensure retro-compatibility
        if (typeof borderStyle?.horizontal === 'string') {
            borderStyle.top = borderStyle.horizontal;
            borderStyle.bottom = borderStyle.horizontal;
        }
        for (const side of sides){
            if (borderStyle[side] === null || typeof borderStyle[side] !== 'string') {
                throw new TypeError(`Invalid border style: ${side}`);
            }
        }
        characters = borderStyle;
    }
    return characters;
};
const makeTitle = (text, horizontal, alignment)=>{
    let title = '';
    const textWidth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$string$2d$width$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(text);
    switch(alignment){
        case 'left':
            {
                title = text + horizontal.slice(textWidth);
                break;
            }
        case 'right':
            {
                title = horizontal.slice(textWidth) + text;
                break;
            }
        default:
            {
                horizontal = horizontal.slice(textWidth);
                if (horizontal.length % 2 === 1) {
                    horizontal = horizontal.slice(Math.floor(horizontal.length / 2));
                    title = horizontal.slice(1) + text + horizontal; // We reduce the left part of one character to avoid the bar to go beyond its limit
                } else {
                    horizontal = horizontal.slice(horizontal.length / 2);
                    title = horizontal + text + horizontal;
                }
                break;
            }
    }
    return title;
};
const makeContentText = (text, { padding, width, textAlignment, height })=>{
    text = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$ansi$2d$align$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(text, {
        align: textAlignment
    });
    let lines = text.split(NEWLINE);
    const textWidth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$widest$2d$line$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(text);
    const max = width - padding.left - padding.right;
    if (textWidth > max) {
        const newLines = [];
        for (const line of lines){
            const createdLines = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$wrap$2d$ansi$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(line, max, {
                hard: true
            });
            const alignedLines = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$ansi$2d$align$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(createdLines, {
                align: textAlignment
            });
            const alignedLinesArray = alignedLines.split('\n');
            const longestLength = Math.max(...alignedLinesArray.map((s)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$string$2d$width$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(s)));
            for (const alignedLine of alignedLinesArray){
                let paddedLine;
                switch(textAlignment){
                    case 'center':
                        {
                            paddedLine = PAD.repeat((max - longestLength) / 2) + alignedLine;
                            break;
                        }
                    case 'right':
                        {
                            paddedLine = PAD.repeat(max - longestLength) + alignedLine;
                            break;
                        }
                    default:
                        {
                            paddedLine = alignedLine;
                            break;
                        }
                }
                newLines.push(paddedLine);
            }
        }
        lines = newLines;
    }
    if (textAlignment === 'center' && textWidth < max) {
        lines = lines.map((line)=>PAD.repeat((max - textWidth) / 2) + line);
    } else if (textAlignment === 'right' && textWidth < max) {
        lines = lines.map((line)=>PAD.repeat(max - textWidth) + line);
    }
    const paddingLeft = PAD.repeat(padding.left);
    const paddingRight = PAD.repeat(padding.right);
    lines = lines.map((line)=>{
        const newLine = paddingLeft + line + paddingRight;
        return newLine + PAD.repeat(width - (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$string$2d$width$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(newLine));
    });
    if (padding.top > 0) {
        lines = [
            ...Array.from({
                length: padding.top
            }).fill(PAD.repeat(width)),
            ...lines
        ];
    }
    if (padding.bottom > 0) {
        lines = [
            ...lines,
            ...Array.from({
                length: padding.bottom
            }).fill(PAD.repeat(width))
        ];
    }
    if (height && lines.length > height) {
        lines = lines.slice(0, height);
    } else if (height && lines.length < height) {
        lines = [
            ...lines,
            ...Array.from({
                length: height - lines.length
            }).fill(PAD.repeat(width))
        ];
    }
    return lines.join(NEWLINE);
};
const boxContent = (content, contentWidth, options)=>{
    const colorizeBorder = (border)=>{
        const newBorder = options.borderColor ? getColorFunction(options.borderColor)(border) : border;
        return options.dimBorder ? __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$boxen$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"].dim(newBorder) : newBorder;
    };
    const colorizeContent = (content)=>options.backgroundColor ? getBGColorFunction(options.backgroundColor)(content) : content;
    const chars = getBorderChars(options.borderStyle);
    const columns = terminalColumns();
    let marginLeft = PAD.repeat(options.margin.left);
    if (options.float === 'center') {
        const marginWidth = Math.max((columns - contentWidth - getBorderWidth(options.borderStyle)) / 2, 0);
        marginLeft = PAD.repeat(marginWidth);
    } else if (options.float === 'right') {
        const marginWidth = Math.max(columns - contentWidth - options.margin.right - getBorderWidth(options.borderStyle), 0);
        marginLeft = PAD.repeat(marginWidth);
    }
    let result = '';
    if (options.margin.top) {
        result += NEWLINE.repeat(options.margin.top);
    }
    if (options.borderStyle !== NONE || options.title) {
        result += colorizeBorder(marginLeft + chars.topLeft + (options.title ? makeTitle(options.title, chars.top.repeat(contentWidth), options.titleAlignment) : chars.top.repeat(contentWidth)) + chars.topRight) + NEWLINE;
    }
    const lines = content.split(NEWLINE);
    result += lines.map((line)=>marginLeft + colorizeBorder(chars.left) + colorizeContent(line) + colorizeBorder(chars.right)).join(NEWLINE);
    if (options.borderStyle !== NONE) {
        result += NEWLINE + colorizeBorder(marginLeft + chars.bottomLeft + chars.bottom.repeat(contentWidth) + chars.bottomRight);
    }
    if (options.margin.bottom) {
        result += NEWLINE.repeat(options.margin.bottom);
    }
    return result;
};
const sanitizeOptions = (options)=>{
    // If fullscreen is enabled, max-out unspecified width/height
    if (options.fullscreen && __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"]?.stdout) {
        let newDimensions = [
            __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stdout.columns,
            __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stdout.rows
        ];
        if (typeof options.fullscreen === 'function') {
            newDimensions = options.fullscreen(...newDimensions);
        }
        options.width ||= newDimensions[0];
        options.height ||= newDimensions[1];
    }
    // If width is provided, make sure it's not below 1
    options.width &&= Math.max(1, options.width - getBorderWidth(options.borderStyle));
    // If height is provided, make sure it's not below 1
    options.height &&= Math.max(1, options.height - getBorderWidth(options.borderStyle));
    return options;
};
const formatTitle = (title, borderStyle)=>borderStyle === NONE ? title : ` ${title} `;
const determineDimensions = (text, options)=>{
    options = sanitizeOptions(options);
    const widthOverride = options.width !== undefined;
    const columns = terminalColumns();
    const borderWidth = getBorderWidth(options.borderStyle);
    const maxWidth = columns - options.margin.left - options.margin.right - borderWidth;
    const widest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$widest$2d$line$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$wrap$2d$ansi$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(text, columns - borderWidth, {
        hard: true,
        trim: false
    })) + options.padding.left + options.padding.right;
    // If title and width are provided, title adheres to fixed width
    if (options.title && widthOverride) {
        options.title = options.title.slice(0, Math.max(0, options.width - 2));
        options.title &&= formatTitle(options.title, options.borderStyle);
    } else if (options.title) {
        options.title = options.title.slice(0, Math.max(0, maxWidth - 2));
        // Recheck if title isn't empty now
        if (options.title) {
            options.title = formatTitle(options.title, options.borderStyle);
            // If the title is larger than content, box adheres to title width
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$string$2d$width$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(options.title) > widest) {
                options.width = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$string$2d$width$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(options.title);
            }
        }
    }
    // If fixed width is provided, use it or content width as reference
    options.width ||= widest;
    if (!widthOverride) {
        if (options.margin.left && options.margin.right && options.width > maxWidth) {
            // Let's assume we have margins: left = 3, right = 5, in total = 8
            const spaceForMargins = columns - options.width - borderWidth;
            // Let's assume we have space = 4
            const multiplier = spaceForMargins / (options.margin.left + options.margin.right);
            // Here: multiplier = 4/8 = 0.5
            options.margin.left = Math.max(0, Math.floor(options.margin.left * multiplier));
            options.margin.right = Math.max(0, Math.floor(options.margin.right * multiplier));
        // Left: 3 * 0.5 = 1.5 -> 1
        // Right: 6 * 0.5 = 3
        }
        // Re-cap width considering the margins after shrinking
        options.width = Math.min(options.width, columns - borderWidth - options.margin.left - options.margin.right);
    }
    // Prevent padding overflow
    if (options.width - (options.padding.left + options.padding.right) <= 0) {
        options.padding.left = 0;
        options.padding.right = 0;
    }
    if (options.height && options.height - (options.padding.top + options.padding.bottom) <= 0) {
        options.padding.top = 0;
        options.padding.bottom = 0;
    }
    return options;
};
const isHex = (color)=>color.match(/^#(?:[0-f]{3}){1,2}$/i);
const isColorValid = (color)=>typeof color === 'string' && (__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$boxen$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"][color] ?? isHex(color));
const getColorFunction = (color)=>isHex(color) ? __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$boxen$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"].hex(color) : __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$boxen$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"][color];
const getBGColorFunction = (color)=>isHex(color) ? __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$boxen$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"].bgHex(color) : __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$boxen$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"][(0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$camelcase$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])([
        'bg',
        color
    ])];
function boxen(text, options) {
    options = {
        padding: 0,
        borderStyle: 'single',
        dimBorder: false,
        textAlignment: 'left',
        float: 'left',
        titleAlignment: 'left',
        ...options
    };
    // This option is deprecated
    if (options.align) {
        options.textAlignment = options.align;
    }
    if (options.borderColor && !isColorValid(options.borderColor)) {
        throw new Error(`${options.borderColor} is not a valid borderColor`);
    }
    if (options.backgroundColor && !isColorValid(options.backgroundColor)) {
        throw new Error(`${options.backgroundColor} is not a valid backgroundColor`);
    }
    options.padding = getObject(options.padding);
    options.margin = getObject(options.margin);
    options = determineDimensions(text, options);
    text = makeContentText(text, options);
    return boxContent(text, options.width, options);
}
;
}),
"[project]/align/node_modules/ora/node_modules/chalk/source/vendor/ansi-styles/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "backgroundColorNames",
    ()=>backgroundColorNames,
    "colorNames",
    ()=>colorNames,
    "default",
    ()=>__TURBOPACK__default__export__,
    "foregroundColorNames",
    ()=>foregroundColorNames,
    "modifierNames",
    ()=>modifierNames
]);
const ANSI_BACKGROUND_OFFSET = 10;
const wrapAnsi16 = (offset = 0)=>(code)=>`\u001B[${code + offset}m`;
const wrapAnsi256 = (offset = 0)=>(code)=>`\u001B[${38 + offset};5;${code}m`;
const wrapAnsi16m = (offset = 0)=>(red, green, blue)=>`\u001B[${38 + offset};2;${red};${green};${blue}m`;
const styles = {
    modifier: {
        reset: [
            0,
            0
        ],
        // 21 isn't widely supported and 22 does the same thing
        bold: [
            1,
            22
        ],
        dim: [
            2,
            22
        ],
        italic: [
            3,
            23
        ],
        underline: [
            4,
            24
        ],
        overline: [
            53,
            55
        ],
        inverse: [
            7,
            27
        ],
        hidden: [
            8,
            28
        ],
        strikethrough: [
            9,
            29
        ]
    },
    color: {
        black: [
            30,
            39
        ],
        red: [
            31,
            39
        ],
        green: [
            32,
            39
        ],
        yellow: [
            33,
            39
        ],
        blue: [
            34,
            39
        ],
        magenta: [
            35,
            39
        ],
        cyan: [
            36,
            39
        ],
        white: [
            37,
            39
        ],
        // Bright color
        blackBright: [
            90,
            39
        ],
        gray: [
            90,
            39
        ],
        grey: [
            90,
            39
        ],
        redBright: [
            91,
            39
        ],
        greenBright: [
            92,
            39
        ],
        yellowBright: [
            93,
            39
        ],
        blueBright: [
            94,
            39
        ],
        magentaBright: [
            95,
            39
        ],
        cyanBright: [
            96,
            39
        ],
        whiteBright: [
            97,
            39
        ]
    },
    bgColor: {
        bgBlack: [
            40,
            49
        ],
        bgRed: [
            41,
            49
        ],
        bgGreen: [
            42,
            49
        ],
        bgYellow: [
            43,
            49
        ],
        bgBlue: [
            44,
            49
        ],
        bgMagenta: [
            45,
            49
        ],
        bgCyan: [
            46,
            49
        ],
        bgWhite: [
            47,
            49
        ],
        // Bright color
        bgBlackBright: [
            100,
            49
        ],
        bgGray: [
            100,
            49
        ],
        bgGrey: [
            100,
            49
        ],
        bgRedBright: [
            101,
            49
        ],
        bgGreenBright: [
            102,
            49
        ],
        bgYellowBright: [
            103,
            49
        ],
        bgBlueBright: [
            104,
            49
        ],
        bgMagentaBright: [
            105,
            49
        ],
        bgCyanBright: [
            106,
            49
        ],
        bgWhiteBright: [
            107,
            49
        ]
    }
};
const modifierNames = Object.keys(styles.modifier);
const foregroundColorNames = Object.keys(styles.color);
const backgroundColorNames = Object.keys(styles.bgColor);
const colorNames = [
    ...foregroundColorNames,
    ...backgroundColorNames
];
function assembleStyles() {
    const codes = new Map();
    for (const [groupName, group] of Object.entries(styles)){
        for (const [styleName, style] of Object.entries(group)){
            styles[styleName] = {
                open: `\u001B[${style[0]}m`,
                close: `\u001B[${style[1]}m`
            };
            group[styleName] = styles[styleName];
            codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
            value: group,
            enumerable: false
        });
    }
    Object.defineProperty(styles, 'codes', {
        value: codes,
        enumerable: false
    });
    styles.color.close = '\u001B[39m';
    styles.bgColor.close = '\u001B[49m';
    styles.color.ansi = wrapAnsi16();
    styles.color.ansi256 = wrapAnsi256();
    styles.color.ansi16m = wrapAnsi16m();
    styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
    styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
    styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
    // From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
    Object.defineProperties(styles, {
        rgbToAnsi256: {
            value (red, green, blue) {
                // We use the extended greyscale palette here, with the exception of
                // black and white. normal palette only has 4 greyscale shades.
                if (red === green && green === blue) {
                    if (red < 8) {
                        return 16;
                    }
                    if (red > 248) {
                        return 231;
                    }
                    return Math.round((red - 8) / 247 * 24) + 232;
                }
                return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
            },
            enumerable: false
        },
        hexToRgb: {
            value (hex) {
                const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
                if (!matches) {
                    return [
                        0,
                        0,
                        0
                    ];
                }
                let [colorString] = matches;
                if (colorString.length === 3) {
                    colorString = [
                        ...colorString
                    ].map((character)=>character + character).join('');
                }
                const integer = Number.parseInt(colorString, 16);
                return [
                    /* eslint-disable no-bitwise */ integer >> 16 & 0xFF,
                    integer >> 8 & 0xFF,
                    integer & 0xFF
                ];
            },
            enumerable: false
        },
        hexToAnsi256: {
            value: (hex)=>styles.rgbToAnsi256(...styles.hexToRgb(hex)),
            enumerable: false
        },
        ansi256ToAnsi: {
            value (code) {
                if (code < 8) {
                    return 30 + code;
                }
                if (code < 16) {
                    return 90 + (code - 8);
                }
                let red;
                let green;
                let blue;
                if (code >= 232) {
                    red = ((code - 232) * 10 + 8) / 255;
                    green = red;
                    blue = red;
                } else {
                    code -= 16;
                    const remainder = code % 36;
                    red = Math.floor(code / 36) / 5;
                    green = Math.floor(remainder / 6) / 5;
                    blue = remainder % 6 / 5;
                }
                const value = Math.max(red, green, blue) * 2;
                if (value === 0) {
                    return 30;
                }
                // eslint-disable-next-line no-bitwise
                let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
                if (value === 2) {
                    result += 60;
                }
                return result;
            },
            enumerable: false
        },
        rgbToAnsi: {
            value: (red, green, blue)=>styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
            enumerable: false
        },
        hexToAnsi: {
            value: (hex)=>styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
            enumerable: false
        }
    });
    return styles;
}
const ansiStyles = assembleStyles();
const __TURBOPACK__default__export__ = ansiStyles;
}),
"[project]/align/node_modules/ora/node_modules/chalk/source/vendor/supports-color/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createSupportsColor",
    ()=>createSupportsColor,
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:os [external] (node:os, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$tty__$5b$external$5d$__$28$node$3a$tty$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:tty [external] (node:tty, cjs)");
;
;
;
// From: https://github.com/sindresorhus/has-flag/blob/main/index.js
/// function hasFlag(flag, argv = globalThis.Deno?.args ?? process.argv) {
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].argv) {
    const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf('--');
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
const { env } = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"];
let flagForceColor;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
    flagForceColor = 0;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
    flagForceColor = 1;
}
function envForceColor() {
    if ('FORCE_COLOR' in env) {
        if (env.FORCE_COLOR === 'true') {
            return 1;
        }
        if (env.FORCE_COLOR === 'false') {
            return 0;
        }
        return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
    }
}
function translateLevel(level) {
    if (level === 0) {
        return false;
    }
    return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
    };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
    const noFlagForceColor = envForceColor();
    if (noFlagForceColor !== undefined) {
        flagForceColor = noFlagForceColor;
    }
    const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
    if (forceColor === 0) {
        return 0;
    }
    if (sniffFlags) {
        if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
            return 3;
        }
        if (hasFlag('color=256')) {
            return 2;
        }
    }
    // Check for Azure DevOps pipelines.
    // Has to be above the `!streamIsTTY` check.
    if ('TF_BUILD' in env && 'AGENT_NAME' in env) {
        return 1;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
        return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === 'dumb') {
        return min;
    }
    if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].platform === 'win32') {
        // Windows 10 build 10586 is the first Windows release that supports 256 colors.
        // Windows 10 build 14931 is the first release that supports 16m/TrueColor.
        const osRelease = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["default"].release().split('.');
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10_586) {
            return Number(osRelease[2]) >= 14_931 ? 3 : 2;
        }
        return 1;
    }
    if ('CI' in env) {
        if ([
            'GITHUB_ACTIONS',
            'GITEA_ACTIONS',
            'CIRCLECI'
        ].some((key)=>key in env)) {
            return 3;
        }
        if ([
            'TRAVIS',
            'APPVEYOR',
            'GITLAB_CI',
            'BUILDKITE',
            'DRONE'
        ].some((sign)=>sign in env) || env.CI_NAME === 'codeship') {
            return 1;
        }
        return min;
    }
    if ('TEAMCITY_VERSION' in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === 'truecolor') {
        return 3;
    }
    if (env.TERM === 'xterm-kitty') {
        return 3;
    }
    if (env.TERM === 'xterm-ghostty') {
        return 3;
    }
    if (env.TERM === 'wezterm') {
        return 3;
    }
    if ('TERM_PROGRAM' in env) {
        const version = Number.parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
        switch(env.TERM_PROGRAM){
            case 'iTerm.app':
                {
                    return version >= 3 ? 3 : 2;
                }
            case 'Apple_Terminal':
                {
                    return 2;
                }
        }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
    }
    if ('COLORTERM' in env) {
        return 1;
    }
    return min;
}
function createSupportsColor(stream, options = {}) {
    const level = _supportsColor(stream, {
        streamIsTTY: stream && stream.isTTY,
        ...options
    });
    return translateLevel(level);
}
const supportsColor = {
    stdout: createSupportsColor({
        isTTY: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$tty__$5b$external$5d$__$28$node$3a$tty$2c$__cjs$29$__["default"].isatty(1)
    }),
    stderr: createSupportsColor({
        isTTY: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$tty__$5b$external$5d$__$28$node$3a$tty$2c$__cjs$29$__["default"].isatty(2)
    })
};
const __TURBOPACK__default__export__ = supportsColor;
}),
"[project]/align/node_modules/ora/node_modules/chalk/source/utilities.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// TODO: When targeting Node.js 16, use `String.prototype.replaceAll`.
__turbopack_context__.s([
    "stringEncaseCRLFWithFirstIndex",
    ()=>stringEncaseCRLFWithFirstIndex,
    "stringReplaceAll",
    ()=>stringReplaceAll
]);
function stringReplaceAll(string, substring, replacer) {
    let index = string.indexOf(substring);
    if (index === -1) {
        return string;
    }
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = '';
    do {
        returnValue += string.slice(endIndex, index) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
    }while (index !== -1)
    returnValue += string.slice(endIndex);
    return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
    let endIndex = 0;
    let returnValue = '';
    do {
        const gotCR = string[index - 1] === '\r';
        returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
        endIndex = index + 1;
        index = string.indexOf('\n', endIndex);
    }while (index !== -1)
    returnValue += string.slice(endIndex);
    return returnValue;
}
}),
"[project]/align/node_modules/ora/node_modules/chalk/source/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Chalk",
    ()=>Chalk,
    "chalkStderr",
    ()=>chalkStderr,
    "default",
    ()=>__TURBOPACK__default__export__,
    "supportsColor",
    ()=>stdoutColor,
    "supportsColorStderr",
    ()=>stderrColor
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$ora$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/ora/node_modules/chalk/source/vendor/ansi-styles/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$ora$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$supports$2d$color$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/ora/node_modules/chalk/source/vendor/supports-color/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$ora$2f$node_modules$2f$chalk$2f$source$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/ora/node_modules/chalk/source/utilities.js [app-route] (ecmascript)");
;
;
;
const { stdout: stdoutColor, stderr: stderrColor } = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$ora$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$supports$2d$color$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"];
const GENERATOR = Symbol('GENERATOR');
const STYLER = Symbol('STYLER');
const IS_EMPTY = Symbol('IS_EMPTY');
// `supportsColor.level`  `ansiStyles.color[name]` mapping
const levelMapping = [
    'ansi',
    'ansi',
    'ansi256',
    'ansi16m'
];
const styles = Object.create(null);
const applyOptions = (object, options = {})=>{
    if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error('The `level` option should be an integer from 0 to 3');
    }
    // Detect level if not set manually
    const colorLevel = stdoutColor ? stdoutColor.level : 0;
    object.level = options.level === undefined ? colorLevel : options.level;
};
class Chalk {
    constructor(options){
        // eslint-disable-next-line no-constructor-return
        return chalkFactory(options);
    }
}
const chalkFactory = (options)=>{
    const chalk = (...strings)=>strings.join(' ');
    applyOptions(chalk, options);
    Object.setPrototypeOf(chalk, createChalk.prototype);
    return chalk;
};
function createChalk(options) {
    return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$ora$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])){
    styles[styleName] = {
        get () {
            const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
            Object.defineProperty(this, styleName, {
                value: builder
            });
            return builder;
        }
    };
}
styles.visible = {
    get () {
        const builder = createBuilder(this, this[STYLER], true);
        Object.defineProperty(this, 'visible', {
            value: builder
        });
        return builder;
    }
};
const getModelAnsi = (model, level, type, ...arguments_)=>{
    if (model === 'rgb') {
        if (level === 'ansi16m') {
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$ora$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"][type].ansi16m(...arguments_);
        }
        if (level === 'ansi256') {
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$ora$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"][type].ansi256(__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$ora$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].rgbToAnsi256(...arguments_));
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$ora$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"][type].ansi(__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$ora$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].rgbToAnsi(...arguments_));
    }
    if (model === 'hex') {
        return getModelAnsi('rgb', level, type, ...__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$ora$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].hexToRgb(...arguments_));
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$ora$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"][type][model](...arguments_);
};
const usedModels = [
    'rgb',
    'hex',
    'ansi256'
];
for (const model of usedModels){
    styles[model] = {
        get () {
            const { level } = this;
            return function(...arguments_) {
                const styler = createStyler(getModelAnsi(model, levelMapping[level], 'color', ...arguments_), __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$ora$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].color.close, this[STYLER]);
                return createBuilder(this, styler, this[IS_EMPTY]);
            };
        }
    };
    const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
        get () {
            const { level } = this;
            return function(...arguments_) {
                const styler = createStyler(getModelAnsi(model, levelMapping[level], 'bgColor', ...arguments_), __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$ora$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].bgColor.close, this[STYLER]);
                return createBuilder(this, styler, this[IS_EMPTY]);
            };
        }
    };
}
const proto = Object.defineProperties(()=>{}, {
    ...styles,
    level: {
        enumerable: true,
        get () {
            return this[GENERATOR].level;
        },
        set (level) {
            this[GENERATOR].level = level;
        }
    }
});
const createStyler = (open, close, parent)=>{
    let openAll;
    let closeAll;
    if (parent === undefined) {
        openAll = open;
        closeAll = close;
    } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
    }
    return {
        open,
        close,
        openAll,
        closeAll,
        parent
    };
};
const createBuilder = (self, _styler, _isEmpty)=>{
    // Single argument is hot path, implicit coercion is faster than anything
    // eslint-disable-next-line no-implicit-coercion
    const builder = (...arguments_)=>applyStyle(builder, arguments_.length === 1 ? '' + arguments_[0] : arguments_.join(' '));
    // We alter the prototype because we must return a function, but there is
    // no way to create a function with a different prototype
    Object.setPrototypeOf(builder, proto);
    builder[GENERATOR] = self;
    builder[STYLER] = _styler;
    builder[IS_EMPTY] = _isEmpty;
    return builder;
};
const applyStyle = (self, string)=>{
    if (self.level <= 0 || !string) {
        return self[IS_EMPTY] ? '' : string;
    }
    let styler = self[STYLER];
    if (styler === undefined) {
        return string;
    }
    const { openAll, closeAll } = styler;
    if (string.includes('\u001B')) {
        while(styler !== undefined){
            // Replace any instances already present with a re-opening code
            // otherwise only the part of the string until said closing code
            // will be colored, and the rest will simply be 'plain'.
            string = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$ora$2f$node_modules$2f$chalk$2f$source$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringReplaceAll"])(string, styler.close, styler.open);
            styler = styler.parent;
        }
    }
    // We can move both next actions out of loop, because remaining actions in loop won't have
    // any/visible effect on parts we add here. Close the styling before a linebreak and reopen
    // after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
    const lfIndex = string.indexOf('\n');
    if (lfIndex !== -1) {
        string = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$ora$2f$node_modules$2f$chalk$2f$source$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringEncaseCRLFWithFirstIndex"])(string, closeAll, openAll, lfIndex);
    }
    return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles);
const chalk = createChalk();
const chalkStderr = createChalk({
    level: stderrColor ? stderrColor.level : 0
});
;
;
const __TURBOPACK__default__export__ = chalk;
}),
"[project]/align/node_modules/ora/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>ora,
    "oraPromise",
    ()=>oraPromise
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$ora$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/align/node_modules/ora/node_modules/chalk/source/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$cli$2d$cursor$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/cli-cursor/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$cli$2d$spinners$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/cli-spinners/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/log-symbols/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$strip$2d$ansi$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/strip-ansi/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$string$2d$width$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/string-width/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$is$2d$interactive$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/is-interactive/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$is$2d$unicode$2d$supported$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/is-unicode-supported/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$stdin$2d$discarder$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/stdin-discarder/index.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
class Ora {
    #linesToClear = 0;
    #isDiscardingStdin = false;
    #lineCount = 0;
    #frameIndex = -1;
    #lastSpinnerFrameTime = 0;
    #options;
    #spinner;
    #stream;
    #id;
    #initialInterval;
    #isEnabled;
    #isSilent;
    #indent;
    #text;
    #prefixText;
    #suffixText;
    color;
    constructor(options){
        if (typeof options === 'string') {
            options = {
                text: options
            };
        }
        this.#options = {
            color: 'cyan',
            stream: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stderr,
            discardStdin: true,
            hideCursor: true,
            ...options
        };
        // Public
        this.color = this.#options.color;
        // It's important that these use the public setters.
        this.spinner = this.#options.spinner;
        this.#initialInterval = this.#options.interval;
        this.#stream = this.#options.stream;
        this.#isEnabled = typeof this.#options.isEnabled === 'boolean' ? this.#options.isEnabled : (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$is$2d$interactive$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])({
            stream: this.#stream
        });
        this.#isSilent = typeof this.#options.isSilent === 'boolean' ? this.#options.isSilent : false;
        // Set *after* `this.#stream`.
        // It's important that these use the public setters.
        this.text = this.#options.text;
        this.prefixText = this.#options.prefixText;
        this.suffixText = this.#options.suffixText;
        this.indent = this.#options.indent;
        if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].env.NODE_ENV === 'test') {
            this._stream = this.#stream;
            this._isEnabled = this.#isEnabled;
            Object.defineProperty(this, '_linesToClear', {
                get () {
                    return this.#linesToClear;
                },
                set (newValue) {
                    this.#linesToClear = newValue;
                }
            });
            Object.defineProperty(this, '_frameIndex', {
                get () {
                    return this.#frameIndex;
                }
            });
            Object.defineProperty(this, '_lineCount', {
                get () {
                    return this.#lineCount;
                }
            });
        }
    }
    get indent() {
        return this.#indent;
    }
    set indent(indent = 0) {
        if (!(indent >= 0 && Number.isInteger(indent))) {
            throw new Error('The `indent` option must be an integer from 0 and up');
        }
        this.#indent = indent;
        this.#updateLineCount();
    }
    get interval() {
        return this.#initialInterval ?? this.#spinner.interval ?? 100;
    }
    get spinner() {
        return this.#spinner;
    }
    set spinner(spinner) {
        this.#frameIndex = -1;
        this.#initialInterval = undefined;
        if (typeof spinner === 'object') {
            if (spinner.frames === undefined) {
                throw new Error('The given spinner must have a `frames` property');
            }
            this.#spinner = spinner;
        } else if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$is$2d$unicode$2d$supported$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])()) {
            this.#spinner = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$cli$2d$spinners$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].line;
        } else if (spinner === undefined) {
            // Set default spinner
            this.#spinner = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$cli$2d$spinners$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].dots;
        } else if (spinner !== 'default' && __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$cli$2d$spinners$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"][spinner]) {
            this.#spinner = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$cli$2d$spinners$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"][spinner];
        } else {
            throw new Error(`There is no built-in spinner named '${spinner}'. See https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json for a full list.`);
        }
    }
    get text() {
        return this.#text;
    }
    set text(value = '') {
        this.#text = value;
        this.#updateLineCount();
    }
    get prefixText() {
        return this.#prefixText;
    }
    set prefixText(value = '') {
        this.#prefixText = value;
        this.#updateLineCount();
    }
    get suffixText() {
        return this.#suffixText;
    }
    set suffixText(value = '') {
        this.#suffixText = value;
        this.#updateLineCount();
    }
    get isSpinning() {
        return this.#id !== undefined;
    }
    #getFullPrefixText(prefixText = this.#prefixText, postfix = ' ') {
        if (typeof prefixText === 'string' && prefixText !== '') {
            return prefixText + postfix;
        }
        if (typeof prefixText === 'function') {
            return prefixText() + postfix;
        }
        return '';
    }
    #getFullSuffixText(suffixText = this.#suffixText, prefix = ' ') {
        if (typeof suffixText === 'string' && suffixText !== '') {
            return prefix + suffixText;
        }
        if (typeof suffixText === 'function') {
            return prefix + suffixText();
        }
        return '';
    }
    #updateLineCount() {
        const columns = this.#stream.columns ?? 80;
        const fullPrefixText = this.#getFullPrefixText(this.#prefixText, '-');
        const fullSuffixText = this.#getFullSuffixText(this.#suffixText, '-');
        const fullText = ' '.repeat(this.#indent) + fullPrefixText + '--' + this.#text + '--' + fullSuffixText;
        this.#lineCount = 0;
        for (const line of (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$strip$2d$ansi$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(fullText).split('\n')){
            this.#lineCount += Math.max(1, Math.ceil((0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$string$2d$width$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(line, {
                countAnsiEscapeCodes: true
            }) / columns));
        }
    }
    get isEnabled() {
        return this.#isEnabled && !this.#isSilent;
    }
    set isEnabled(value) {
        if (typeof value !== 'boolean') {
            throw new TypeError('The `isEnabled` option must be a boolean');
        }
        this.#isEnabled = value;
    }
    get isSilent() {
        return this.#isSilent;
    }
    set isSilent(value) {
        if (typeof value !== 'boolean') {
            throw new TypeError('The `isSilent` option must be a boolean');
        }
        this.#isSilent = value;
    }
    frame() {
        // Ensure we only update the spinner frame at the wanted interval,
        // even if the render method is called more often.
        const now = Date.now();
        if (this.#frameIndex === -1 || now - this.#lastSpinnerFrameTime >= this.interval) {
            this.#frameIndex = ++this.#frameIndex % this.#spinner.frames.length;
            this.#lastSpinnerFrameTime = now;
        }
        const { frames } = this.#spinner;
        let frame = frames[this.#frameIndex];
        if (this.color) {
            frame = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$ora$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"][this.color](frame);
        }
        const fullPrefixText = typeof this.#prefixText === 'string' && this.#prefixText !== '' ? this.#prefixText + ' ' : '';
        const fullText = typeof this.text === 'string' ? ' ' + this.text : '';
        const fullSuffixText = typeof this.#suffixText === 'string' && this.#suffixText !== '' ? ' ' + this.#suffixText : '';
        return fullPrefixText + frame + fullText + fullSuffixText;
    }
    clear() {
        if (!this.#isEnabled || !this.#stream.isTTY) {
            return this;
        }
        this.#stream.cursorTo(0);
        for(let index = 0; index < this.#linesToClear; index++){
            if (index > 0) {
                this.#stream.moveCursor(0, -1);
            }
            this.#stream.clearLine(1);
        }
        if (this.#indent || this.lastIndent !== this.#indent) {
            this.#stream.cursorTo(this.#indent);
        }
        this.lastIndent = this.#indent;
        this.#linesToClear = 0;
        return this;
    }
    render() {
        if (this.#isSilent) {
            return this;
        }
        this.clear();
        this.#stream.write(this.frame());
        this.#linesToClear = this.#lineCount;
        return this;
    }
    start(text) {
        if (text) {
            this.text = text;
        }
        if (this.#isSilent) {
            return this;
        }
        if (!this.#isEnabled) {
            if (this.text) {
                this.#stream.write(`- ${this.text}\n`);
            }
            return this;
        }
        if (this.isSpinning) {
            return this;
        }
        if (this.#options.hideCursor) {
            __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$cli$2d$cursor$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].hide(this.#stream);
        }
        if (this.#options.discardStdin && __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stdin.isTTY) {
            this.#isDiscardingStdin = true;
            __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$stdin$2d$discarder$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].start();
        }
        this.render();
        this.#id = setInterval(this.render.bind(this), this.interval);
        return this;
    }
    stop() {
        if (!this.#isEnabled) {
            return this;
        }
        clearInterval(this.#id);
        this.#id = undefined;
        this.#frameIndex = 0;
        this.clear();
        if (this.#options.hideCursor) {
            __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$cli$2d$cursor$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].show(this.#stream);
        }
        if (this.#options.discardStdin && __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stdin.isTTY && this.#isDiscardingStdin) {
            __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$stdin$2d$discarder$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].stop();
            this.#isDiscardingStdin = false;
        }
        return this;
    }
    succeed(text) {
        return this.stopAndPersist({
            symbol: __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].success,
            text
        });
    }
    fail(text) {
        return this.stopAndPersist({
            symbol: __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].error,
            text
        });
    }
    warn(text) {
        return this.stopAndPersist({
            symbol: __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].warning,
            text
        });
    }
    info(text) {
        return this.stopAndPersist({
            symbol: __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].info,
            text
        });
    }
    stopAndPersist(options = {}) {
        if (this.#isSilent) {
            return this;
        }
        const prefixText = options.prefixText ?? this.#prefixText;
        const fullPrefixText = this.#getFullPrefixText(prefixText, ' ');
        const symbolText = options.symbol ?? ' ';
        const text = options.text ?? this.text;
        const separatorText = symbolText ? ' ' : '';
        const fullText = typeof text === 'string' ? separatorText + text : '';
        const suffixText = options.suffixText ?? this.#suffixText;
        const fullSuffixText = this.#getFullSuffixText(suffixText, ' ');
        const textToWrite = fullPrefixText + symbolText + fullText + fullSuffixText + '\n';
        this.stop();
        this.#stream.write(textToWrite);
        return this;
    }
}
function ora(options) {
    return new Ora(options);
}
async function oraPromise(action, options) {
    const actionIsFunction = typeof action === 'function';
    const actionIsPromise = typeof action.then === 'function';
    if (!actionIsFunction && !actionIsPromise) {
        throw new TypeError('Parameter `action` must be a Function or a Promise');
    }
    const { successText, failText } = typeof options === 'object' ? options : {
        successText: undefined,
        failText: undefined
    };
    const spinner = ora(options).start();
    try {
        const promise = actionIsFunction ? action(spinner) : action;
        const result = await promise;
        spinner.succeed(successText === undefined ? undefined : typeof successText === 'string' ? successText : successText(result));
        return result;
    } catch (error) {
        spinner.fail(failText === undefined ? undefined : typeof failText === 'string' ? failText : failText(error));
        throw error;
    }
}
;
}),
"[project]/align/node_modules/log-symbols/node_modules/chalk/source/vendor/ansi-styles/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "backgroundColorNames",
    ()=>backgroundColorNames,
    "colorNames",
    ()=>colorNames,
    "default",
    ()=>__TURBOPACK__default__export__,
    "foregroundColorNames",
    ()=>foregroundColorNames,
    "modifierNames",
    ()=>modifierNames
]);
const ANSI_BACKGROUND_OFFSET = 10;
const wrapAnsi16 = (offset = 0)=>(code)=>`\u001B[${code + offset}m`;
const wrapAnsi256 = (offset = 0)=>(code)=>`\u001B[${38 + offset};5;${code}m`;
const wrapAnsi16m = (offset = 0)=>(red, green, blue)=>`\u001B[${38 + offset};2;${red};${green};${blue}m`;
const styles = {
    modifier: {
        reset: [
            0,
            0
        ],
        // 21 isn't widely supported and 22 does the same thing
        bold: [
            1,
            22
        ],
        dim: [
            2,
            22
        ],
        italic: [
            3,
            23
        ],
        underline: [
            4,
            24
        ],
        overline: [
            53,
            55
        ],
        inverse: [
            7,
            27
        ],
        hidden: [
            8,
            28
        ],
        strikethrough: [
            9,
            29
        ]
    },
    color: {
        black: [
            30,
            39
        ],
        red: [
            31,
            39
        ],
        green: [
            32,
            39
        ],
        yellow: [
            33,
            39
        ],
        blue: [
            34,
            39
        ],
        magenta: [
            35,
            39
        ],
        cyan: [
            36,
            39
        ],
        white: [
            37,
            39
        ],
        // Bright color
        blackBright: [
            90,
            39
        ],
        gray: [
            90,
            39
        ],
        grey: [
            90,
            39
        ],
        redBright: [
            91,
            39
        ],
        greenBright: [
            92,
            39
        ],
        yellowBright: [
            93,
            39
        ],
        blueBright: [
            94,
            39
        ],
        magentaBright: [
            95,
            39
        ],
        cyanBright: [
            96,
            39
        ],
        whiteBright: [
            97,
            39
        ]
    },
    bgColor: {
        bgBlack: [
            40,
            49
        ],
        bgRed: [
            41,
            49
        ],
        bgGreen: [
            42,
            49
        ],
        bgYellow: [
            43,
            49
        ],
        bgBlue: [
            44,
            49
        ],
        bgMagenta: [
            45,
            49
        ],
        bgCyan: [
            46,
            49
        ],
        bgWhite: [
            47,
            49
        ],
        // Bright color
        bgBlackBright: [
            100,
            49
        ],
        bgGray: [
            100,
            49
        ],
        bgGrey: [
            100,
            49
        ],
        bgRedBright: [
            101,
            49
        ],
        bgGreenBright: [
            102,
            49
        ],
        bgYellowBright: [
            103,
            49
        ],
        bgBlueBright: [
            104,
            49
        ],
        bgMagentaBright: [
            105,
            49
        ],
        bgCyanBright: [
            106,
            49
        ],
        bgWhiteBright: [
            107,
            49
        ]
    }
};
const modifierNames = Object.keys(styles.modifier);
const foregroundColorNames = Object.keys(styles.color);
const backgroundColorNames = Object.keys(styles.bgColor);
const colorNames = [
    ...foregroundColorNames,
    ...backgroundColorNames
];
function assembleStyles() {
    const codes = new Map();
    for (const [groupName, group] of Object.entries(styles)){
        for (const [styleName, style] of Object.entries(group)){
            styles[styleName] = {
                open: `\u001B[${style[0]}m`,
                close: `\u001B[${style[1]}m`
            };
            group[styleName] = styles[styleName];
            codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
            value: group,
            enumerable: false
        });
    }
    Object.defineProperty(styles, 'codes', {
        value: codes,
        enumerable: false
    });
    styles.color.close = '\u001B[39m';
    styles.bgColor.close = '\u001B[49m';
    styles.color.ansi = wrapAnsi16();
    styles.color.ansi256 = wrapAnsi256();
    styles.color.ansi16m = wrapAnsi16m();
    styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
    styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
    styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
    // From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
    Object.defineProperties(styles, {
        rgbToAnsi256: {
            value (red, green, blue) {
                // We use the extended greyscale palette here, with the exception of
                // black and white. normal palette only has 4 greyscale shades.
                if (red === green && green === blue) {
                    if (red < 8) {
                        return 16;
                    }
                    if (red > 248) {
                        return 231;
                    }
                    return Math.round((red - 8) / 247 * 24) + 232;
                }
                return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
            },
            enumerable: false
        },
        hexToRgb: {
            value (hex) {
                const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
                if (!matches) {
                    return [
                        0,
                        0,
                        0
                    ];
                }
                let [colorString] = matches;
                if (colorString.length === 3) {
                    colorString = [
                        ...colorString
                    ].map((character)=>character + character).join('');
                }
                const integer = Number.parseInt(colorString, 16);
                return [
                    /* eslint-disable no-bitwise */ integer >> 16 & 0xFF,
                    integer >> 8 & 0xFF,
                    integer & 0xFF
                ];
            },
            enumerable: false
        },
        hexToAnsi256: {
            value: (hex)=>styles.rgbToAnsi256(...styles.hexToRgb(hex)),
            enumerable: false
        },
        ansi256ToAnsi: {
            value (code) {
                if (code < 8) {
                    return 30 + code;
                }
                if (code < 16) {
                    return 90 + (code - 8);
                }
                let red;
                let green;
                let blue;
                if (code >= 232) {
                    red = ((code - 232) * 10 + 8) / 255;
                    green = red;
                    blue = red;
                } else {
                    code -= 16;
                    const remainder = code % 36;
                    red = Math.floor(code / 36) / 5;
                    green = Math.floor(remainder / 6) / 5;
                    blue = remainder % 6 / 5;
                }
                const value = Math.max(red, green, blue) * 2;
                if (value === 0) {
                    return 30;
                }
                // eslint-disable-next-line no-bitwise
                let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
                if (value === 2) {
                    result += 60;
                }
                return result;
            },
            enumerable: false
        },
        rgbToAnsi: {
            value: (red, green, blue)=>styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
            enumerable: false
        },
        hexToAnsi: {
            value: (hex)=>styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
            enumerable: false
        }
    });
    return styles;
}
const ansiStyles = assembleStyles();
const __TURBOPACK__default__export__ = ansiStyles;
}),
"[project]/align/node_modules/log-symbols/node_modules/chalk/source/vendor/supports-color/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createSupportsColor",
    ()=>createSupportsColor,
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:os [external] (node:os, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$tty__$5b$external$5d$__$28$node$3a$tty$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:tty [external] (node:tty, cjs)");
;
;
;
// From: https://github.com/sindresorhus/has-flag/blob/main/index.js
/// function hasFlag(flag, argv = globalThis.Deno?.args ?? process.argv) {
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].argv) {
    const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf('--');
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
const { env } = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"];
let flagForceColor;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
    flagForceColor = 0;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
    flagForceColor = 1;
}
function envForceColor() {
    if ('FORCE_COLOR' in env) {
        if (env.FORCE_COLOR === 'true') {
            return 1;
        }
        if (env.FORCE_COLOR === 'false') {
            return 0;
        }
        return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
    }
}
function translateLevel(level) {
    if (level === 0) {
        return false;
    }
    return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
    };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
    const noFlagForceColor = envForceColor();
    if (noFlagForceColor !== undefined) {
        flagForceColor = noFlagForceColor;
    }
    const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
    if (forceColor === 0) {
        return 0;
    }
    if (sniffFlags) {
        if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
            return 3;
        }
        if (hasFlag('color=256')) {
            return 2;
        }
    }
    // Check for Azure DevOps pipelines.
    // Has to be above the `!streamIsTTY` check.
    if ('TF_BUILD' in env && 'AGENT_NAME' in env) {
        return 1;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
        return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === 'dumb') {
        return min;
    }
    if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].platform === 'win32') {
        // Windows 10 build 10586 is the first Windows release that supports 256 colors.
        // Windows 10 build 14931 is the first release that supports 16m/TrueColor.
        const osRelease = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["default"].release().split('.');
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10_586) {
            return Number(osRelease[2]) >= 14_931 ? 3 : 2;
        }
        return 1;
    }
    if ('CI' in env) {
        if ([
            'GITHUB_ACTIONS',
            'GITEA_ACTIONS',
            'CIRCLECI'
        ].some((key)=>key in env)) {
            return 3;
        }
        if ([
            'TRAVIS',
            'APPVEYOR',
            'GITLAB_CI',
            'BUILDKITE',
            'DRONE'
        ].some((sign)=>sign in env) || env.CI_NAME === 'codeship') {
            return 1;
        }
        return min;
    }
    if ('TEAMCITY_VERSION' in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === 'truecolor') {
        return 3;
    }
    if (env.TERM === 'xterm-kitty') {
        return 3;
    }
    if (env.TERM === 'xterm-ghostty') {
        return 3;
    }
    if (env.TERM === 'wezterm') {
        return 3;
    }
    if ('TERM_PROGRAM' in env) {
        const version = Number.parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
        switch(env.TERM_PROGRAM){
            case 'iTerm.app':
                {
                    return version >= 3 ? 3 : 2;
                }
            case 'Apple_Terminal':
                {
                    return 2;
                }
        }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
    }
    if ('COLORTERM' in env) {
        return 1;
    }
    return min;
}
function createSupportsColor(stream, options = {}) {
    const level = _supportsColor(stream, {
        streamIsTTY: stream && stream.isTTY,
        ...options
    });
    return translateLevel(level);
}
const supportsColor = {
    stdout: createSupportsColor({
        isTTY: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$tty__$5b$external$5d$__$28$node$3a$tty$2c$__cjs$29$__["default"].isatty(1)
    }),
    stderr: createSupportsColor({
        isTTY: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$tty__$5b$external$5d$__$28$node$3a$tty$2c$__cjs$29$__["default"].isatty(2)
    })
};
const __TURBOPACK__default__export__ = supportsColor;
}),
"[project]/align/node_modules/log-symbols/node_modules/chalk/source/utilities.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// TODO: When targeting Node.js 16, use `String.prototype.replaceAll`.
__turbopack_context__.s([
    "stringEncaseCRLFWithFirstIndex",
    ()=>stringEncaseCRLFWithFirstIndex,
    "stringReplaceAll",
    ()=>stringReplaceAll
]);
function stringReplaceAll(string, substring, replacer) {
    let index = string.indexOf(substring);
    if (index === -1) {
        return string;
    }
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = '';
    do {
        returnValue += string.slice(endIndex, index) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
    }while (index !== -1)
    returnValue += string.slice(endIndex);
    return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
    let endIndex = 0;
    let returnValue = '';
    do {
        const gotCR = string[index - 1] === '\r';
        returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
        endIndex = index + 1;
        index = string.indexOf('\n', endIndex);
    }while (index !== -1)
    returnValue += string.slice(endIndex);
    return returnValue;
}
}),
"[project]/align/node_modules/log-symbols/node_modules/chalk/source/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Chalk",
    ()=>Chalk,
    "chalkStderr",
    ()=>chalkStderr,
    "default",
    ()=>__TURBOPACK__default__export__,
    "supportsColor",
    ()=>stdoutColor,
    "supportsColorStderr",
    ()=>stderrColor
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/log-symbols/node_modules/chalk/source/vendor/ansi-styles/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$supports$2d$color$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/log-symbols/node_modules/chalk/source/vendor/supports-color/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/log-symbols/node_modules/chalk/source/utilities.js [app-route] (ecmascript)");
;
;
;
const { stdout: stdoutColor, stderr: stderrColor } = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$supports$2d$color$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"];
const GENERATOR = Symbol('GENERATOR');
const STYLER = Symbol('STYLER');
const IS_EMPTY = Symbol('IS_EMPTY');
// `supportsColor.level`  `ansiStyles.color[name]` mapping
const levelMapping = [
    'ansi',
    'ansi',
    'ansi256',
    'ansi16m'
];
const styles = Object.create(null);
const applyOptions = (object, options = {})=>{
    if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error('The `level` option should be an integer from 0 to 3');
    }
    // Detect level if not set manually
    const colorLevel = stdoutColor ? stdoutColor.level : 0;
    object.level = options.level === undefined ? colorLevel : options.level;
};
class Chalk {
    constructor(options){
        // eslint-disable-next-line no-constructor-return
        return chalkFactory(options);
    }
}
const chalkFactory = (options)=>{
    const chalk = (...strings)=>strings.join(' ');
    applyOptions(chalk, options);
    Object.setPrototypeOf(chalk, createChalk.prototype);
    return chalk;
};
function createChalk(options) {
    return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])){
    styles[styleName] = {
        get () {
            const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
            Object.defineProperty(this, styleName, {
                value: builder
            });
            return builder;
        }
    };
}
styles.visible = {
    get () {
        const builder = createBuilder(this, this[STYLER], true);
        Object.defineProperty(this, 'visible', {
            value: builder
        });
        return builder;
    }
};
const getModelAnsi = (model, level, type, ...arguments_)=>{
    if (model === 'rgb') {
        if (level === 'ansi16m') {
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"][type].ansi16m(...arguments_);
        }
        if (level === 'ansi256') {
            return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"][type].ansi256(__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].rgbToAnsi256(...arguments_));
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"][type].ansi(__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].rgbToAnsi(...arguments_));
    }
    if (model === 'hex') {
        return getModelAnsi('rgb', level, type, ...__TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].hexToRgb(...arguments_));
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"][type][model](...arguments_);
};
const usedModels = [
    'rgb',
    'hex',
    'ansi256'
];
for (const model of usedModels){
    styles[model] = {
        get () {
            const { level } = this;
            return function(...arguments_) {
                const styler = createStyler(getModelAnsi(model, levelMapping[level], 'color', ...arguments_), __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].color.close, this[STYLER]);
                return createBuilder(this, styler, this[IS_EMPTY]);
            };
        }
    };
    const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
        get () {
            const { level } = this;
            return function(...arguments_) {
                const styler = createStyler(getModelAnsi(model, levelMapping[level], 'bgColor', ...arguments_), __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$vendor$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].bgColor.close, this[STYLER]);
                return createBuilder(this, styler, this[IS_EMPTY]);
            };
        }
    };
}
const proto = Object.defineProperties(()=>{}, {
    ...styles,
    level: {
        enumerable: true,
        get () {
            return this[GENERATOR].level;
        },
        set (level) {
            this[GENERATOR].level = level;
        }
    }
});
const createStyler = (open, close, parent)=>{
    let openAll;
    let closeAll;
    if (parent === undefined) {
        openAll = open;
        closeAll = close;
    } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
    }
    return {
        open,
        close,
        openAll,
        closeAll,
        parent
    };
};
const createBuilder = (self, _styler, _isEmpty)=>{
    // Single argument is hot path, implicit coercion is faster than anything
    // eslint-disable-next-line no-implicit-coercion
    const builder = (...arguments_)=>applyStyle(builder, arguments_.length === 1 ? '' + arguments_[0] : arguments_.join(' '));
    // We alter the prototype because we must return a function, but there is
    // no way to create a function with a different prototype
    Object.setPrototypeOf(builder, proto);
    builder[GENERATOR] = self;
    builder[STYLER] = _styler;
    builder[IS_EMPTY] = _isEmpty;
    return builder;
};
const applyStyle = (self, string)=>{
    if (self.level <= 0 || !string) {
        return self[IS_EMPTY] ? '' : string;
    }
    let styler = self[STYLER];
    if (styler === undefined) {
        return string;
    }
    const { openAll, closeAll } = styler;
    if (string.includes('\u001B')) {
        while(styler !== undefined){
            // Replace any instances already present with a re-opening code
            // otherwise only the part of the string until said closing code
            // will be colored, and the rest will simply be 'plain'.
            string = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringReplaceAll"])(string, styler.close, styler.open);
            styler = styler.parent;
        }
    }
    // We can move both next actions out of loop, because remaining actions in loop won't have
    // any/visible effect on parts we add here. Close the styling before a linebreak and reopen
    // after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
    const lfIndex = string.indexOf('\n');
    if (lfIndex !== -1) {
        string = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringEncaseCRLFWithFirstIndex"])(string, closeAll, openAll, lfIndex);
    }
    return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles);
const chalk = createChalk();
const chalkStderr = createChalk({
    level: stderrColor ? stderrColor.level : 0
});
;
;
const __TURBOPACK__default__export__ = chalk;
}),
"[project]/align/node_modules/log-symbols/node_modules/is-unicode-supported/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>isUnicodeSupported
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
;
function isUnicodeSupported() {
    if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].platform !== 'win32') {
        return __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].env.TERM !== 'linux'; // Linux console (kernel)
    }
    return Boolean(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].env.CI) || Boolean(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].env.WT_SESSION) // Windows Terminal
     || Boolean(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].env.TERMINUS_SUBLIME) // Terminus (<0.2.27)
     || __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].env.ConEmuTask === '{cmd::Cmder}' // ConEmu and cmder
     || __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].env.TERM_PROGRAM === 'Terminus-Sublime' || __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].env.TERM_PROGRAM === 'vscode' || __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].env.TERM === 'xterm-256color' || __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].env.TERM === 'alacritty' || __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].env.TERMINAL_EMULATOR === 'JetBrains-JediTerm';
}
}),
"[project]/align/node_modules/log-symbols/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/align/node_modules/log-symbols/node_modules/chalk/source/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$is$2d$unicode$2d$supported$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/log-symbols/node_modules/is-unicode-supported/index.js [app-route] (ecmascript)");
;
;
const main = {
    info: __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"].blue(''),
    success: __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"].green(''),
    warning: __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"].yellow(''),
    error: __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"].red('')
};
const fallback = {
    info: __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"].blue('i'),
    success: __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"].green(''),
    warning: __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"].yellow(''),
    error: __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"].red('')
};
const logSymbols = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$log$2d$symbols$2f$node_modules$2f$is$2d$unicode$2d$supported$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])() ? main : fallback;
const __TURBOPACK__default__export__ = logSymbols;
}),
"[project]/align/node_modules/color-name/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {
    "aliceblue": [
        240,
        248,
        255
    ],
    "antiquewhite": [
        250,
        235,
        215
    ],
    "aqua": [
        0,
        255,
        255
    ],
    "aquamarine": [
        127,
        255,
        212
    ],
    "azure": [
        240,
        255,
        255
    ],
    "beige": [
        245,
        245,
        220
    ],
    "bisque": [
        255,
        228,
        196
    ],
    "black": [
        0,
        0,
        0
    ],
    "blanchedalmond": [
        255,
        235,
        205
    ],
    "blue": [
        0,
        0,
        255
    ],
    "blueviolet": [
        138,
        43,
        226
    ],
    "brown": [
        165,
        42,
        42
    ],
    "burlywood": [
        222,
        184,
        135
    ],
    "cadetblue": [
        95,
        158,
        160
    ],
    "chartreuse": [
        127,
        255,
        0
    ],
    "chocolate": [
        210,
        105,
        30
    ],
    "coral": [
        255,
        127,
        80
    ],
    "cornflowerblue": [
        100,
        149,
        237
    ],
    "cornsilk": [
        255,
        248,
        220
    ],
    "crimson": [
        220,
        20,
        60
    ],
    "cyan": [
        0,
        255,
        255
    ],
    "darkblue": [
        0,
        0,
        139
    ],
    "darkcyan": [
        0,
        139,
        139
    ],
    "darkgoldenrod": [
        184,
        134,
        11
    ],
    "darkgray": [
        169,
        169,
        169
    ],
    "darkgreen": [
        0,
        100,
        0
    ],
    "darkgrey": [
        169,
        169,
        169
    ],
    "darkkhaki": [
        189,
        183,
        107
    ],
    "darkmagenta": [
        139,
        0,
        139
    ],
    "darkolivegreen": [
        85,
        107,
        47
    ],
    "darkorange": [
        255,
        140,
        0
    ],
    "darkorchid": [
        153,
        50,
        204
    ],
    "darkred": [
        139,
        0,
        0
    ],
    "darksalmon": [
        233,
        150,
        122
    ],
    "darkseagreen": [
        143,
        188,
        143
    ],
    "darkslateblue": [
        72,
        61,
        139
    ],
    "darkslategray": [
        47,
        79,
        79
    ],
    "darkslategrey": [
        47,
        79,
        79
    ],
    "darkturquoise": [
        0,
        206,
        209
    ],
    "darkviolet": [
        148,
        0,
        211
    ],
    "deeppink": [
        255,
        20,
        147
    ],
    "deepskyblue": [
        0,
        191,
        255
    ],
    "dimgray": [
        105,
        105,
        105
    ],
    "dimgrey": [
        105,
        105,
        105
    ],
    "dodgerblue": [
        30,
        144,
        255
    ],
    "firebrick": [
        178,
        34,
        34
    ],
    "floralwhite": [
        255,
        250,
        240
    ],
    "forestgreen": [
        34,
        139,
        34
    ],
    "fuchsia": [
        255,
        0,
        255
    ],
    "gainsboro": [
        220,
        220,
        220
    ],
    "ghostwhite": [
        248,
        248,
        255
    ],
    "gold": [
        255,
        215,
        0
    ],
    "goldenrod": [
        218,
        165,
        32
    ],
    "gray": [
        128,
        128,
        128
    ],
    "green": [
        0,
        128,
        0
    ],
    "greenyellow": [
        173,
        255,
        47
    ],
    "grey": [
        128,
        128,
        128
    ],
    "honeydew": [
        240,
        255,
        240
    ],
    "hotpink": [
        255,
        105,
        180
    ],
    "indianred": [
        205,
        92,
        92
    ],
    "indigo": [
        75,
        0,
        130
    ],
    "ivory": [
        255,
        255,
        240
    ],
    "khaki": [
        240,
        230,
        140
    ],
    "lavender": [
        230,
        230,
        250
    ],
    "lavenderblush": [
        255,
        240,
        245
    ],
    "lawngreen": [
        124,
        252,
        0
    ],
    "lemonchiffon": [
        255,
        250,
        205
    ],
    "lightblue": [
        173,
        216,
        230
    ],
    "lightcoral": [
        240,
        128,
        128
    ],
    "lightcyan": [
        224,
        255,
        255
    ],
    "lightgoldenrodyellow": [
        250,
        250,
        210
    ],
    "lightgray": [
        211,
        211,
        211
    ],
    "lightgreen": [
        144,
        238,
        144
    ],
    "lightgrey": [
        211,
        211,
        211
    ],
    "lightpink": [
        255,
        182,
        193
    ],
    "lightsalmon": [
        255,
        160,
        122
    ],
    "lightseagreen": [
        32,
        178,
        170
    ],
    "lightskyblue": [
        135,
        206,
        250
    ],
    "lightslategray": [
        119,
        136,
        153
    ],
    "lightslategrey": [
        119,
        136,
        153
    ],
    "lightsteelblue": [
        176,
        196,
        222
    ],
    "lightyellow": [
        255,
        255,
        224
    ],
    "lime": [
        0,
        255,
        0
    ],
    "limegreen": [
        50,
        205,
        50
    ],
    "linen": [
        250,
        240,
        230
    ],
    "magenta": [
        255,
        0,
        255
    ],
    "maroon": [
        128,
        0,
        0
    ],
    "mediumaquamarine": [
        102,
        205,
        170
    ],
    "mediumblue": [
        0,
        0,
        205
    ],
    "mediumorchid": [
        186,
        85,
        211
    ],
    "mediumpurple": [
        147,
        112,
        219
    ],
    "mediumseagreen": [
        60,
        179,
        113
    ],
    "mediumslateblue": [
        123,
        104,
        238
    ],
    "mediumspringgreen": [
        0,
        250,
        154
    ],
    "mediumturquoise": [
        72,
        209,
        204
    ],
    "mediumvioletred": [
        199,
        21,
        133
    ],
    "midnightblue": [
        25,
        25,
        112
    ],
    "mintcream": [
        245,
        255,
        250
    ],
    "mistyrose": [
        255,
        228,
        225
    ],
    "moccasin": [
        255,
        228,
        181
    ],
    "navajowhite": [
        255,
        222,
        173
    ],
    "navy": [
        0,
        0,
        128
    ],
    "oldlace": [
        253,
        245,
        230
    ],
    "olive": [
        128,
        128,
        0
    ],
    "olivedrab": [
        107,
        142,
        35
    ],
    "orange": [
        255,
        165,
        0
    ],
    "orangered": [
        255,
        69,
        0
    ],
    "orchid": [
        218,
        112,
        214
    ],
    "palegoldenrod": [
        238,
        232,
        170
    ],
    "palegreen": [
        152,
        251,
        152
    ],
    "paleturquoise": [
        175,
        238,
        238
    ],
    "palevioletred": [
        219,
        112,
        147
    ],
    "papayawhip": [
        255,
        239,
        213
    ],
    "peachpuff": [
        255,
        218,
        185
    ],
    "peru": [
        205,
        133,
        63
    ],
    "pink": [
        255,
        192,
        203
    ],
    "plum": [
        221,
        160,
        221
    ],
    "powderblue": [
        176,
        224,
        230
    ],
    "purple": [
        128,
        0,
        128
    ],
    "rebeccapurple": [
        102,
        51,
        153
    ],
    "red": [
        255,
        0,
        0
    ],
    "rosybrown": [
        188,
        143,
        143
    ],
    "royalblue": [
        65,
        105,
        225
    ],
    "saddlebrown": [
        139,
        69,
        19
    ],
    "salmon": [
        250,
        128,
        114
    ],
    "sandybrown": [
        244,
        164,
        96
    ],
    "seagreen": [
        46,
        139,
        87
    ],
    "seashell": [
        255,
        245,
        238
    ],
    "sienna": [
        160,
        82,
        45
    ],
    "silver": [
        192,
        192,
        192
    ],
    "skyblue": [
        135,
        206,
        235
    ],
    "slateblue": [
        106,
        90,
        205
    ],
    "slategray": [
        112,
        128,
        144
    ],
    "slategrey": [
        112,
        128,
        144
    ],
    "snow": [
        255,
        250,
        250
    ],
    "springgreen": [
        0,
        255,
        127
    ],
    "steelblue": [
        70,
        130,
        180
    ],
    "tan": [
        210,
        180,
        140
    ],
    "teal": [
        0,
        128,
        128
    ],
    "thistle": [
        216,
        191,
        216
    ],
    "tomato": [
        255,
        99,
        71
    ],
    "turquoise": [
        64,
        224,
        208
    ],
    "violet": [
        238,
        130,
        238
    ],
    "wheat": [
        245,
        222,
        179
    ],
    "white": [
        255,
        255,
        255
    ],
    "whitesmoke": [
        245,
        245,
        245
    ],
    "yellow": [
        255,
        255,
        0
    ],
    "yellowgreen": [
        154,
        205,
        50
    ]
};
}),
"[project]/align/node_modules/color-convert/conversions.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/* MIT license */ /* eslint-disable no-mixed-operators */ const cssKeywords = __turbopack_context__.r("[project]/align/node_modules/color-name/index.js [app-route] (ecmascript)");
// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)
const reverseKeywords = {};
for (const key of Object.keys(cssKeywords)){
    reverseKeywords[cssKeywords[key]] = key;
}
const convert = {
    rgb: {
        channels: 3,
        labels: 'rgb'
    },
    hsl: {
        channels: 3,
        labels: 'hsl'
    },
    hsv: {
        channels: 3,
        labels: 'hsv'
    },
    hwb: {
        channels: 3,
        labels: 'hwb'
    },
    cmyk: {
        channels: 4,
        labels: 'cmyk'
    },
    xyz: {
        channels: 3,
        labels: 'xyz'
    },
    lab: {
        channels: 3,
        labels: 'lab'
    },
    lch: {
        channels: 3,
        labels: 'lch'
    },
    hex: {
        channels: 1,
        labels: [
            'hex'
        ]
    },
    keyword: {
        channels: 1,
        labels: [
            'keyword'
        ]
    },
    ansi16: {
        channels: 1,
        labels: [
            'ansi16'
        ]
    },
    ansi256: {
        channels: 1,
        labels: [
            'ansi256'
        ]
    },
    hcg: {
        channels: 3,
        labels: [
            'h',
            'c',
            'g'
        ]
    },
    apple: {
        channels: 3,
        labels: [
            'r16',
            'g16',
            'b16'
        ]
    },
    gray: {
        channels: 1,
        labels: [
            'gray'
        ]
    }
};
module.exports = convert;
// Hide .channels and .labels properties
for (const model of Object.keys(convert)){
    if (!('channels' in convert[model])) {
        throw new Error('missing channels property: ' + model);
    }
    if (!('labels' in convert[model])) {
        throw new Error('missing channel labels property: ' + model);
    }
    if (convert[model].labels.length !== convert[model].channels) {
        throw new Error('channel and label counts mismatch: ' + model);
    }
    const { channels, labels } = convert[model];
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], 'channels', {
        value: channels
    });
    Object.defineProperty(convert[model], 'labels', {
        value: labels
    });
}
convert.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;
    if (max === min) {
        h = 0;
    } else if (r === max) {
        h = (g - b) / delta;
    } else if (g === max) {
        h = 2 + (b - r) / delta;
    } else if (b === max) {
        h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
        h += 360;
    }
    const l = (min + max) / 2;
    if (max === min) {
        s = 0;
    } else if (l <= 0.5) {
        s = delta / (max + min);
    } else {
        s = delta / (2 - max - min);
    }
    return [
        h,
        s * 100,
        l * 100
    ];
};
convert.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
        h = 0;
        s = 0;
    } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
            h = bdif - gdif;
        } else if (g === v) {
            h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
            h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
            h += 1;
        } else if (h > 1) {
            h -= 1;
        }
    }
    return [
        h * 360,
        s * 100,
        v * 100
    ];
};
convert.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = convert.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [
        h,
        w * 100,
        b * 100
    ];
};
convert.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [
        c * 100,
        m * 100,
        y * 100,
        k * 100
    ];
};
function comparativeDistance(x, y) {
    /*
		See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	*/ return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
}
convert.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
        return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)){
        const value = cssKeywords[keyword];
        // Compute comparative distance
        const distance = comparativeDistance(rgb, value);
        // Check if its less, if so set as closest
        if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
        }
    }
    return currentClosestKeyword;
};
convert.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
};
convert.rgb.xyz = function(rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;
    // Assume sRGB
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [
        x * 100,
        y * 100,
        z * 100
    ];
};
convert.rgb.lab = function(rgb) {
    const xyz = convert.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [
        l,
        a,
        b
    ];
};
convert.hsl.rgb = function(hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s === 0) {
        val = l * 255;
        return [
            val,
            val,
            val
        ];
    }
    if (l < 0.5) {
        t2 = l * (1 + s);
    } else {
        t2 = l + s - l * s;
    }
    const t1 = 2 * l - t2;
    const rgb = [
        0,
        0,
        0
    ];
    for(let i = 0; i < 3; i++){
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
            t3++;
        }
        if (t3 > 1) {
            t3--;
        }
        if (6 * t3 < 1) {
            val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
            val = t2;
        } else if (3 * t3 < 2) {
            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
            val = t1;
        }
        rgb[i] = val * 255;
    }
    return rgb;
};
convert.hsl.hsv = function(hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [
        h,
        sv * 100,
        v * 100
    ];
};
convert.hsv.rgb = function(hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch(hi){
        case 0:
            return [
                v,
                t,
                p
            ];
        case 1:
            return [
                q,
                v,
                p
            ];
        case 2:
            return [
                p,
                v,
                t
            ];
        case 3:
            return [
                p,
                q,
                v
            ];
        case 4:
            return [
                t,
                p,
                v
            ];
        case 5:
            return [
                v,
                p,
                q
            ];
    }
};
convert.hsv.hsl = function(hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [
        h,
        sl * 100,
        l * 100
    ];
};
// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function(hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    // Wh + bl cant be > 1
    if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 0x01) !== 0) {
        f = 1 - f;
    }
    const n = wh + f * (v - wh); // Linear interpolation
    let r;
    let g;
    let b;
    /* eslint-disable max-statements-per-line,no-multi-spaces */ switch(i){
        default:
        case 6:
        case 0:
            r = v;
            g = n;
            b = wh;
            break;
        case 1:
            r = n;
            g = v;
            b = wh;
            break;
        case 2:
            r = wh;
            g = v;
            b = n;
            break;
        case 3:
            r = wh;
            g = n;
            b = v;
            break;
        case 4:
            r = n;
            g = wh;
            b = v;
            break;
        case 5:
            r = v;
            g = wh;
            b = n;
            break;
    }
    /* eslint-enable max-statements-per-line,no-multi-spaces */ return [
        r * 255,
        g * 255,
        b * 255
    ];
};
convert.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [
        r * 255,
        g * 255,
        b * 255
    ];
};
convert.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.2040 + z * 1.0570;
    // Assume sRGB
    r = r > 0.0031308 ? 1.055 * r ** (1.0 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * g ** (1.0 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * b ** (1.0 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [
        r * 255,
        g * 255,
        b * 255
    ];
};
convert.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [
        l,
        a,
        b
    ];
};
convert.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [
        x,
        y,
        z
    ];
};
convert.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
        h += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [
        l,
        c,
        h
    ];
};
convert.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [
        l,
        a,
        b
    ];
};
convert.rgb.ansi16 = function(args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization
    value = Math.round(value / 50);
    if (value === 0) {
        return 30;
    }
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
        ansi += 60;
    }
    return ansi;
};
convert.hsv.ansi16 = function(args) {
    // Optimization here; we already know the value and don't need to get
    // it converted for us.
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};
convert.rgb.ansi256 = function(args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    // We use the extended greyscale palette here, with the exception of
    // black and white. normal palette only has 4 greyscale shades.
    if (r === g && g === b) {
        if (r < 8) {
            return 16;
        }
        if (r > 248) {
            return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
};
convert.ansi16.rgb = function(args) {
    let color = args % 10;
    // Handle greyscale
    if (color === 0 || color === 7) {
        if (args > 50) {
            color += 3.5;
        }
        color = color / 10.5 * 255;
        return [
            color,
            color,
            color
        ];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [
        r,
        g,
        b
    ];
};
convert.ansi256.rgb = function(args) {
    // Handle greyscale
    if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [
            c,
            c,
            c
        ];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [
        r,
        g,
        b
    ];
};
convert.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
    const string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
};
convert.hex.rgb = function(args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
        return [
            0,
            0,
            0
        ];
    }
    let colorString = match[0];
    if (match[0].length === 3) {
        colorString = colorString.split('').map((char)=>{
            return char + char;
        }).join('');
    }
    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 0xFF;
    const g = integer >> 8 & 0xFF;
    const b = integer & 0xFF;
    return [
        r,
        g,
        b
    ];
};
convert.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let grayscale;
    let hue;
    if (chroma < 1) {
        grayscale = min / (1 - chroma);
    } else {
        grayscale = 0;
    }
    if (chroma <= 0) {
        hue = 0;
    } else if (max === r) {
        hue = (g - b) / chroma % 6;
    } else if (max === g) {
        hue = 2 + (b - r) / chroma;
    } else {
        hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [
        hue * 360,
        chroma * 100,
        grayscale * 100
    ];
};
convert.hsl.hcg = function(hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2.0 * s * l : 2.0 * s * (1.0 - l);
    let f = 0;
    if (c < 1.0) {
        f = (l - 0.5 * c) / (1.0 - c);
    }
    return [
        hsl[0],
        c * 100,
        f * 100
    ];
};
convert.hsv.hcg = function(hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1.0) {
        f = (v - c) / (1 - c);
    }
    return [
        hsv[0],
        c * 100,
        f * 100
    ];
};
convert.hcg.rgb = function(hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0.0) {
        return [
            g * 255,
            g * 255,
            g * 255
        ];
    }
    const pure = [
        0,
        0,
        0
    ];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    /* eslint-disable max-statements-per-line */ switch(Math.floor(hi)){
        case 0:
            pure[0] = 1;
            pure[1] = v;
            pure[2] = 0;
            break;
        case 1:
            pure[0] = w;
            pure[1] = 1;
            pure[2] = 0;
            break;
        case 2:
            pure[0] = 0;
            pure[1] = 1;
            pure[2] = v;
            break;
        case 3:
            pure[0] = 0;
            pure[1] = w;
            pure[2] = 1;
            break;
        case 4:
            pure[0] = v;
            pure[1] = 0;
            pure[2] = 1;
            break;
        default:
            pure[0] = 1;
            pure[1] = 0;
            pure[2] = w;
    }
    /* eslint-enable max-statements-per-line */ mg = (1.0 - c) * g;
    return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
    ];
};
convert.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1.0 - c);
    let f = 0;
    if (v > 0.0) {
        f = c / v;
    }
    return [
        hcg[0],
        f * 100,
        v * 100
    ];
};
convert.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1.0 - c) + 0.5 * c;
    let s = 0;
    if (l > 0.0 && l < 0.5) {
        s = c / (2 * l);
    } else if (l >= 0.5 && l < 1.0) {
        s = c / (2 * (1 - l));
    }
    return [
        hcg[0],
        s * 100,
        l * 100
    ];
};
convert.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1.0 - c);
    return [
        hcg[0],
        (v - c) * 100,
        (1 - v) * 100
    ];
};
convert.hwb.hcg = function(hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) {
        g = (v - c) / (1 - c);
    }
    return [
        hwb[0],
        c * 100,
        g * 100
    ];
};
convert.apple.rgb = function(apple) {
    return [
        apple[0] / 65535 * 255,
        apple[1] / 65535 * 255,
        apple[2] / 65535 * 255
    ];
};
convert.rgb.apple = function(rgb) {
    return [
        rgb[0] / 255 * 65535,
        rgb[1] / 255 * 65535,
        rgb[2] / 255 * 65535
    ];
};
convert.gray.rgb = function(args) {
    return [
        args[0] / 100 * 255,
        args[0] / 100 * 255,
        args[0] / 100 * 255
    ];
};
convert.gray.hsl = function(args) {
    return [
        0,
        0,
        args[0]
    ];
};
convert.gray.hsv = convert.gray.hsl;
convert.gray.hwb = function(gray) {
    return [
        0,
        100,
        gray[0]
    ];
};
convert.gray.cmyk = function(gray) {
    return [
        0,
        0,
        0,
        gray[0]
    ];
};
convert.gray.lab = function(gray) {
    return [
        gray[0],
        0,
        0
    ];
};
convert.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 0xFF;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
};
convert.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [
        val / 255 * 100
    ];
};
}),
"[project]/align/node_modules/color-convert/route.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const conversions = __turbopack_context__.r("[project]/align/node_modules/color-convert/conversions.js [app-route] (ecmascript)");
/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/ function buildGraph() {
    const graph = {};
    // https://jsperf.com/object-keys-vs-for-in-with-closure/3
    const models = Object.keys(conversions);
    for(let len = models.length, i = 0; i < len; i++){
        graph[models[i]] = {
            // http://jsperf.com/1-vs-infinity
            // micro-opt, but this is simple.
            distance: -1,
            parent: null
        };
    }
    return graph;
}
// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [
        fromModel
    ]; // Unshift -> queue -> pop
    graph[fromModel].distance = 0;
    while(queue.length){
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for(let len = adjacents.length, i = 0; i < len; i++){
            const adjacent = adjacents[i];
            const node = graph[adjacent];
            if (node.distance === -1) {
                node.distance = graph[current].distance + 1;
                node.parent = current;
                queue.unshift(adjacent);
            }
        }
    }
    return graph;
}
function link(from, to) {
    return function(args) {
        return to(from(args));
    };
}
function wrapConversion(toModel, graph) {
    const path = [
        graph[toModel].parent,
        toModel
    ];
    let fn = conversions[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while(graph[cur].parent){
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
    }
    fn.conversion = path;
    return fn;
}
module.exports = function(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for(let len = models.length, i = 0; i < len; i++){
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
            continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
};
}),
"[project]/align/node_modules/color-convert/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const conversions = __turbopack_context__.r("[project]/align/node_modules/color-convert/conversions.js [app-route] (ecmascript)");
const route = __turbopack_context__.r("[project]/align/node_modules/color-convert/route.js [app-route] (ecmascript)");
const convert = {};
const models = Object.keys(conversions);
function wrapRaw(fn) {
    const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === undefined || arg0 === null) {
            return arg0;
        }
        if (arg0.length > 1) {
            args = arg0;
        }
        return fn(args);
    };
    // Preserve .conversion property if there is one
    if ('conversion' in fn) {
        wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
}
function wrapRounded(fn) {
    const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === undefined || arg0 === null) {
            return arg0;
        }
        if (arg0.length > 1) {
            args = arg0;
        }
        const result = fn(args);
        // We're assuming the result is an array here.
        // see notice in conversions.js; don't use box types
        // in conversion functions.
        if (typeof result === 'object') {
            for(let len = result.length, i = 0; i < len; i++){
                result[i] = Math.round(result[i]);
            }
        }
        return result;
    };
    // Preserve .conversion property if there is one
    if ('conversion' in fn) {
        wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
}
models.forEach((fromModel)=>{
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], 'channels', {
        value: conversions[fromModel].channels
    });
    Object.defineProperty(convert[fromModel], 'labels', {
        value: conversions[fromModel].labels
    });
    const routes = route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel)=>{
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
    });
});
module.exports = convert;
}),
"[project]/align/node_modules/ansi-styles/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const wrapAnsi16 = (fn, offset)=>(...args)=>{
        const code = fn(...args);
        return `\u001B[${code + offset}m`;
    };
const wrapAnsi256 = (fn, offset)=>(...args)=>{
        const code = fn(...args);
        return `\u001B[${38 + offset};5;${code}m`;
    };
const wrapAnsi16m = (fn, offset)=>(...args)=>{
        const rgb = fn(...args);
        return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
const ansi2ansi = (n)=>n;
const rgb2rgb = (r, g, b)=>[
        r,
        g,
        b
    ];
const setLazyProperty = (object, property, get)=>{
    Object.defineProperty(object, property, {
        get: ()=>{
            const value = get();
            Object.defineProperty(object, property, {
                value,
                enumerable: true,
                configurable: true
            });
            return value;
        },
        enumerable: true,
        configurable: true
    });
};
/** @type {typeof import('color-convert')} */ let colorConvert;
const makeDynamicStyles = (wrap, targetSpace, identity, isBackground)=>{
    if (colorConvert === undefined) {
        colorConvert = __turbopack_context__.r("[project]/align/node_modules/color-convert/index.js [app-route] (ecmascript)");
    }
    const offset = isBackground ? 10 : 0;
    const styles = {};
    for (const [sourceSpace, suite] of Object.entries(colorConvert)){
        const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
        if (sourceSpace === targetSpace) {
            styles[name] = wrap(identity, offset);
        } else if (typeof suite === 'object') {
            styles[name] = wrap(suite[targetSpace], offset);
        }
    }
    return styles;
};
function assembleStyles() {
    const codes = new Map();
    const styles = {
        modifier: {
            reset: [
                0,
                0
            ],
            // 21 isn't widely supported and 22 does the same thing
            bold: [
                1,
                22
            ],
            dim: [
                2,
                22
            ],
            italic: [
                3,
                23
            ],
            underline: [
                4,
                24
            ],
            inverse: [
                7,
                27
            ],
            hidden: [
                8,
                28
            ],
            strikethrough: [
                9,
                29
            ]
        },
        color: {
            black: [
                30,
                39
            ],
            red: [
                31,
                39
            ],
            green: [
                32,
                39
            ],
            yellow: [
                33,
                39
            ],
            blue: [
                34,
                39
            ],
            magenta: [
                35,
                39
            ],
            cyan: [
                36,
                39
            ],
            white: [
                37,
                39
            ],
            // Bright color
            blackBright: [
                90,
                39
            ],
            redBright: [
                91,
                39
            ],
            greenBright: [
                92,
                39
            ],
            yellowBright: [
                93,
                39
            ],
            blueBright: [
                94,
                39
            ],
            magentaBright: [
                95,
                39
            ],
            cyanBright: [
                96,
                39
            ],
            whiteBright: [
                97,
                39
            ]
        },
        bgColor: {
            bgBlack: [
                40,
                49
            ],
            bgRed: [
                41,
                49
            ],
            bgGreen: [
                42,
                49
            ],
            bgYellow: [
                43,
                49
            ],
            bgBlue: [
                44,
                49
            ],
            bgMagenta: [
                45,
                49
            ],
            bgCyan: [
                46,
                49
            ],
            bgWhite: [
                47,
                49
            ],
            // Bright color
            bgBlackBright: [
                100,
                49
            ],
            bgRedBright: [
                101,
                49
            ],
            bgGreenBright: [
                102,
                49
            ],
            bgYellowBright: [
                103,
                49
            ],
            bgBlueBright: [
                104,
                49
            ],
            bgMagentaBright: [
                105,
                49
            ],
            bgCyanBright: [
                106,
                49
            ],
            bgWhiteBright: [
                107,
                49
            ]
        }
    };
    // Alias bright black as gray (and grey)
    styles.color.gray = styles.color.blackBright;
    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
    styles.color.grey = styles.color.blackBright;
    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles)){
        for (const [styleName, style] of Object.entries(group)){
            styles[styleName] = {
                open: `\u001B[${style[0]}m`,
                close: `\u001B[${style[1]}m`
            };
            group[styleName] = styles[styleName];
            codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
            value: group,
            enumerable: false
        });
    }
    Object.defineProperty(styles, 'codes', {
        value: codes,
        enumerable: false
    });
    styles.color.close = '\u001B[39m';
    styles.bgColor.close = '\u001B[49m';
    setLazyProperty(styles.color, 'ansi', ()=>makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
    setLazyProperty(styles.color, 'ansi256', ()=>makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
    setLazyProperty(styles.color, 'ansi16m', ()=>makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
    setLazyProperty(styles.bgColor, 'ansi', ()=>makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
    setLazyProperty(styles.bgColor, 'ansi256', ()=>makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
    setLazyProperty(styles.bgColor, 'ansi16m', ()=>makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));
    return styles;
}
// Make the export immutable
Object.defineProperty(module, 'exports', {
    enumerable: true,
    get: assembleStyles
});
}),
"[project]/align/node_modules/jest-diff/node_modules/ansi-styles/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const ANSI_BACKGROUND_OFFSET = 10;
const wrapAnsi256 = (offset = 0)=>(code)=>`\u001B[${38 + offset};5;${code}m`;
const wrapAnsi16m = (offset = 0)=>(red, green, blue)=>`\u001B[${38 + offset};2;${red};${green};${blue}m`;
function assembleStyles() {
    const codes = new Map();
    const styles = {
        modifier: {
            reset: [
                0,
                0
            ],
            // 21 isn't widely supported and 22 does the same thing
            bold: [
                1,
                22
            ],
            dim: [
                2,
                22
            ],
            italic: [
                3,
                23
            ],
            underline: [
                4,
                24
            ],
            overline: [
                53,
                55
            ],
            inverse: [
                7,
                27
            ],
            hidden: [
                8,
                28
            ],
            strikethrough: [
                9,
                29
            ]
        },
        color: {
            black: [
                30,
                39
            ],
            red: [
                31,
                39
            ],
            green: [
                32,
                39
            ],
            yellow: [
                33,
                39
            ],
            blue: [
                34,
                39
            ],
            magenta: [
                35,
                39
            ],
            cyan: [
                36,
                39
            ],
            white: [
                37,
                39
            ],
            // Bright color
            blackBright: [
                90,
                39
            ],
            redBright: [
                91,
                39
            ],
            greenBright: [
                92,
                39
            ],
            yellowBright: [
                93,
                39
            ],
            blueBright: [
                94,
                39
            ],
            magentaBright: [
                95,
                39
            ],
            cyanBright: [
                96,
                39
            ],
            whiteBright: [
                97,
                39
            ]
        },
        bgColor: {
            bgBlack: [
                40,
                49
            ],
            bgRed: [
                41,
                49
            ],
            bgGreen: [
                42,
                49
            ],
            bgYellow: [
                43,
                49
            ],
            bgBlue: [
                44,
                49
            ],
            bgMagenta: [
                45,
                49
            ],
            bgCyan: [
                46,
                49
            ],
            bgWhite: [
                47,
                49
            ],
            // Bright color
            bgBlackBright: [
                100,
                49
            ],
            bgRedBright: [
                101,
                49
            ],
            bgGreenBright: [
                102,
                49
            ],
            bgYellowBright: [
                103,
                49
            ],
            bgBlueBright: [
                104,
                49
            ],
            bgMagentaBright: [
                105,
                49
            ],
            bgCyanBright: [
                106,
                49
            ],
            bgWhiteBright: [
                107,
                49
            ]
        }
    };
    // Alias bright black as gray (and grey)
    styles.color.gray = styles.color.blackBright;
    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
    styles.color.grey = styles.color.blackBright;
    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles)){
        for (const [styleName, style] of Object.entries(group)){
            styles[styleName] = {
                open: `\u001B[${style[0]}m`,
                close: `\u001B[${style[1]}m`
            };
            group[styleName] = styles[styleName];
            codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
            value: group,
            enumerable: false
        });
    }
    Object.defineProperty(styles, 'codes', {
        value: codes,
        enumerable: false
    });
    styles.color.close = '\u001B[39m';
    styles.bgColor.close = '\u001B[49m';
    styles.color.ansi256 = wrapAnsi256();
    styles.color.ansi16m = wrapAnsi16m();
    styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
    styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
    // From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
    Object.defineProperties(styles, {
        rgbToAnsi256: {
            value: (red, green, blue)=>{
                // We use the extended greyscale palette here, with the exception of
                // black and white. normal palette only has 4 greyscale shades.
                if (red === green && green === blue) {
                    if (red < 8) {
                        return 16;
                    }
                    if (red > 248) {
                        return 231;
                    }
                    return Math.round((red - 8) / 247 * 24) + 232;
                }
                return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
            },
            enumerable: false
        },
        hexToRgb: {
            value: (hex)=>{
                const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
                if (!matches) {
                    return [
                        0,
                        0,
                        0
                    ];
                }
                let { colorString } = matches.groups;
                if (colorString.length === 3) {
                    colorString = colorString.split('').map((character)=>character + character).join('');
                }
                const integer = Number.parseInt(colorString, 16);
                return [
                    integer >> 16 & 0xFF,
                    integer >> 8 & 0xFF,
                    integer & 0xFF
                ];
            },
            enumerable: false
        },
        hexToAnsi256: {
            value: (hex)=>styles.rgbToAnsi256(...styles.hexToRgb(hex)),
            enumerable: false
        }
    });
    return styles;
}
// Make the export immutable
Object.defineProperty(module, 'exports', {
    enumerable: true,
    get: assembleStyles
});
}),
"[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/collections.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.printIteratorEntries = printIteratorEntries;
exports.printIteratorValues = printIteratorValues;
exports.printListItems = printListItems;
exports.printObjectProperties = printObjectProperties;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ const getKeysOfEnumerableProperties = (object, compareKeys)=>{
    const rawKeys = Object.keys(object);
    const keys = compareKeys !== null ? rawKeys.sort(compareKeys) : rawKeys;
    if (Object.getOwnPropertySymbols) {
        Object.getOwnPropertySymbols(object).forEach((symbol)=>{
            if (Object.getOwnPropertyDescriptor(object, symbol).enumerable) {
                keys.push(symbol);
            }
        });
    }
    return keys;
};
/**
 * Return entries (for example, of a map)
 * with spacing, indentation, and comma
 * without surrounding punctuation (for example, braces)
 */ function printIteratorEntries(iterator, config, indentation, depth, refs, printer, // Too bad, so sad that separator for ECMAScript Map has been ' => '
// What a distracting diff if you change a data structure to/from
// ECMAScript Object or Immutable.Map/OrderedMap which use the default.
separator = ': ') {
    let result = '';
    let width = 0;
    let current = iterator.next();
    if (!current.done) {
        result += config.spacingOuter;
        const indentationNext = indentation + config.indent;
        while(!current.done){
            result += indentationNext;
            if (width++ === config.maxWidth) {
                result += '';
                break;
            }
            const name = printer(current.value[0], config, indentationNext, depth, refs);
            const value = printer(current.value[1], config, indentationNext, depth, refs);
            result += name + separator + value;
            current = iterator.next();
            if (!current.done) {
                result += `,${config.spacingInner}`;
            } else if (!config.min) {
                result += ',';
            }
        }
        result += config.spacingOuter + indentation;
    }
    return result;
}
/**
 * Return values (for example, of a set)
 * with spacing, indentation, and comma
 * without surrounding punctuation (braces or brackets)
 */ function printIteratorValues(iterator, config, indentation, depth, refs, printer) {
    let result = '';
    let width = 0;
    let current = iterator.next();
    if (!current.done) {
        result += config.spacingOuter;
        const indentationNext = indentation + config.indent;
        while(!current.done){
            result += indentationNext;
            if (width++ === config.maxWidth) {
                result += '';
                break;
            }
            result += printer(current.value, config, indentationNext, depth, refs);
            current = iterator.next();
            if (!current.done) {
                result += `,${config.spacingInner}`;
            } else if (!config.min) {
                result += ',';
            }
        }
        result += config.spacingOuter + indentation;
    }
    return result;
}
/**
 * Return items (for example, of an array)
 * with spacing, indentation, and comma
 * without surrounding punctuation (for example, brackets)
 **/ function printListItems(list, config, indentation, depth, refs, printer) {
    let result = '';
    if (list.length) {
        result += config.spacingOuter;
        const indentationNext = indentation + config.indent;
        for(let i = 0; i < list.length; i++){
            result += indentationNext;
            if (i === config.maxWidth) {
                result += '';
                break;
            }
            if (i in list) {
                result += printer(list[i], config, indentationNext, depth, refs);
            }
            if (i < list.length - 1) {
                result += `,${config.spacingInner}`;
            } else if (!config.min) {
                result += ',';
            }
        }
        result += config.spacingOuter + indentation;
    }
    return result;
}
/**
 * Return properties of an object
 * with spacing, indentation, and comma
 * without surrounding punctuation (for example, braces)
 */ function printObjectProperties(val, config, indentation, depth, refs, printer) {
    let result = '';
    const keys = getKeysOfEnumerableProperties(val, config.compareKeys);
    if (keys.length) {
        result += config.spacingOuter;
        const indentationNext = indentation + config.indent;
        for(let i = 0; i < keys.length; i++){
            const key = keys[i];
            const name = printer(key, config, indentationNext, depth, refs);
            const value = printer(val[key], config, indentationNext, depth, refs);
            result += `${indentationNext + name}: ${value}`;
            if (i < keys.length - 1) {
                result += `,${config.spacingInner}`;
            } else if (!config.min) {
                result += ',';
            }
        }
        result += config.spacingOuter + indentation;
    }
    return result;
}
}),
"[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/plugins/AsymmetricMatcher.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.test = exports.serialize = exports.default = void 0;
var _collections = __turbopack_context__.r("[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/collections.js [app-route] (ecmascript)");
var Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ const asymmetricMatcher = typeof Symbol === 'function' && Symbol.for ? Symbol.for('jest.asymmetricMatcher') : 0x1357a5;
const SPACE = ' ';
const serialize = (val, config, indentation, depth, refs, printer)=>{
    const stringedValue = val.toString();
    if (stringedValue === 'ArrayContaining' || stringedValue === 'ArrayNotContaining') {
        if (++depth > config.maxDepth) {
            return `[${stringedValue}]`;
        }
        return `${stringedValue + SPACE}[${(0, _collections.printListItems)(val.sample, config, indentation, depth, refs, printer)}]`;
    }
    if (stringedValue === 'ObjectContaining' || stringedValue === 'ObjectNotContaining') {
        if (++depth > config.maxDepth) {
            return `[${stringedValue}]`;
        }
        return `${stringedValue + SPACE}{${(0, _collections.printObjectProperties)(val.sample, config, indentation, depth, refs, printer)}}`;
    }
    if (stringedValue === 'StringMatching' || stringedValue === 'StringNotMatching') {
        return stringedValue + SPACE + printer(val.sample, config, indentation, depth, refs);
    }
    if (stringedValue === 'StringContaining' || stringedValue === 'StringNotContaining') {
        return stringedValue + SPACE + printer(val.sample, config, indentation, depth, refs);
    }
    if (typeof val.toAsymmetricMatcher !== 'function') {
        throw new Error(`Asymmetric matcher ${val.constructor.name} does not implement toAsymmetricMatcher()`);
    }
    return val.toAsymmetricMatcher();
};
exports.serialize = serialize;
const test = (val)=>val && val.$$typeof === asymmetricMatcher;
exports.test = test;
const plugin = {
    serialize,
    test
};
var _default = plugin;
exports.default = _default;
}),
"[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/plugins/DOMCollection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.test = exports.serialize = exports.default = void 0;
var _collections = __turbopack_context__.r("[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/collections.js [app-route] (ecmascript)");
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ const SPACE = ' ';
const OBJECT_NAMES = [
    'DOMStringMap',
    'NamedNodeMap'
];
const ARRAY_REGEXP = /^(HTML\w*Collection|NodeList)$/;
const testName = (name)=>OBJECT_NAMES.indexOf(name) !== -1 || ARRAY_REGEXP.test(name);
const test = (val)=>val && val.constructor && !!val.constructor.name && testName(val.constructor.name);
exports.test = test;
const isNamedNodeMap = (collection)=>collection.constructor.name === 'NamedNodeMap';
const serialize = (collection, config, indentation, depth, refs, printer)=>{
    const name = collection.constructor.name;
    if (++depth > config.maxDepth) {
        return `[${name}]`;
    }
    return (config.min ? '' : name + SPACE) + (OBJECT_NAMES.indexOf(name) !== -1 ? `{${(0, _collections.printObjectProperties)(isNamedNodeMap(collection) ? Array.from(collection).reduce((props, attribute)=>{
        props[attribute.name] = attribute.value;
        return props;
    }, {}) : {
        ...collection
    }, config, indentation, depth, refs, printer)}}` : `[${(0, _collections.printListItems)(Array.from(collection), config, indentation, depth, refs, printer)}]`);
};
exports.serialize = serialize;
const plugin = {
    serialize,
    test
};
var _default = plugin;
exports.default = _default;
}),
"[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/plugins/lib/escapeHTML.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.default = escapeHTML;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ function escapeHTML(str) {
    return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
}
}),
"[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/plugins/lib/markup.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.printText = exports.printProps = exports.printElementAsLeaf = exports.printElement = exports.printComment = exports.printChildren = void 0;
var _escapeHTML = _interopRequireDefault(__turbopack_context__.r("[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/plugins/lib/escapeHTML.js [app-route] (ecmascript)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // Return empty string if keys is empty.
const printProps = (keys, props, config, indentation, depth, refs, printer)=>{
    const indentationNext = indentation + config.indent;
    const colors = config.colors;
    return keys.map((key)=>{
        const value = props[key];
        let printed = printer(value, config, indentationNext, depth, refs);
        if (typeof value !== 'string') {
            if (printed.indexOf('\n') !== -1) {
                printed = config.spacingOuter + indentationNext + printed + config.spacingOuter + indentation;
            }
            printed = `{${printed}}`;
        }
        return `${config.spacingInner + indentation + colors.prop.open + key + colors.prop.close}=${colors.value.open}${printed}${colors.value.close}`;
    }).join('');
};
// Return empty string if children is empty.
exports.printProps = printProps;
const printChildren = (children, config, indentation, depth, refs, printer)=>children.map((child)=>config.spacingOuter + indentation + (typeof child === 'string' ? printText(child, config) : printer(child, config, indentation, depth, refs))).join('');
exports.printChildren = printChildren;
const printText = (text, config)=>{
    const contentColor = config.colors.content;
    return contentColor.open + (0, _escapeHTML.default)(text) + contentColor.close;
};
exports.printText = printText;
const printComment = (comment, config)=>{
    const commentColor = config.colors.comment;
    return `${commentColor.open}<!--${(0, _escapeHTML.default)(comment)}-->${commentColor.close}`;
};
// Separate the functions to format props, children, and element,
// so a plugin could override a particular function, if needed.
// Too bad, so sad: the traditional (but unnecessary) space
// in a self-closing tagColor requires a second test of printedProps.
exports.printComment = printComment;
const printElement = (type, printedProps, printedChildren, config, indentation)=>{
    const tagColor = config.colors.tag;
    return `${tagColor.open}<${type}${printedProps && tagColor.close + printedProps + config.spacingOuter + indentation + tagColor.open}${printedChildren ? `>${tagColor.close}${printedChildren}${config.spacingOuter}${indentation}${tagColor.open}</${type}` : `${printedProps && !config.min ? '' : ' '}/`}>${tagColor.close}`;
};
exports.printElement = printElement;
const printElementAsLeaf = (type, config)=>{
    const tagColor = config.colors.tag;
    return `${tagColor.open}<${type}${tagColor.close} ${tagColor.open} />${tagColor.close}`;
};
exports.printElementAsLeaf = printElementAsLeaf;
}),
"[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/plugins/DOMElement.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.test = exports.serialize = exports.default = void 0;
var _markup = __turbopack_context__.r("[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/plugins/lib/markup.js [app-route] (ecmascript)");
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ const ELEMENT_NODE = 1;
const TEXT_NODE = 3;
const COMMENT_NODE = 8;
const FRAGMENT_NODE = 11;
const ELEMENT_REGEXP = /^((HTML|SVG)\w*)?Element$/;
const testHasAttribute = (val)=>{
    try {
        return typeof val.hasAttribute === 'function' && val.hasAttribute('is');
    } catch  {
        return false;
    }
};
const testNode = (val)=>{
    const constructorName = val.constructor.name;
    const { nodeType, tagName } = val;
    const isCustomElement = typeof tagName === 'string' && tagName.includes('-') || testHasAttribute(val);
    return nodeType === ELEMENT_NODE && (ELEMENT_REGEXP.test(constructorName) || isCustomElement) || nodeType === TEXT_NODE && constructorName === 'Text' || nodeType === COMMENT_NODE && constructorName === 'Comment' || nodeType === FRAGMENT_NODE && constructorName === 'DocumentFragment';
};
const test = (val)=>val?.constructor?.name && testNode(val);
exports.test = test;
function nodeIsText(node) {
    return node.nodeType === TEXT_NODE;
}
function nodeIsComment(node) {
    return node.nodeType === COMMENT_NODE;
}
function nodeIsFragment(node) {
    return node.nodeType === FRAGMENT_NODE;
}
const serialize = (node, config, indentation, depth, refs, printer)=>{
    if (nodeIsText(node)) {
        return (0, _markup.printText)(node.data, config);
    }
    if (nodeIsComment(node)) {
        return (0, _markup.printComment)(node.data, config);
    }
    const type = nodeIsFragment(node) ? 'DocumentFragment' : node.tagName.toLowerCase();
    if (++depth > config.maxDepth) {
        return (0, _markup.printElementAsLeaf)(type, config);
    }
    return (0, _markup.printElement)(type, (0, _markup.printProps)(nodeIsFragment(node) ? [] : Array.from(node.attributes, (attr)=>attr.name).sort(), nodeIsFragment(node) ? {} : Array.from(node.attributes).reduce((props, attribute)=>{
        props[attribute.name] = attribute.value;
        return props;
    }, {}), config, indentation + config.indent, depth, refs, printer), (0, _markup.printChildren)(Array.prototype.slice.call(node.childNodes || node.children), config, indentation + config.indent, depth, refs, printer), config, indentation);
};
exports.serialize = serialize;
const plugin = {
    serialize,
    test
};
var _default = plugin;
exports.default = _default;
}),
"[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/plugins/Immutable.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.test = exports.serialize = exports.default = void 0;
var _collections = __turbopack_context__.r("[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/collections.js [app-route] (ecmascript)");
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // SENTINEL constants are from https://github.com/facebook/immutable-js
const IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
const IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';
const IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
const IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';
const IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
const IS_RECORD_SENTINEL = '@@__IMMUTABLE_RECORD__@@'; // immutable v4
const IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';
const IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';
const IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';
const getImmutableName = (name)=>`Immutable.${name}`;
const printAsLeaf = (name)=>`[${name}]`;
const SPACE = ' ';
const LAZY = ''; // Seq is lazy if it calls a method like filter
const printImmutableEntries = (val, config, indentation, depth, refs, printer, type)=>++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}{${(0, _collections.printIteratorEntries)(val.entries(), config, indentation, depth, refs, printer)}}`;
// Record has an entries method because it is a collection in immutable v3.
// Return an iterator for Immutable Record from version v3 or v4.
function getRecordEntries(val) {
    let i = 0;
    return {
        next () {
            if (i < val._keys.length) {
                const key = val._keys[i++];
                return {
                    done: false,
                    value: [
                        key,
                        val.get(key)
                    ]
                };
            }
            return {
                done: true,
                value: undefined
            };
        }
    };
}
const printImmutableRecord = (val, config, indentation, depth, refs, printer)=>{
    // _name property is defined only for an Immutable Record instance
    // which was constructed with a second optional descriptive name arg
    const name = getImmutableName(val._name || 'Record');
    return ++depth > config.maxDepth ? printAsLeaf(name) : `${name + SPACE}{${(0, _collections.printIteratorEntries)(getRecordEntries(val), config, indentation, depth, refs, printer)}}`;
};
const printImmutableSeq = (val, config, indentation, depth, refs, printer)=>{
    const name = getImmutableName('Seq');
    if (++depth > config.maxDepth) {
        return printAsLeaf(name);
    }
    if (val[IS_KEYED_SENTINEL]) {
        return `${name + SPACE}{${// from Immutable collection of entries or from ECMAScript object
        val._iter || val._object ? (0, _collections.printIteratorEntries)(val.entries(), config, indentation, depth, refs, printer) : LAZY}}`;
    }
    return `${name + SPACE}[${val._iter || // from Immutable collection of values
    val._array || // from ECMAScript array
    val._collection || // from ECMAScript collection in immutable v4
    val._iterable // from ECMAScript collection in immutable v3
     ? (0, _collections.printIteratorValues)(val.values(), config, indentation, depth, refs, printer) : LAZY}]`;
};
const printImmutableValues = (val, config, indentation, depth, refs, printer, type)=>++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}[${(0, _collections.printIteratorValues)(val.values(), config, indentation, depth, refs, printer)}]`;
const serialize = (val, config, indentation, depth, refs, printer)=>{
    if (val[IS_MAP_SENTINEL]) {
        return printImmutableEntries(val, config, indentation, depth, refs, printer, val[IS_ORDERED_SENTINEL] ? 'OrderedMap' : 'Map');
    }
    if (val[IS_LIST_SENTINEL]) {
        return printImmutableValues(val, config, indentation, depth, refs, printer, 'List');
    }
    if (val[IS_SET_SENTINEL]) {
        return printImmutableValues(val, config, indentation, depth, refs, printer, val[IS_ORDERED_SENTINEL] ? 'OrderedSet' : 'Set');
    }
    if (val[IS_STACK_SENTINEL]) {
        return printImmutableValues(val, config, indentation, depth, refs, printer, 'Stack');
    }
    if (val[IS_SEQ_SENTINEL]) {
        return printImmutableSeq(val, config, indentation, depth, refs, printer);
    }
    // For compatibility with immutable v3 and v4, let record be the default.
    return printImmutableRecord(val, config, indentation, depth, refs, printer);
};
// Explicitly comparing sentinel properties to true avoids false positive
// when mock identity-obj-proxy returns the key as the value for any key.
exports.serialize = serialize;
const test = (val)=>val && (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true);
exports.test = test;
const plugin = {
    serialize,
    test
};
var _default = plugin;
exports.default = _default;
}),
"[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/plugins/ReactElement.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.test = exports.serialize = exports.default = void 0;
var ReactIs = _interopRequireWildcard(__turbopack_context__.r("[project]/align/node_modules/jest-diff/node_modules/react-is/index.js [app-route] (ecmascript)"));
var _markup = __turbopack_context__.r("[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/plugins/lib/markup.js [app-route] (ecmascript)");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== 'function') return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // Given element.props.children, or subtree during recursive traversal,
// return flattened array of children.
const getChildren = (arg, children = [])=>{
    if (Array.isArray(arg)) {
        arg.forEach((item)=>{
            getChildren(item, children);
        });
    } else if (arg != null && arg !== false) {
        children.push(arg);
    }
    return children;
};
const getType = (element)=>{
    const type = element.type;
    if (typeof type === 'string') {
        return type;
    }
    if (typeof type === 'function') {
        return type.displayName || type.name || 'Unknown';
    }
    if (ReactIs.isFragment(element)) {
        return 'React.Fragment';
    }
    if (ReactIs.isSuspense(element)) {
        return 'React.Suspense';
    }
    if (typeof type === 'object' && type !== null) {
        if (ReactIs.isContextProvider(element)) {
            return 'Context.Provider';
        }
        if (ReactIs.isContextConsumer(element)) {
            return 'Context.Consumer';
        }
        if (ReactIs.isForwardRef(element)) {
            if (type.displayName) {
                return type.displayName;
            }
            const functionName = type.render.displayName || type.render.name || '';
            return functionName !== '' ? `ForwardRef(${functionName})` : 'ForwardRef';
        }
        if (ReactIs.isMemo(element)) {
            const functionName = type.displayName || type.type.displayName || type.type.name || '';
            return functionName !== '' ? `Memo(${functionName})` : 'Memo';
        }
    }
    return 'UNDEFINED';
};
const getPropKeys = (element)=>{
    const { props } = element;
    return Object.keys(props).filter((key)=>key !== 'children' && props[key] !== undefined).sort();
};
const serialize = (element, config, indentation, depth, refs, printer)=>++depth > config.maxDepth ? (0, _markup.printElementAsLeaf)(getType(element), config) : (0, _markup.printElement)(getType(element), (0, _markup.printProps)(getPropKeys(element), element.props, config, indentation + config.indent, depth, refs, printer), (0, _markup.printChildren)(getChildren(element.props.children), config, indentation + config.indent, depth, refs, printer), config, indentation);
exports.serialize = serialize;
const test = (val)=>val != null && ReactIs.isElement(val);
exports.test = test;
const plugin = {
    serialize,
    test
};
var _default = plugin;
exports.default = _default;
}),
"[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/plugins/ReactTestComponent.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.test = exports.serialize = exports.default = void 0;
var _markup = __turbopack_context__.r("[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/plugins/lib/markup.js [app-route] (ecmascript)");
var Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // Child can be `number` in Stack renderer but not in Fiber renderer.
const testSymbol = typeof Symbol === 'function' && Symbol.for ? Symbol.for('react.test.json') : 0xea71357;
const getPropKeys = (object)=>{
    const { props } = object;
    return props ? Object.keys(props).filter((key)=>props[key] !== undefined).sort() : [];
};
const serialize = (object, config, indentation, depth, refs, printer)=>++depth > config.maxDepth ? (0, _markup.printElementAsLeaf)(object.type, config) : (0, _markup.printElement)(object.type, object.props ? (0, _markup.printProps)(getPropKeys(object), object.props, config, indentation + config.indent, depth, refs, printer) : '', object.children ? (0, _markup.printChildren)(object.children, config, indentation + config.indent, depth, refs, printer) : '', config, indentation);
exports.serialize = serialize;
const test = (val)=>val && val.$$typeof === testSymbol;
exports.test = test;
const plugin = {
    serialize,
    test
};
var _default = plugin;
exports.default = _default;
}),
"[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.default = exports.DEFAULT_OPTIONS = void 0;
exports.format = format;
exports.plugins = void 0;
var _ansiStyles = _interopRequireDefault(__turbopack_context__.r("[project]/align/node_modules/jest-diff/node_modules/ansi-styles/index.js [app-route] (ecmascript)"));
var _collections = __turbopack_context__.r("[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/collections.js [app-route] (ecmascript)");
var _AsymmetricMatcher = _interopRequireDefault(__turbopack_context__.r("[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/plugins/AsymmetricMatcher.js [app-route] (ecmascript)"));
var _DOMCollection = _interopRequireDefault(__turbopack_context__.r("[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/plugins/DOMCollection.js [app-route] (ecmascript)"));
var _DOMElement = _interopRequireDefault(__turbopack_context__.r("[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/plugins/DOMElement.js [app-route] (ecmascript)"));
var _Immutable = _interopRequireDefault(__turbopack_context__.r("[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/plugins/Immutable.js [app-route] (ecmascript)"));
var _ReactElement = _interopRequireDefault(__turbopack_context__.r("[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/plugins/ReactElement.js [app-route] (ecmascript)"));
var _ReactTestComponent = _interopRequireDefault(__turbopack_context__.r("[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/plugins/ReactTestComponent.js [app-route] (ecmascript)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ /* eslint-disable local/ban-types-eventually */ const toString = Object.prototype.toString;
const toISOString = Date.prototype.toISOString;
const errorToString = Error.prototype.toString;
const regExpToString = RegExp.prototype.toString;
/**
 * Explicitly comparing typeof constructor to function avoids undefined as name
 * when mock identity-obj-proxy returns the key as the value for any key.
 */ const getConstructorName = (val)=>typeof val.constructor === 'function' && val.constructor.name || 'Object';
/* global window */ /** Is val is equal to global window object? Works even if it does not exist :) */ const isWindow = (val)=>("TURBOPACK compile-time value", "undefined") !== 'undefined' && val === window;
const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
const NEWLINE_REGEXP = /\n/gi;
class PrettyFormatPluginError extends Error {
    constructor(message, stack){
        super(message);
        this.stack = stack;
        this.name = this.constructor.name;
    }
}
function isToStringedArrayType(toStringed) {
    return toStringed === '[object Array]' || toStringed === '[object ArrayBuffer]' || toStringed === '[object DataView]' || toStringed === '[object Float32Array]' || toStringed === '[object Float64Array]' || toStringed === '[object Int8Array]' || toStringed === '[object Int16Array]' || toStringed === '[object Int32Array]' || toStringed === '[object Uint8Array]' || toStringed === '[object Uint8ClampedArray]' || toStringed === '[object Uint16Array]' || toStringed === '[object Uint32Array]';
}
function printNumber(val) {
    return Object.is(val, -0) ? '-0' : String(val);
}
function printBigInt(val) {
    return String(`${val}n`);
}
function printFunction(val, printFunctionName) {
    if (!printFunctionName) {
        return '[Function]';
    }
    return `[Function ${val.name || 'anonymous'}]`;
}
function printSymbol(val) {
    return String(val).replace(SYMBOL_REGEXP, 'Symbol($1)');
}
function printError(val) {
    return `[${errorToString.call(val)}]`;
}
/**
 * The first port of call for printing an object, handles most of the
 * data-types in JS.
 */ function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
    if (val === true || val === false) {
        return `${val}`;
    }
    if (val === undefined) {
        return 'undefined';
    }
    if (val === null) {
        return 'null';
    }
    const typeOf = typeof val;
    if (typeOf === 'number') {
        return printNumber(val);
    }
    if (typeOf === 'bigint') {
        return printBigInt(val);
    }
    if (typeOf === 'string') {
        if (escapeString) {
            return `"${val.replace(/"|\\/g, '\\$&')}"`;
        }
        return `"${val}"`;
    }
    if (typeOf === 'function') {
        return printFunction(val, printFunctionName);
    }
    if (typeOf === 'symbol') {
        return printSymbol(val);
    }
    const toStringed = toString.call(val);
    if (toStringed === '[object WeakMap]') {
        return 'WeakMap {}';
    }
    if (toStringed === '[object WeakSet]') {
        return 'WeakSet {}';
    }
    if (toStringed === '[object Function]' || toStringed === '[object GeneratorFunction]') {
        return printFunction(val, printFunctionName);
    }
    if (toStringed === '[object Symbol]') {
        return printSymbol(val);
    }
    if (toStringed === '[object Date]') {
        return isNaN(+val) ? 'Date { NaN }' : toISOString.call(val);
    }
    if (toStringed === '[object Error]') {
        return printError(val);
    }
    if (toStringed === '[object RegExp]') {
        if (escapeRegex) {
            // https://github.com/benjamingr/RegExp.escape/blob/main/polyfill.js
            return regExpToString.call(val).replace(/[\\^$*+?.()|[\]{}]/g, '\\$&');
        }
        return regExpToString.call(val);
    }
    if (val instanceof Error) {
        return printError(val);
    }
    return null;
}
/**
 * Handles more complex objects ( such as objects with circular references.
 * maps and sets etc )
 */ function printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON) {
    if (refs.indexOf(val) !== -1) {
        return '[Circular]';
    }
    refs = refs.slice();
    refs.push(val);
    const hitMaxDepth = ++depth > config.maxDepth;
    const min = config.min;
    if (config.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON === 'function' && !hasCalledToJSON) {
        return printer(val.toJSON(), config, indentation, depth, refs, true);
    }
    const toStringed = toString.call(val);
    if (toStringed === '[object Arguments]') {
        return hitMaxDepth ? '[Arguments]' : `${min ? '' : 'Arguments '}[${(0, _collections.printListItems)(val, config, indentation, depth, refs, printer)}]`;
    }
    if (isToStringedArrayType(toStringed)) {
        return hitMaxDepth ? `[${val.constructor.name}]` : `${min ? '' : !config.printBasicPrototype && val.constructor.name === 'Array' ? '' : `${val.constructor.name} `}[${(0, _collections.printListItems)(val, config, indentation, depth, refs, printer)}]`;
    }
    if (toStringed === '[object Map]') {
        return hitMaxDepth ? '[Map]' : `Map {${(0, _collections.printIteratorEntries)(val.entries(), config, indentation, depth, refs, printer, ' => ')}}`;
    }
    if (toStringed === '[object Set]') {
        return hitMaxDepth ? '[Set]' : `Set {${(0, _collections.printIteratorValues)(val.values(), config, indentation, depth, refs, printer)}}`;
    }
    // Avoid failure to serialize global window object in jsdom test environment.
    // For example, not even relevant if window is prop of React element.
    return hitMaxDepth || isWindow(val) ? `[${getConstructorName(val)}]` : `${min ? '' : !config.printBasicPrototype && getConstructorName(val) === 'Object' ? '' : `${getConstructorName(val)} `}{${(0, _collections.printObjectProperties)(val, config, indentation, depth, refs, printer)}}`;
}
function isNewPlugin(plugin) {
    return plugin.serialize != null;
}
function printPlugin(plugin, val, config, indentation, depth, refs) {
    let printed;
    try {
        printed = isNewPlugin(plugin) ? plugin.serialize(val, config, indentation, depth, refs, printer) : plugin.print(val, (valChild)=>printer(valChild, config, indentation, depth, refs), (str)=>{
            const indentationNext = indentation + config.indent;
            return indentationNext + str.replace(NEWLINE_REGEXP, `\n${indentationNext}`);
        }, {
            edgeSpacing: config.spacingOuter,
            min: config.min,
            spacing: config.spacingInner
        }, config.colors);
    } catch (error) {
        throw new PrettyFormatPluginError(error.message, error.stack);
    }
    if (typeof printed !== 'string') {
        throw new Error(`pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`);
    }
    return printed;
}
function findPlugin(plugins, val) {
    for(let p = 0; p < plugins.length; p++){
        try {
            if (plugins[p].test(val)) {
                return plugins[p];
            }
        } catch (error) {
            throw new PrettyFormatPluginError(error.message, error.stack);
        }
    }
    return null;
}
function printer(val, config, indentation, depth, refs, hasCalledToJSON) {
    const plugin = findPlugin(config.plugins, val);
    if (plugin !== null) {
        return printPlugin(plugin, val, config, indentation, depth, refs);
    }
    const basicResult = printBasicValue(val, config.printFunctionName, config.escapeRegex, config.escapeString);
    if (basicResult !== null) {
        return basicResult;
    }
    return printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON);
}
const DEFAULT_THEME = {
    comment: 'gray',
    content: 'reset',
    prop: 'yellow',
    tag: 'cyan',
    value: 'green'
};
const DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);
// could be replaced by `satisfies` operator in the future: https://github.com/microsoft/TypeScript/issues/47920
const toOptionsSubtype = (options)=>options;
const DEFAULT_OPTIONS = toOptionsSubtype({
    callToJSON: true,
    compareKeys: undefined,
    escapeRegex: false,
    escapeString: true,
    highlight: false,
    indent: 2,
    maxDepth: Infinity,
    maxWidth: Infinity,
    min: false,
    plugins: [],
    printBasicPrototype: true,
    printFunctionName: true,
    theme: DEFAULT_THEME
});
exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;
function validateOptions(options) {
    Object.keys(options).forEach((key)=>{
        if (!Object.prototype.hasOwnProperty.call(DEFAULT_OPTIONS, key)) {
            throw new Error(`pretty-format: Unknown option "${key}".`);
        }
    });
    if (options.min && options.indent !== undefined && options.indent !== 0) {
        throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
    }
    if (options.theme !== undefined) {
        if (options.theme === null) {
            throw new Error('pretty-format: Option "theme" must not be null.');
        }
        if (typeof options.theme !== 'object') {
            throw new Error(`pretty-format: Option "theme" must be of type "object" but instead received "${typeof options.theme}".`);
        }
    }
}
const getColorsHighlight = (options)=>DEFAULT_THEME_KEYS.reduce((colors, key)=>{
        const value = options.theme && options.theme[key] !== undefined ? options.theme[key] : DEFAULT_THEME[key];
        const color = value && _ansiStyles.default[value];
        if (color && typeof color.close === 'string' && typeof color.open === 'string') {
            colors[key] = color;
        } else {
            throw new Error(`pretty-format: Option "theme" has a key "${key}" whose value "${value}" is undefined in ansi-styles.`);
        }
        return colors;
    }, Object.create(null));
const getColorsEmpty = ()=>DEFAULT_THEME_KEYS.reduce((colors, key)=>{
        colors[key] = {
            close: '',
            open: ''
        };
        return colors;
    }, Object.create(null));
const getPrintFunctionName = (options)=>options?.printFunctionName ?? DEFAULT_OPTIONS.printFunctionName;
const getEscapeRegex = (options)=>options?.escapeRegex ?? DEFAULT_OPTIONS.escapeRegex;
const getEscapeString = (options)=>options?.escapeString ?? DEFAULT_OPTIONS.escapeString;
const getConfig = (options)=>({
        callToJSON: options?.callToJSON ?? DEFAULT_OPTIONS.callToJSON,
        colors: options?.highlight ? getColorsHighlight(options) : getColorsEmpty(),
        compareKeys: typeof options?.compareKeys === 'function' || options?.compareKeys === null ? options.compareKeys : DEFAULT_OPTIONS.compareKeys,
        escapeRegex: getEscapeRegex(options),
        escapeString: getEscapeString(options),
        indent: options?.min ? '' : createIndent(options?.indent ?? DEFAULT_OPTIONS.indent),
        maxDepth: options?.maxDepth ?? DEFAULT_OPTIONS.maxDepth,
        maxWidth: options?.maxWidth ?? DEFAULT_OPTIONS.maxWidth,
        min: options?.min ?? DEFAULT_OPTIONS.min,
        plugins: options?.plugins ?? DEFAULT_OPTIONS.plugins,
        printBasicPrototype: options?.printBasicPrototype ?? true,
        printFunctionName: getPrintFunctionName(options),
        spacingInner: options?.min ? ' ' : '\n',
        spacingOuter: options?.min ? '' : '\n'
    });
function createIndent(indent) {
    return new Array(indent + 1).join(' ');
}
/**
 * Returns a presentation string of your `val` object
 * @param val any potential JavaScript object
 * @param options Custom settings
 */ function format(val, options) {
    if (options) {
        validateOptions(options);
        if (options.plugins) {
            const plugin = findPlugin(options.plugins, val);
            if (plugin !== null) {
                return printPlugin(plugin, val, getConfig(options), '', 0, []);
            }
        }
    }
    const basicResult = printBasicValue(val, getPrintFunctionName(options), getEscapeRegex(options), getEscapeString(options));
    if (basicResult !== null) {
        return basicResult;
    }
    return printComplexValue(val, getConfig(options), '', 0, []);
}
const plugins = {
    AsymmetricMatcher: _AsymmetricMatcher.default,
    DOMCollection: _DOMCollection.default,
    DOMElement: _DOMElement.default,
    Immutable: _Immutable.default,
    ReactElement: _ReactElement.default,
    ReactTestComponent: _ReactTestComponent.default
};
exports.plugins = plugins;
var _default = format;
exports.default = _default;
}),
"[project]/align/node_modules/jest-diff/node_modules/react-is/cjs/react-is.development.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ if ("TURBOPACK compile-time truthy", 1) {
    (function() {
        'use strict';
        // ATTENTION
        // When adding new symbols to this file,
        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
        // The Symbol used to tag the ReactElement-like types.
        var REACT_ELEMENT_TYPE = Symbol.for('react.element');
        var REACT_PORTAL_TYPE = Symbol.for('react.portal');
        var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
        var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
        var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
        var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
        var REACT_CONTEXT_TYPE = Symbol.for('react.context');
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
        var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
        var REACT_MEMO_TYPE = Symbol.for('react.memo');
        var REACT_LAZY_TYPE = Symbol.for('react.lazy');
        var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
        // -----------------------------------------------------------------------------
        var enableScopeAPI = false; // Experimental Create Event Handle API.
        var enableCacheElement = false;
        var enableTransitionTracing = false; // No known bugs, but needs performance testing
        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
        // stuff. Intended to enable React core members to more easily debug scheduling
        // issues in DEV builds.
        var enableDebugTracing = false; // Track which Fiber(s) schedule render work.
        var REACT_MODULE_REFERENCE;
        {
            REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
        }
        function isValidElementType(type) {
            if (typeof type === 'string' || typeof type === 'function') {
                return true;
            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
                return true;
            }
            if (typeof type === 'object' && type !== null) {
                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
                // types supported by any Flight configuration anywhere since
                // we don't know which Flight build this will end up being used
                // with.
                type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
                    return true;
                }
            }
            return false;
        }
        function typeOf(object) {
            if (typeof object === 'object' && object !== null) {
                var $$typeof = object.$$typeof;
                switch($$typeof){
                    case REACT_ELEMENT_TYPE:
                        var type = object.type;
                        switch(type){
                            case REACT_FRAGMENT_TYPE:
                            case REACT_PROFILER_TYPE:
                            case REACT_STRICT_MODE_TYPE:
                            case REACT_SUSPENSE_TYPE:
                            case REACT_SUSPENSE_LIST_TYPE:
                                return type;
                            default:
                                var $$typeofType = type && type.$$typeof;
                                switch($$typeofType){
                                    case REACT_SERVER_CONTEXT_TYPE:
                                    case REACT_CONTEXT_TYPE:
                                    case REACT_FORWARD_REF_TYPE:
                                    case REACT_LAZY_TYPE:
                                    case REACT_MEMO_TYPE:
                                    case REACT_PROVIDER_TYPE:
                                        return $$typeofType;
                                    default:
                                        return $$typeof;
                                }
                        }
                    case REACT_PORTAL_TYPE:
                        return $$typeof;
                }
            }
            return undefined;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated
        function isAsyncMode(object) {
            {
                if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                    hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint
                    console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
                }
            }
            return false;
        }
        function isConcurrentMode(object) {
            {
                if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
                    hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint
                    console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
                }
            }
            return false;
        }
        function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
            return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        function isSuspenseList(object) {
            return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.SuspenseList = SuspenseList;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isSuspenseList = isSuspenseList;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
    })();
}
}),
"[project]/align/node_modules/jest-diff/node_modules/react-is/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/align/node_modules/jest-diff/node_modules/react-is/cjs/react-is.development.js [app-route] (ecmascript)");
}
}),
"[project]/align/node_modules/jest-diff/build/cleanupSemantic.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.cleanupSemantic = exports.Diff = exports.DIFF_INSERT = exports.DIFF_EQUAL = exports.DIFF_DELETE = void 0;
/**
 * Diff Match and Patch
 * Copyright 2018 The diff-match-patch Authors.
 * https://github.com/google/diff-match-patch
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @fileoverview Computes the difference between two texts to create a patch.
 * Applies the patch onto another text, allowing for errors.
 * @author fraser@google.com (Neil Fraser)
 */ /**
 * CHANGES by pedrottimark to diff_match_patch_uncompressed.ts file:
 *
 * 1. Delete anything not needed to use diff_cleanupSemantic method
 * 2. Convert from prototype properties to var declarations
 * 3. Convert Diff to class from constructor and prototype
 * 4. Add type annotations for arguments and return values
 * 5. Add exports
 */ /**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */ var DIFF_DELETE = -1;
exports.DIFF_DELETE = DIFF_DELETE;
var DIFF_INSERT = 1;
exports.DIFF_INSERT = DIFF_INSERT;
var DIFF_EQUAL = 0;
/**
 * Class representing one diff tuple.
 * Attempts to look like a two-element array (which is what this used to be).
 * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.
 * @param {string} text Text to be deleted, inserted, or retained.
 * @constructor
 */ exports.DIFF_EQUAL = DIFF_EQUAL;
class Diff {
    0;
    1;
    constructor(op, text){
        this[0] = op;
        this[1] = text;
    }
}
/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */ exports.Diff = Diff;
var diff_commonPrefix = function(text1, text2) {
    // Quick check for common null cases.
    if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
        return 0;
    }
    // Binary search.
    // Performance analysis: https://neil.fraser.name/news/2007/10/09/
    var pointermin = 0;
    var pointermax = Math.min(text1.length, text2.length);
    var pointermid = pointermax;
    var pointerstart = 0;
    while(pointermin < pointermid){
        if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
            pointermin = pointermid;
            pointerstart = pointermin;
        } else {
            pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }
    return pointermid;
};
/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */ var diff_commonSuffix = function(text1, text2) {
    // Quick check for common null cases.
    if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
        return 0;
    }
    // Binary search.
    // Performance analysis: https://neil.fraser.name/news/2007/10/09/
    var pointermin = 0;
    var pointermax = Math.min(text1.length, text2.length);
    var pointermid = pointermax;
    var pointerend = 0;
    while(pointermin < pointermid){
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
            pointermin = pointermid;
            pointerend = pointermin;
        } else {
            pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }
    return pointermid;
};
/**
 * Determine if the suffix of one string is the prefix of another.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of the first
 *     string and the start of the second string.
 * @private
 */ var diff_commonOverlap_ = function(text1, text2) {
    // Cache the text lengths to prevent multiple calls.
    var text1_length = text1.length;
    var text2_length = text2.length;
    // Eliminate the null case.
    if (text1_length == 0 || text2_length == 0) {
        return 0;
    }
    // Truncate the longer string.
    if (text1_length > text2_length) {
        text1 = text1.substring(text1_length - text2_length);
    } else if (text1_length < text2_length) {
        text2 = text2.substring(0, text1_length);
    }
    var text_length = Math.min(text1_length, text2_length);
    // Quick check for the worst case.
    if (text1 == text2) {
        return text_length;
    }
    // Start by looking for a single character match
    // and increase length until no match is found.
    // Performance analysis: https://neil.fraser.name/news/2010/11/04/
    var best = 0;
    var length = 1;
    while(true){
        var pattern = text1.substring(text_length - length);
        var found = text2.indexOf(pattern);
        if (found == -1) {
            return best;
        }
        length += found;
        if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {
            best = length;
            length++;
        }
    }
};
/**
 * Reduce the number of edits by eliminating semantically trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */ var diff_cleanupSemantic = function(diffs) {
    var changes = false;
    var equalities = []; // Stack of indices where equalities are found.
    var equalitiesLength = 0; // Keeping our own length var is faster in JS.
    /** @type {?string} */ var lastEquality = null;
    // Always equal to diffs[equalities[equalitiesLength - 1]][1]
    var pointer = 0; // Index of current position.
    // Number of characters that changed prior to the equality.
    var length_insertions1 = 0;
    var length_deletions1 = 0;
    // Number of characters that changed after the equality.
    var length_insertions2 = 0;
    var length_deletions2 = 0;
    while(pointer < diffs.length){
        if (diffs[pointer][0] == DIFF_EQUAL) {
            // Equality found.
            equalities[equalitiesLength++] = pointer;
            length_insertions1 = length_insertions2;
            length_deletions1 = length_deletions2;
            length_insertions2 = 0;
            length_deletions2 = 0;
            lastEquality = diffs[pointer][1];
        } else {
            // An insertion or deletion.
            if (diffs[pointer][0] == DIFF_INSERT) {
                length_insertions2 += diffs[pointer][1].length;
            } else {
                length_deletions2 += diffs[pointer][1].length;
            }
            // Eliminate an equality that is smaller or equal to the edits on both
            // sides of it.
            if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {
                // Duplicate record.
                diffs.splice(equalities[equalitiesLength - 1], 0, new Diff(DIFF_DELETE, lastEquality));
                // Change second copy to insert.
                diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
                // Throw away the equality we just deleted.
                equalitiesLength--;
                // Throw away the previous equality (it needs to be reevaluated).
                equalitiesLength--;
                pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
                length_insertions1 = 0; // Reset the counters.
                length_deletions1 = 0;
                length_insertions2 = 0;
                length_deletions2 = 0;
                lastEquality = null;
                changes = true;
            }
        }
        pointer++;
    }
    // Normalize the diff.
    if (changes) {
        diff_cleanupMerge(diffs);
    }
    diff_cleanupSemanticLossless(diffs);
    // Find any overlaps between deletions and insertions.
    // e.g: <del>abcxxx</del><ins>xxxdef</ins>
    //   -> <del>abc</del>xxx<ins>def</ins>
    // e.g: <del>xxxabc</del><ins>defxxx</ins>
    //   -> <ins>def</ins>xxx<del>abc</del>
    // Only extract an overlap if it is as big as the edit ahead or behind it.
    pointer = 1;
    while(pointer < diffs.length){
        if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
            var deletion = diffs[pointer - 1][1];
            var insertion = diffs[pointer][1];
            var overlap_length1 = diff_commonOverlap_(deletion, insertion);
            var overlap_length2 = diff_commonOverlap_(insertion, deletion);
            if (overlap_length1 >= overlap_length2) {
                if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
                    // Overlap found.  Insert an equality and trim the surrounding edits.
                    diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));
                    diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
                    diffs[pointer + 1][1] = insertion.substring(overlap_length1);
                    pointer++;
                }
            } else {
                if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
                    // Reverse overlap found.
                    // Insert an equality and swap and trim the surrounding edits.
                    diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));
                    diffs[pointer - 1][0] = DIFF_INSERT;
                    diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
                    diffs[pointer + 1][0] = DIFF_DELETE;
                    diffs[pointer + 1][1] = deletion.substring(overlap_length2);
                    pointer++;
                }
            }
            pointer++;
        }
        pointer++;
    }
};
/**
 * Look for single edits surrounded on both sides by equalities
 * which can be shifted sideways to align the edit to a word boundary.
 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */ exports.cleanupSemantic = diff_cleanupSemantic;
var diff_cleanupSemanticLossless = function(diffs) {
    /**
   * Given two strings, compute a score representing whether the internal
   * boundary falls on logical boundaries.
   * Scores range from 6 (best) to 0 (worst).
   * Closure, but does not reference any external variables.
   * @param {string} one First string.
   * @param {string} two Second string.
   * @return {number} The score.
   * @private
   */ function diff_cleanupSemanticScore_(one, two) {
        if (!one || !two) {
            // Edges are the best.
            return 6;
        }
        // Each port of this function behaves slightly differently due to
        // subtle differences in each language's definition of things like
        // 'whitespace'.  Since this function's purpose is largely cosmetic,
        // the choice has been made to use each language's native features
        // rather than force total conformity.
        var char1 = one.charAt(one.length - 1);
        var char2 = two.charAt(0);
        var nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);
        var nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);
        var whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);
        var whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);
        var lineBreak1 = whitespace1 && char1.match(linebreakRegex_);
        var lineBreak2 = whitespace2 && char2.match(linebreakRegex_);
        var blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);
        var blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
        if (blankLine1 || blankLine2) {
            // Five points for blank lines.
            return 5;
        } else if (lineBreak1 || lineBreak2) {
            // Four points for line breaks.
            return 4;
        } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
            // Three points for end of sentences.
            return 3;
        } else if (whitespace1 || whitespace2) {
            // Two points for whitespace.
            return 2;
        } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
            // One point for non-alphanumeric.
            return 1;
        }
        return 0;
    }
    var pointer = 1;
    // Intentionally ignore the first and last element (don't need checking).
    while(pointer < diffs.length - 1){
        if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
            // This is a single edit surrounded by equalities.
            var equality1 = diffs[pointer - 1][1];
            var edit = diffs[pointer][1];
            var equality2 = diffs[pointer + 1][1];
            // First, shift the edit as far left as possible.
            var commonOffset = diff_commonSuffix(equality1, edit);
            if (commonOffset) {
                var commonString = edit.substring(edit.length - commonOffset);
                equality1 = equality1.substring(0, equality1.length - commonOffset);
                edit = commonString + edit.substring(0, edit.length - commonOffset);
                equality2 = commonString + equality2;
            }
            // Second, step character by character right, looking for the best fit.
            var bestEquality1 = equality1;
            var bestEdit = edit;
            var bestEquality2 = equality2;
            var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
            while(edit.charAt(0) === equality2.charAt(0)){
                equality1 += edit.charAt(0);
                edit = edit.substring(1) + equality2.charAt(0);
                equality2 = equality2.substring(1);
                var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
                // The >= encourages trailing rather than leading whitespace on edits.
                if (score >= bestScore) {
                    bestScore = score;
                    bestEquality1 = equality1;
                    bestEdit = edit;
                    bestEquality2 = equality2;
                }
            }
            if (diffs[pointer - 1][1] != bestEquality1) {
                // We have an improvement, save it back to the diff.
                if (bestEquality1) {
                    diffs[pointer - 1][1] = bestEquality1;
                } else {
                    diffs.splice(pointer - 1, 1);
                    pointer--;
                }
                diffs[pointer][1] = bestEdit;
                if (bestEquality2) {
                    diffs[pointer + 1][1] = bestEquality2;
                } else {
                    diffs.splice(pointer + 1, 1);
                    pointer--;
                }
            }
        }
        pointer++;
    }
};
// Define some regex patterns for matching boundaries.
var nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
var whitespaceRegex_ = /\s/;
var linebreakRegex_ = /[\r\n]/;
var blanklineEndRegex_ = /\n\r?\n$/;
var blanklineStartRegex_ = /^\r?\n\r?\n/;
/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */ var diff_cleanupMerge = function(diffs) {
    // Add a dummy entry at the end.
    diffs.push(new Diff(DIFF_EQUAL, ''));
    var pointer = 0;
    var count_delete = 0;
    var count_insert = 0;
    var text_delete = '';
    var text_insert = '';
    var commonlength;
    while(pointer < diffs.length){
        switch(diffs[pointer][0]){
            case DIFF_INSERT:
                count_insert++;
                text_insert += diffs[pointer][1];
                pointer++;
                break;
            case DIFF_DELETE:
                count_delete++;
                text_delete += diffs[pointer][1];
                pointer++;
                break;
            case DIFF_EQUAL:
                // Upon reaching an equality, check for prior redundancies.
                if (count_delete + count_insert > 1) {
                    if (count_delete !== 0 && count_insert !== 0) {
                        // Factor out any common prefixies.
                        commonlength = diff_commonPrefix(text_insert, text_delete);
                        if (commonlength !== 0) {
                            if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                                diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                            } else {
                                diffs.splice(0, 0, new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength)));
                                pointer++;
                            }
                            text_insert = text_insert.substring(commonlength);
                            text_delete = text_delete.substring(commonlength);
                        }
                        // Factor out any common suffixies.
                        commonlength = diff_commonSuffix(text_insert, text_delete);
                        if (commonlength !== 0) {
                            diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                            text_insert = text_insert.substring(0, text_insert.length - commonlength);
                            text_delete = text_delete.substring(0, text_delete.length - commonlength);
                        }
                    }
                    // Delete the offending records and add the merged ones.
                    pointer -= count_delete + count_insert;
                    diffs.splice(pointer, count_delete + count_insert);
                    if (text_delete.length) {
                        diffs.splice(pointer, 0, new Diff(DIFF_DELETE, text_delete));
                        pointer++;
                    }
                    if (text_insert.length) {
                        diffs.splice(pointer, 0, new Diff(DIFF_INSERT, text_insert));
                        pointer++;
                    }
                    pointer++;
                } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
                    // Merge this equality with the previous one.
                    diffs[pointer - 1][1] += diffs[pointer][1];
                    diffs.splice(pointer, 1);
                } else {
                    pointer++;
                }
                count_insert = 0;
                count_delete = 0;
                text_delete = '';
                text_insert = '';
                break;
        }
    }
    if (diffs[diffs.length - 1][1] === '') {
        diffs.pop(); // Remove the dummy entry at the end.
    }
    // Second pass: look for single edits surrounded on both sides by equalities
    // which can be shifted sideways to eliminate an equality.
    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
    var changes = false;
    pointer = 1;
    // Intentionally ignore the first and last element (don't need checking).
    while(pointer < diffs.length - 1){
        if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
            // This is a single edit surrounded by equalities.
            if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
                // Shift the edit over the previous equality.
                diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
                diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
                diffs.splice(pointer - 1, 1);
                changes = true;
            } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
                // Shift the edit over the next equality.
                diffs[pointer - 1][1] += diffs[pointer + 1][1];
                diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
                diffs.splice(pointer + 1, 1);
                changes = true;
            }
        }
        pointer++;
    }
    // If shifts were made, the diff needs reordering and another shift sweep.
    if (changes) {
        diff_cleanupMerge(diffs);
    }
};
}),
"[project]/align/node_modules/jest-diff/build/constants.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.SIMILAR_MESSAGE = exports.NO_DIFF_MESSAGE = void 0;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ const NO_DIFF_MESSAGE = 'Compared values have no visual difference.';
exports.NO_DIFF_MESSAGE = NO_DIFF_MESSAGE;
const SIMILAR_MESSAGE = 'Compared values serialize to the same structure.\n' + 'Printing internal object structure without calling `toJSON` instead.';
exports.SIMILAR_MESSAGE = SIMILAR_MESSAGE;
}),
"[project]/align/node_modules/jest-diff/build/joinAlignedDiffs.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.joinAlignedDiffsNoExpand = exports.joinAlignedDiffsExpand = void 0;
var _cleanupSemantic = __turbopack_context__.r("[project]/align/node_modules/jest-diff/build/cleanupSemantic.js [app-route] (ecmascript)");
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ const formatTrailingSpaces = (line, trailingSpaceFormatter)=>line.replace(/\s+$/, (match)=>trailingSpaceFormatter(match));
const printDiffLine = (line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder)=>line.length !== 0 ? color(`${indicator} ${formatTrailingSpaces(line, trailingSpaceFormatter)}`) : indicator !== ' ' ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color(`${indicator} ${emptyFirstOrLastLinePlaceholder}`) : '';
const printDeleteLine = (line, isFirstOrLast, { aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder })=>printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
const printInsertLine = (line, isFirstOrLast, { bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder })=>printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
const printCommonLine = (line, isFirstOrLast, { commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder })=>printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
// In GNU diff format, indexes are one-based instead of zero-based.
const createPatchMark = (aStart, aEnd, bStart, bEnd, { patchColor })=>patchColor(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`);
// jest --no-expand
//
// Given array of aligned strings with inverse highlight formatting,
// return joined lines with diff formatting (and patch marks, if needed).
const joinAlignedDiffsNoExpand = (diffs, options)=>{
    const iLength = diffs.length;
    const nContextLines = options.contextLines;
    const nContextLines2 = nContextLines + nContextLines;
    // First pass: count output lines and see if it has patches.
    let jLength = iLength;
    let hasExcessAtStartOrEnd = false;
    let nExcessesBetweenChanges = 0;
    let i = 0;
    while(i !== iLength){
        const iStart = i;
        while(i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_EQUAL){
            i += 1;
        }
        if (iStart !== i) {
            if (iStart === 0) {
                // at start
                if (i > nContextLines) {
                    jLength -= i - nContextLines; // subtract excess common lines
                    hasExcessAtStartOrEnd = true;
                }
            } else if (i === iLength) {
                // at end
                const n = i - iStart;
                if (n > nContextLines) {
                    jLength -= n - nContextLines; // subtract excess common lines
                    hasExcessAtStartOrEnd = true;
                }
            } else {
                // between changes
                const n = i - iStart;
                if (n > nContextLines2) {
                    jLength -= n - nContextLines2; // subtract excess common lines
                    nExcessesBetweenChanges += 1;
                }
            }
        }
        while(i !== iLength && diffs[i][0] !== _cleanupSemantic.DIFF_EQUAL){
            i += 1;
        }
    }
    const hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;
    if (nExcessesBetweenChanges !== 0) {
        jLength += nExcessesBetweenChanges + 1; // add patch lines
    } else if (hasExcessAtStartOrEnd) {
        jLength += 1; // add patch line
    }
    const jLast = jLength - 1;
    const lines = [];
    let jPatchMark = 0; // index of placeholder line for current patch mark
    if (hasPatch) {
        lines.push(''); // placeholder line for first patch mark
    }
    // Indexes of expected or received lines in current patch:
    let aStart = 0;
    let bStart = 0;
    let aEnd = 0;
    let bEnd = 0;
    const pushCommonLine = (line)=>{
        const j = lines.length;
        lines.push(printCommonLine(line, j === 0 || j === jLast, options));
        aEnd += 1;
        bEnd += 1;
    };
    const pushDeleteLine = (line)=>{
        const j = lines.length;
        lines.push(printDeleteLine(line, j === 0 || j === jLast, options));
        aEnd += 1;
    };
    const pushInsertLine = (line)=>{
        const j = lines.length;
        lines.push(printInsertLine(line, j === 0 || j === jLast, options));
        bEnd += 1;
    };
    // Second pass: push lines with diff formatting (and patch marks, if needed).
    i = 0;
    while(i !== iLength){
        let iStart = i;
        while(i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_EQUAL){
            i += 1;
        }
        if (iStart !== i) {
            if (iStart === 0) {
                // at beginning
                if (i > nContextLines) {
                    iStart = i - nContextLines;
                    aStart = iStart;
                    bStart = iStart;
                    aEnd = aStart;
                    bEnd = bStart;
                }
                for(let iCommon = iStart; iCommon !== i; iCommon += 1){
                    pushCommonLine(diffs[iCommon][1]);
                }
            } else if (i === iLength) {
                // at end
                const iEnd = i - iStart > nContextLines ? iStart + nContextLines : i;
                for(let iCommon = iStart; iCommon !== iEnd; iCommon += 1){
                    pushCommonLine(diffs[iCommon][1]);
                }
            } else {
                // between changes
                const nCommon = i - iStart;
                if (nCommon > nContextLines2) {
                    const iEnd = iStart + nContextLines;
                    for(let iCommon = iStart; iCommon !== iEnd; iCommon += 1){
                        pushCommonLine(diffs[iCommon][1]);
                    }
                    lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);
                    jPatchMark = lines.length;
                    lines.push(''); // placeholder line for next patch mark
                    const nOmit = nCommon - nContextLines2;
                    aStart = aEnd + nOmit;
                    bStart = bEnd + nOmit;
                    aEnd = aStart;
                    bEnd = bStart;
                    for(let iCommon = i - nContextLines; iCommon !== i; iCommon += 1){
                        pushCommonLine(diffs[iCommon][1]);
                    }
                } else {
                    for(let iCommon = iStart; iCommon !== i; iCommon += 1){
                        pushCommonLine(diffs[iCommon][1]);
                    }
                }
            }
        }
        while(i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_DELETE){
            pushDeleteLine(diffs[i][1]);
            i += 1;
        }
        while(i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_INSERT){
            pushInsertLine(diffs[i][1]);
            i += 1;
        }
    }
    if (hasPatch) {
        lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);
    }
    return lines.join('\n');
};
// jest --expand
//
// Given array of aligned strings with inverse highlight formatting,
// return joined lines with diff formatting.
exports.joinAlignedDiffsNoExpand = joinAlignedDiffsNoExpand;
const joinAlignedDiffsExpand = (diffs, options)=>diffs.map((diff, i, diffs)=>{
        const line = diff[1];
        const isFirstOrLast = i === 0 || i === diffs.length - 1;
        switch(diff[0]){
            case _cleanupSemantic.DIFF_DELETE:
                return printDeleteLine(line, isFirstOrLast, options);
            case _cleanupSemantic.DIFF_INSERT:
                return printInsertLine(line, isFirstOrLast, options);
            default:
                return printCommonLine(line, isFirstOrLast, options);
        }
    }).join('\n');
exports.joinAlignedDiffsExpand = joinAlignedDiffsExpand;
}),
"[project]/align/node_modules/jest-diff/build/normalizeDiffOptions.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.normalizeDiffOptions = exports.noColor = void 0;
var _chalk = _interopRequireDefault(__turbopack_context__.r("[project]/align/node_modules/chalk/source/index.js [app-route] (ecmascript)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ const noColor = (string)=>string;
exports.noColor = noColor;
const DIFF_CONTEXT_DEFAULT = 5;
const OPTIONS_DEFAULT = {
    aAnnotation: 'Expected',
    aColor: _chalk.default.green,
    aIndicator: '-',
    bAnnotation: 'Received',
    bColor: _chalk.default.red,
    bIndicator: '+',
    changeColor: _chalk.default.inverse,
    changeLineTrailingSpaceColor: noColor,
    commonColor: _chalk.default.dim,
    commonIndicator: ' ',
    commonLineTrailingSpaceColor: noColor,
    compareKeys: undefined,
    contextLines: DIFF_CONTEXT_DEFAULT,
    emptyFirstOrLastLinePlaceholder: '',
    expand: true,
    includeChangeCounts: false,
    omitAnnotationLines: false,
    patchColor: _chalk.default.yellow
};
const getCompareKeys = (compareKeys)=>compareKeys && typeof compareKeys === 'function' ? compareKeys : OPTIONS_DEFAULT.compareKeys;
const getContextLines = (contextLines)=>typeof contextLines === 'number' && Number.isSafeInteger(contextLines) && contextLines >= 0 ? contextLines : DIFF_CONTEXT_DEFAULT;
// Pure function returns options with all properties.
const normalizeDiffOptions = (options = {})=>({
        ...OPTIONS_DEFAULT,
        ...options,
        compareKeys: getCompareKeys(options.compareKeys),
        contextLines: getContextLines(options.contextLines)
    });
exports.normalizeDiffOptions = normalizeDiffOptions;
}),
"[project]/align/node_modules/jest-diff/build/diffLines.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.printDiffLines = exports.diffLinesUnified2 = exports.diffLinesUnified = exports.diffLinesRaw = void 0;
var _diffSequences = _interopRequireDefault(__turbopack_context__.r("[project]/align/node_modules/diff-sequences/build/index.js [app-route] (ecmascript)"));
var _cleanupSemantic = __turbopack_context__.r("[project]/align/node_modules/jest-diff/build/cleanupSemantic.js [app-route] (ecmascript)");
var _joinAlignedDiffs = __turbopack_context__.r("[project]/align/node_modules/jest-diff/build/joinAlignedDiffs.js [app-route] (ecmascript)");
var _normalizeDiffOptions = __turbopack_context__.r("[project]/align/node_modules/jest-diff/build/normalizeDiffOptions.js [app-route] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ const isEmptyString = (lines)=>lines.length === 1 && lines[0].length === 0;
const countChanges = (diffs)=>{
    let a = 0;
    let b = 0;
    diffs.forEach((diff)=>{
        switch(diff[0]){
            case _cleanupSemantic.DIFF_DELETE:
                a += 1;
                break;
            case _cleanupSemantic.DIFF_INSERT:
                b += 1;
                break;
        }
    });
    return {
        a,
        b
    };
};
const printAnnotation = ({ aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator, includeChangeCounts, omitAnnotationLines }, changeCounts)=>{
    if (omitAnnotationLines) {
        return '';
    }
    let aRest = '';
    let bRest = '';
    if (includeChangeCounts) {
        const aCount = String(changeCounts.a);
        const bCount = String(changeCounts.b);
        // Padding right aligns the ends of the annotations.
        const baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length;
        const aAnnotationPadding = ' '.repeat(Math.max(0, baAnnotationLengthDiff));
        const bAnnotationPadding = ' '.repeat(Math.max(0, -baAnnotationLengthDiff));
        // Padding left aligns the ends of the counts.
        const baCountLengthDiff = bCount.length - aCount.length;
        const aCountPadding = ' '.repeat(Math.max(0, baCountLengthDiff));
        const bCountPadding = ' '.repeat(Math.max(0, -baCountLengthDiff));
        aRest = `${aAnnotationPadding}  ${aIndicator} ${aCountPadding}${aCount}`;
        bRest = `${bAnnotationPadding}  ${bIndicator} ${bCountPadding}${bCount}`;
    }
    const a = `${aIndicator} ${aAnnotation}${aRest}`;
    const b = `${bIndicator} ${bAnnotation}${bRest}`;
    return `${aColor(a)}\n${bColor(b)}\n\n`;
};
const printDiffLines = (diffs, options)=>printAnnotation(options, countChanges(diffs)) + (options.expand ? (0, _joinAlignedDiffs.joinAlignedDiffsExpand)(diffs, options) : (0, _joinAlignedDiffs.joinAlignedDiffsNoExpand)(diffs, options));
// Compare two arrays of strings line-by-line. Format as comparison lines.
exports.printDiffLines = printDiffLines;
const diffLinesUnified = (aLines, bLines, options)=>printDiffLines(diffLinesRaw(isEmptyString(aLines) ? [] : aLines, isEmptyString(bLines) ? [] : bLines), (0, _normalizeDiffOptions.normalizeDiffOptions)(options));
// Given two pairs of arrays of strings:
// Compare the pair of comparison arrays line-by-line.
// Format the corresponding lines in the pair of displayable arrays.
exports.diffLinesUnified = diffLinesUnified;
const diffLinesUnified2 = (aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options)=>{
    if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare)) {
        aLinesDisplay = [];
        aLinesCompare = [];
    }
    if (isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare)) {
        bLinesDisplay = [];
        bLinesCompare = [];
    }
    if (aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length) {
        // Fall back to diff of display lines.
        return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);
    }
    const diffs = diffLinesRaw(aLinesCompare, bLinesCompare);
    // Replace comparison lines with displayable lines.
    let aIndex = 0;
    let bIndex = 0;
    diffs.forEach((diff)=>{
        switch(diff[0]){
            case _cleanupSemantic.DIFF_DELETE:
                diff[1] = aLinesDisplay[aIndex];
                aIndex += 1;
                break;
            case _cleanupSemantic.DIFF_INSERT:
                diff[1] = bLinesDisplay[bIndex];
                bIndex += 1;
                break;
            default:
                diff[1] = bLinesDisplay[bIndex];
                aIndex += 1;
                bIndex += 1;
        }
    });
    return printDiffLines(diffs, (0, _normalizeDiffOptions.normalizeDiffOptions)(options));
};
// Compare two arrays of strings line-by-line.
exports.diffLinesUnified2 = diffLinesUnified2;
const diffLinesRaw = (aLines, bLines)=>{
    const aLength = aLines.length;
    const bLength = bLines.length;
    const isCommon = (aIndex, bIndex)=>aLines[aIndex] === bLines[bIndex];
    const diffs = [];
    let aIndex = 0;
    let bIndex = 0;
    const foundSubsequence = (nCommon, aCommon, bCommon)=>{
        for(; aIndex !== aCommon; aIndex += 1){
            diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_DELETE, aLines[aIndex]));
        }
        for(; bIndex !== bCommon; bIndex += 1){
            diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_INSERT, bLines[bIndex]));
        }
        for(; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1){
            diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_EQUAL, bLines[bIndex]));
        }
    };
    (0, _diffSequences.default)(aLength, bLength, isCommon, foundSubsequence);
    // After the last common subsequence, push remaining change items.
    for(; aIndex !== aLength; aIndex += 1){
        diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_DELETE, aLines[aIndex]));
    }
    for(; bIndex !== bLength; bIndex += 1){
        diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_INSERT, bLines[bIndex]));
    }
    return diffs;
};
exports.diffLinesRaw = diffLinesRaw;
}),
"[project]/align/node_modules/jest-diff/build/diffStrings.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.default = void 0;
var _diffSequences = _interopRequireDefault(__turbopack_context__.r("[project]/align/node_modules/diff-sequences/build/index.js [app-route] (ecmascript)"));
var _cleanupSemantic = __turbopack_context__.r("[project]/align/node_modules/jest-diff/build/cleanupSemantic.js [app-route] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ const diffStrings = (a, b)=>{
    const isCommon = (aIndex, bIndex)=>a[aIndex] === b[bIndex];
    let aIndex = 0;
    let bIndex = 0;
    const diffs = [];
    const foundSubsequence = (nCommon, aCommon, bCommon)=>{
        if (aIndex !== aCommon) {
            diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_DELETE, a.slice(aIndex, aCommon)));
        }
        if (bIndex !== bCommon) {
            diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_INSERT, b.slice(bIndex, bCommon)));
        }
        aIndex = aCommon + nCommon; // number of characters compared in a
        bIndex = bCommon + nCommon; // number of characters compared in b
        diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_EQUAL, b.slice(bCommon, bIndex)));
    };
    (0, _diffSequences.default)(a.length, b.length, isCommon, foundSubsequence);
    // After the last common subsequence, push remaining change items.
    if (aIndex !== a.length) {
        diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_DELETE, a.slice(aIndex)));
    }
    if (bIndex !== b.length) {
        diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_INSERT, b.slice(bIndex)));
    }
    return diffs;
};
var _default = diffStrings;
exports.default = _default;
}),
"[project]/align/node_modules/jest-diff/build/getAlignedDiffs.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.default = void 0;
var _cleanupSemantic = __turbopack_context__.r("[project]/align/node_modules/jest-diff/build/cleanupSemantic.js [app-route] (ecmascript)");
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // Given change op and array of diffs, return concatenated string:
// * include common strings
// * include change strings which have argument op with changeColor
// * exclude change strings which have opposite op
const concatenateRelevantDiffs = (op, diffs, changeColor)=>diffs.reduce((reduced, diff)=>reduced + (diff[0] === _cleanupSemantic.DIFF_EQUAL ? diff[1] : diff[0] === op && diff[1].length !== 0 // empty if change is newline
         ? changeColor(diff[1]) : ''), '');
// Encapsulate change lines until either a common newline or the end.
class ChangeBuffer {
    op;
    line;
    lines;
    changeColor;
    constructor(op, changeColor){
        this.op = op;
        this.line = [];
        this.lines = [];
        this.changeColor = changeColor;
    }
    pushSubstring(substring) {
        this.pushDiff(new _cleanupSemantic.Diff(this.op, substring));
    }
    pushLine() {
        // Assume call only if line has at least one diff,
        // therefore an empty line must have a diff which has an empty string.
        // If line has multiple diffs, then assume it has a common diff,
        // therefore change diffs have change color;
        // otherwise then it has line color only.
        this.lines.push(this.line.length !== 1 ? new _cleanupSemantic.Diff(this.op, concatenateRelevantDiffs(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] // can use instance
         : new _cleanupSemantic.Diff(this.op, this.line[0][1]) // was common diff
        );
        this.line.length = 0;
    }
    isLineEmpty() {
        return this.line.length === 0;
    }
    // Minor input to buffer.
    pushDiff(diff) {
        this.line.push(diff);
    }
    // Main input to buffer.
    align(diff) {
        const string = diff[1];
        if (string.includes('\n')) {
            const substrings = string.split('\n');
            const iLast = substrings.length - 1;
            substrings.forEach((substring, i)=>{
                if (i < iLast) {
                    // The first substring completes the current change line.
                    // A middle substring is a change line.
                    this.pushSubstring(substring);
                    this.pushLine();
                } else if (substring.length !== 0) {
                    // The last substring starts a change line, if it is not empty.
                    // Important: This non-empty condition also automatically omits
                    // the newline appended to the end of expected and received strings.
                    this.pushSubstring(substring);
                }
            });
        } else {
            // Append non-multiline string to current change line.
            this.pushDiff(diff);
        }
    }
    // Output from buffer.
    moveLinesTo(lines) {
        if (!this.isLineEmpty()) {
            this.pushLine();
        }
        lines.push(...this.lines);
        this.lines.length = 0;
    }
}
// Encapsulate common and change lines.
class CommonBuffer {
    deleteBuffer;
    insertBuffer;
    lines;
    constructor(deleteBuffer, insertBuffer){
        this.deleteBuffer = deleteBuffer;
        this.insertBuffer = insertBuffer;
        this.lines = [];
    }
    pushDiffCommonLine(diff) {
        this.lines.push(diff);
    }
    pushDiffChangeLines(diff) {
        const isDiffEmpty = diff[1].length === 0;
        // An empty diff string is redundant, unless a change line is empty.
        if (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) {
            this.deleteBuffer.pushDiff(diff);
        }
        if (!isDiffEmpty || this.insertBuffer.isLineEmpty()) {
            this.insertBuffer.pushDiff(diff);
        }
    }
    flushChangeLines() {
        this.deleteBuffer.moveLinesTo(this.lines);
        this.insertBuffer.moveLinesTo(this.lines);
    }
    // Input to buffer.
    align(diff) {
        const op = diff[0];
        const string = diff[1];
        if (string.includes('\n')) {
            const substrings = string.split('\n');
            const iLast = substrings.length - 1;
            substrings.forEach((substring, i)=>{
                if (i === 0) {
                    const subdiff = new _cleanupSemantic.Diff(op, substring);
                    if (this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty()) {
                        // If both current change lines are empty,
                        // then the first substring is a common line.
                        this.flushChangeLines();
                        this.pushDiffCommonLine(subdiff);
                    } else {
                        // If either current change line is non-empty,
                        // then the first substring completes the change lines.
                        this.pushDiffChangeLines(subdiff);
                        this.flushChangeLines();
                    }
                } else if (i < iLast) {
                    // A middle substring is a common line.
                    this.pushDiffCommonLine(new _cleanupSemantic.Diff(op, substring));
                } else if (substring.length !== 0) {
                    // The last substring starts a change line, if it is not empty.
                    // Important: This non-empty condition also automatically omits
                    // the newline appended to the end of expected and received strings.
                    this.pushDiffChangeLines(new _cleanupSemantic.Diff(op, substring));
                }
            });
        } else {
            // Append non-multiline string to current change lines.
            // Important: It cannot be at the end following empty change lines,
            // because newline appended to the end of expected and received strings.
            this.pushDiffChangeLines(diff);
        }
    }
    // Output from buffer.
    getLines() {
        this.flushChangeLines();
        return this.lines;
    }
}
// Given diffs from expected and received strings,
// return new array of diffs split or joined into lines.
//
// To correctly align a change line at the end, the algorithm:
// * assumes that a newline was appended to the strings
// * omits the last newline from the output array
//
// Assume the function is not called:
// * if either expected or received is empty string
// * if neither expected nor received is multiline string
const getAlignedDiffs = (diffs, changeColor)=>{
    const deleteBuffer = new ChangeBuffer(_cleanupSemantic.DIFF_DELETE, changeColor);
    const insertBuffer = new ChangeBuffer(_cleanupSemantic.DIFF_INSERT, changeColor);
    const commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);
    diffs.forEach((diff)=>{
        switch(diff[0]){
            case _cleanupSemantic.DIFF_DELETE:
                deleteBuffer.align(diff);
                break;
            case _cleanupSemantic.DIFF_INSERT:
                insertBuffer.align(diff);
                break;
            default:
                commonBuffer.align(diff);
        }
    });
    return commonBuffer.getLines();
};
var _default = getAlignedDiffs;
exports.default = _default;
}),
"[project]/align/node_modules/jest-diff/build/printDiffs.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.diffStringsUnified = exports.diffStringsRaw = void 0;
var _cleanupSemantic = __turbopack_context__.r("[project]/align/node_modules/jest-diff/build/cleanupSemantic.js [app-route] (ecmascript)");
var _diffLines = __turbopack_context__.r("[project]/align/node_modules/jest-diff/build/diffLines.js [app-route] (ecmascript)");
var _diffStrings = _interopRequireDefault(__turbopack_context__.r("[project]/align/node_modules/jest-diff/build/diffStrings.js [app-route] (ecmascript)"));
var _getAlignedDiffs = _interopRequireDefault(__turbopack_context__.r("[project]/align/node_modules/jest-diff/build/getAlignedDiffs.js [app-route] (ecmascript)"));
var _normalizeDiffOptions = __turbopack_context__.r("[project]/align/node_modules/jest-diff/build/normalizeDiffOptions.js [app-route] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ const hasCommonDiff = (diffs, isMultiline)=>{
    if (isMultiline) {
        // Important: Ignore common newline that was appended to multiline strings!
        const iLast = diffs.length - 1;
        return diffs.some((diff, i)=>diff[0] === _cleanupSemantic.DIFF_EQUAL && (i !== iLast || diff[1] !== '\n'));
    }
    return diffs.some((diff)=>diff[0] === _cleanupSemantic.DIFF_EQUAL);
};
// Compare two strings character-by-character.
// Format as comparison lines in which changed substrings have inverse colors.
const diffStringsUnified = (a, b, options)=>{
    if (a !== b && a.length !== 0 && b.length !== 0) {
        const isMultiline = a.includes('\n') || b.includes('\n');
        // getAlignedDiffs assumes that a newline was appended to the strings.
        const diffs = diffStringsRaw(isMultiline ? `${a}\n` : a, isMultiline ? `${b}\n` : b, true // cleanupSemantic
        );
        if (hasCommonDiff(diffs, isMultiline)) {
            const optionsNormalized = (0, _normalizeDiffOptions.normalizeDiffOptions)(options);
            const lines = (0, _getAlignedDiffs.default)(diffs, optionsNormalized.changeColor);
            return (0, _diffLines.printDiffLines)(lines, optionsNormalized);
        }
    }
    // Fall back to line-by-line diff.
    return (0, _diffLines.diffLinesUnified)(a.split('\n'), b.split('\n'), options);
};
// Compare two strings character-by-character.
// Optionally clean up small common substrings, also known as chaff.
exports.diffStringsUnified = diffStringsUnified;
const diffStringsRaw = (a, b, cleanup)=>{
    const diffs = (0, _diffStrings.default)(a, b);
    if (cleanup) {
        (0, _cleanupSemantic.cleanupSemantic)(diffs); // impure function
    }
    return diffs;
};
exports.diffStringsRaw = diffStringsRaw;
}),
"[project]/align/node_modules/jest-diff/build/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, '__esModule', {
    value: true
});
Object.defineProperty(exports, 'DIFF_DELETE', {
    enumerable: true,
    get: function() {
        return _cleanupSemantic.DIFF_DELETE;
    }
});
Object.defineProperty(exports, 'DIFF_EQUAL', {
    enumerable: true,
    get: function() {
        return _cleanupSemantic.DIFF_EQUAL;
    }
});
Object.defineProperty(exports, 'DIFF_INSERT', {
    enumerable: true,
    get: function() {
        return _cleanupSemantic.DIFF_INSERT;
    }
});
Object.defineProperty(exports, 'Diff', {
    enumerable: true,
    get: function() {
        return _cleanupSemantic.Diff;
    }
});
exports.diff = diff;
Object.defineProperty(exports, 'diffLinesRaw', {
    enumerable: true,
    get: function() {
        return _diffLines.diffLinesRaw;
    }
});
Object.defineProperty(exports, 'diffLinesUnified', {
    enumerable: true,
    get: function() {
        return _diffLines.diffLinesUnified;
    }
});
Object.defineProperty(exports, 'diffLinesUnified2', {
    enumerable: true,
    get: function() {
        return _diffLines.diffLinesUnified2;
    }
});
Object.defineProperty(exports, 'diffStringsRaw', {
    enumerable: true,
    get: function() {
        return _printDiffs.diffStringsRaw;
    }
});
Object.defineProperty(exports, 'diffStringsUnified', {
    enumerable: true,
    get: function() {
        return _printDiffs.diffStringsUnified;
    }
});
var _chalk = _interopRequireDefault(__turbopack_context__.r("[project]/align/node_modules/chalk/source/index.js [app-route] (ecmascript)"));
var _jestGetType = __turbopack_context__.r("[project]/align/node_modules/jest-get-type/build/index.js [app-route] (ecmascript)");
var _prettyFormat = __turbopack_context__.r("[project]/align/node_modules/jest-diff/node_modules/pretty-format/build/index.js [app-route] (ecmascript)");
var _cleanupSemantic = __turbopack_context__.r("[project]/align/node_modules/jest-diff/build/cleanupSemantic.js [app-route] (ecmascript)");
var _constants = __turbopack_context__.r("[project]/align/node_modules/jest-diff/build/constants.js [app-route] (ecmascript)");
var _diffLines = __turbopack_context__.r("[project]/align/node_modules/jest-diff/build/diffLines.js [app-route] (ecmascript)");
var _normalizeDiffOptions = __turbopack_context__.r("[project]/align/node_modules/jest-diff/build/normalizeDiffOptions.js [app-route] (ecmascript)");
var _printDiffs = __turbopack_context__.r("[project]/align/node_modules/jest-diff/build/printDiffs.js [app-route] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ const getCommonMessage = (message, options)=>{
    const { commonColor } = (0, _normalizeDiffOptions.normalizeDiffOptions)(options);
    return commonColor(message);
};
const { AsymmetricMatcher, DOMCollection, DOMElement, Immutable, ReactElement, ReactTestComponent } = _prettyFormat.plugins;
const PLUGINS = [
    ReactTestComponent,
    ReactElement,
    DOMElement,
    DOMCollection,
    Immutable,
    AsymmetricMatcher
];
const FORMAT_OPTIONS = {
    plugins: PLUGINS
};
const FALLBACK_FORMAT_OPTIONS = {
    callToJSON: false,
    maxDepth: 10,
    plugins: PLUGINS
};
// Generate a string that will highlight the difference between two values
// with green and red. (similar to how github does code diffing)
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function diff(a, b, options) {
    if (Object.is(a, b)) {
        return getCommonMessage(_constants.NO_DIFF_MESSAGE, options);
    }
    const aType = (0, _jestGetType.getType)(a);
    let expectedType = aType;
    let omitDifference = false;
    if (aType === 'object' && typeof a.asymmetricMatch === 'function') {
        if (a.$$typeof !== Symbol.for('jest.asymmetricMatcher')) {
            // Do not know expected type of user-defined asymmetric matcher.
            return null;
        }
        if (typeof a.getExpectedType !== 'function') {
            // For example, expect.anything() matches either null or undefined
            return null;
        }
        expectedType = a.getExpectedType();
        // Primitive types boolean and number omit difference below.
        // For example, omit difference for expect.stringMatching(regexp)
        omitDifference = expectedType === 'string';
    }
    if (expectedType !== (0, _jestGetType.getType)(b)) {
        return '  Comparing two different types of values.' + ` Expected ${_chalk.default.green(expectedType)} but ` + `received ${_chalk.default.red((0, _jestGetType.getType)(b))}.`;
    }
    if (omitDifference) {
        return null;
    }
    switch(aType){
        case 'string':
            return (0, _diffLines.diffLinesUnified)(a.split('\n'), b.split('\n'), options);
        case 'boolean':
        case 'number':
            return comparePrimitive(a, b, options);
        case 'map':
            return compareObjects(sortMap(a), sortMap(b), options);
        case 'set':
            return compareObjects(sortSet(a), sortSet(b), options);
        default:
            return compareObjects(a, b, options);
    }
}
function comparePrimitive(a, b, options) {
    const aFormat = (0, _prettyFormat.format)(a, FORMAT_OPTIONS);
    const bFormat = (0, _prettyFormat.format)(b, FORMAT_OPTIONS);
    return aFormat === bFormat ? getCommonMessage(_constants.NO_DIFF_MESSAGE, options) : (0, _diffLines.diffLinesUnified)(aFormat.split('\n'), bFormat.split('\n'), options);
}
function sortMap(map) {
    return new Map(Array.from(map.entries()).sort());
}
function sortSet(set) {
    return new Set(Array.from(set.values()).sort());
}
function compareObjects(a, b, options) {
    let difference;
    let hasThrown = false;
    try {
        const formatOptions = getFormatOptions(FORMAT_OPTIONS, options);
        difference = getObjectsDifference(a, b, formatOptions, options);
    } catch  {
        hasThrown = true;
    }
    const noDiffMessage = getCommonMessage(_constants.NO_DIFF_MESSAGE, options);
    // If the comparison yields no results, compare again but this time
    // without calling `toJSON`. It's also possible that toJSON might throw.
    if (difference === undefined || difference === noDiffMessage) {
        const formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);
        difference = getObjectsDifference(a, b, formatOptions, options);
        if (difference !== noDiffMessage && !hasThrown) {
            difference = `${getCommonMessage(_constants.SIMILAR_MESSAGE, options)}\n\n${difference}`;
        }
    }
    return difference;
}
function getFormatOptions(formatOptions, options) {
    const { compareKeys } = (0, _normalizeDiffOptions.normalizeDiffOptions)(options);
    return {
        ...formatOptions,
        compareKeys
    };
}
function getObjectsDifference(a, b, formatOptions, options) {
    const formatOptionsZeroIndent = {
        ...formatOptions,
        indent: 0
    };
    const aCompare = (0, _prettyFormat.format)(a, formatOptionsZeroIndent);
    const bCompare = (0, _prettyFormat.format)(b, formatOptionsZeroIndent);
    if (aCompare === bCompare) {
        return getCommonMessage(_constants.NO_DIFF_MESSAGE, options);
    } else {
        const aDisplay = (0, _prettyFormat.format)(a, formatOptions);
        const bDisplay = (0, _prettyFormat.format)(b, formatOptions);
        return (0, _diffLines.diffLinesUnified2)(aDisplay.split('\n'), bDisplay.split('\n'), aCompare.split('\n'), bCompare.split('\n'), options);
    }
}
}),
"[project]/align/node_modules/wrap-ansi/node_modules/ansi-styles/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "backgroundColorNames",
    ()=>backgroundColorNames,
    "colorNames",
    ()=>colorNames,
    "default",
    ()=>__TURBOPACK__default__export__,
    "foregroundColorNames",
    ()=>foregroundColorNames,
    "modifierNames",
    ()=>modifierNames
]);
const ANSI_BACKGROUND_OFFSET = 10;
const wrapAnsi16 = (offset = 0)=>(code)=>`\u001B[${code + offset}m`;
const wrapAnsi256 = (offset = 0)=>(code)=>`\u001B[${38 + offset};5;${code}m`;
const wrapAnsi16m = (offset = 0)=>(red, green, blue)=>`\u001B[${38 + offset};2;${red};${green};${blue}m`;
const styles = {
    modifier: {
        reset: [
            0,
            0
        ],
        // 21 isn't widely supported and 22 does the same thing
        bold: [
            1,
            22
        ],
        dim: [
            2,
            22
        ],
        italic: [
            3,
            23
        ],
        underline: [
            4,
            24
        ],
        overline: [
            53,
            55
        ],
        inverse: [
            7,
            27
        ],
        hidden: [
            8,
            28
        ],
        strikethrough: [
            9,
            29
        ]
    },
    color: {
        black: [
            30,
            39
        ],
        red: [
            31,
            39
        ],
        green: [
            32,
            39
        ],
        yellow: [
            33,
            39
        ],
        blue: [
            34,
            39
        ],
        magenta: [
            35,
            39
        ],
        cyan: [
            36,
            39
        ],
        white: [
            37,
            39
        ],
        // Bright color
        blackBright: [
            90,
            39
        ],
        gray: [
            90,
            39
        ],
        grey: [
            90,
            39
        ],
        redBright: [
            91,
            39
        ],
        greenBright: [
            92,
            39
        ],
        yellowBright: [
            93,
            39
        ],
        blueBright: [
            94,
            39
        ],
        magentaBright: [
            95,
            39
        ],
        cyanBright: [
            96,
            39
        ],
        whiteBright: [
            97,
            39
        ]
    },
    bgColor: {
        bgBlack: [
            40,
            49
        ],
        bgRed: [
            41,
            49
        ],
        bgGreen: [
            42,
            49
        ],
        bgYellow: [
            43,
            49
        ],
        bgBlue: [
            44,
            49
        ],
        bgMagenta: [
            45,
            49
        ],
        bgCyan: [
            46,
            49
        ],
        bgWhite: [
            47,
            49
        ],
        // Bright color
        bgBlackBright: [
            100,
            49
        ],
        bgGray: [
            100,
            49
        ],
        bgGrey: [
            100,
            49
        ],
        bgRedBright: [
            101,
            49
        ],
        bgGreenBright: [
            102,
            49
        ],
        bgYellowBright: [
            103,
            49
        ],
        bgBlueBright: [
            104,
            49
        ],
        bgMagentaBright: [
            105,
            49
        ],
        bgCyanBright: [
            106,
            49
        ],
        bgWhiteBright: [
            107,
            49
        ]
    }
};
const modifierNames = Object.keys(styles.modifier);
const foregroundColorNames = Object.keys(styles.color);
const backgroundColorNames = Object.keys(styles.bgColor);
const colorNames = [
    ...foregroundColorNames,
    ...backgroundColorNames
];
function assembleStyles() {
    const codes = new Map();
    for (const [groupName, group] of Object.entries(styles)){
        for (const [styleName, style] of Object.entries(group)){
            styles[styleName] = {
                open: `\u001B[${style[0]}m`,
                close: `\u001B[${style[1]}m`
            };
            group[styleName] = styles[styleName];
            codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
            value: group,
            enumerable: false
        });
    }
    Object.defineProperty(styles, 'codes', {
        value: codes,
        enumerable: false
    });
    styles.color.close = '\u001B[39m';
    styles.bgColor.close = '\u001B[49m';
    styles.color.ansi = wrapAnsi16();
    styles.color.ansi256 = wrapAnsi256();
    styles.color.ansi16m = wrapAnsi16m();
    styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
    styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
    styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
    // From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
    Object.defineProperties(styles, {
        rgbToAnsi256: {
            value (red, green, blue) {
                // We use the extended greyscale palette here, with the exception of
                // black and white. normal palette only has 4 greyscale shades.
                if (red === green && green === blue) {
                    if (red < 8) {
                        return 16;
                    }
                    if (red > 248) {
                        return 231;
                    }
                    return Math.round((red - 8) / 247 * 24) + 232;
                }
                return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
            },
            enumerable: false
        },
        hexToRgb: {
            value (hex) {
                const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
                if (!matches) {
                    return [
                        0,
                        0,
                        0
                    ];
                }
                let [colorString] = matches;
                if (colorString.length === 3) {
                    colorString = [
                        ...colorString
                    ].map((character)=>character + character).join('');
                }
                const integer = Number.parseInt(colorString, 16);
                return [
                    /* eslint-disable no-bitwise */ integer >> 16 & 0xFF,
                    integer >> 8 & 0xFF,
                    integer & 0xFF
                ];
            },
            enumerable: false
        },
        hexToAnsi256: {
            value: (hex)=>styles.rgbToAnsi256(...styles.hexToRgb(hex)),
            enumerable: false
        },
        ansi256ToAnsi: {
            value (code) {
                if (code < 8) {
                    return 30 + code;
                }
                if (code < 16) {
                    return 90 + (code - 8);
                }
                let red;
                let green;
                let blue;
                if (code >= 232) {
                    red = ((code - 232) * 10 + 8) / 255;
                    green = red;
                    blue = red;
                } else {
                    code -= 16;
                    const remainder = code % 36;
                    red = Math.floor(code / 36) / 5;
                    green = Math.floor(remainder / 6) / 5;
                    blue = remainder % 6 / 5;
                }
                const value = Math.max(red, green, blue) * 2;
                if (value === 0) {
                    return 30;
                }
                // eslint-disable-next-line no-bitwise
                let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
                if (value === 2) {
                    result += 60;
                }
                return result;
            },
            enumerable: false
        },
        rgbToAnsi: {
            value: (red, green, blue)=>styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
            enumerable: false
        },
        hexToAnsi: {
            value: (hex)=>styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
            enumerable: false
        }
    });
    return styles;
}
const ansiStyles = assembleStyles();
const __TURBOPACK__default__export__ = ansiStyles;
}),
"[project]/align/node_modules/wrap-ansi/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>wrapAnsi
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$string$2d$width$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/string-width/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$strip$2d$ansi$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/strip-ansi/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$wrap$2d$ansi$2f$node_modules$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/wrap-ansi/node_modules/ansi-styles/index.js [app-route] (ecmascript)");
;
;
;
const ESCAPES = new Set([
    '\u001B',
    '\u009B'
]);
const END_CODE = 39;
const ANSI_ESCAPE_BELL = '\u0007';
const ANSI_CSI = '[';
const ANSI_OSC = ']';
const ANSI_SGR_TERMINATOR = 'm';
const ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;
const wrapAnsiCode = (code)=>`${ESCAPES.values().next().value}${ANSI_CSI}${code}${ANSI_SGR_TERMINATOR}`;
const wrapAnsiHyperlink = (url)=>`${ESCAPES.values().next().value}${ANSI_ESCAPE_LINK}${url}${ANSI_ESCAPE_BELL}`;
// Calculate the length of words split on ' ', ignoring
// the extra characters added by ansi escape codes
const wordLengths = (string)=>string.split(' ').map((character)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$string$2d$width$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(character));
// Wrap a long word across multiple rows
// Ansi escape codes do not count towards length
const wrapWord = (rows, word, columns)=>{
    const characters = [
        ...word
    ];
    let isInsideEscape = false;
    let isInsideLinkEscape = false;
    let visible = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$string$2d$width$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$strip$2d$ansi$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(rows.at(-1)));
    for (const [index, character] of characters.entries()){
        const characterLength = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$string$2d$width$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(character);
        if (visible + characterLength <= columns) {
            rows[rows.length - 1] += character;
        } else {
            rows.push(character);
            visible = 0;
        }
        if (ESCAPES.has(character)) {
            isInsideEscape = true;
            const ansiEscapeLinkCandidate = characters.slice(index + 1, index + 1 + ANSI_ESCAPE_LINK.length).join('');
            isInsideLinkEscape = ansiEscapeLinkCandidate === ANSI_ESCAPE_LINK;
        }
        if (isInsideEscape) {
            if (isInsideLinkEscape) {
                if (character === ANSI_ESCAPE_BELL) {
                    isInsideEscape = false;
                    isInsideLinkEscape = false;
                }
            } else if (character === ANSI_SGR_TERMINATOR) {
                isInsideEscape = false;
            }
            continue;
        }
        visible += characterLength;
        if (visible === columns && index < characters.length - 1) {
            rows.push('');
            visible = 0;
        }
    }
    // It's possible that the last row we copy over is only
    // ansi escape characters, handle this edge-case
    if (!visible && rows.at(-1).length > 0 && rows.length > 1) {
        rows[rows.length - 2] += rows.pop();
    }
};
// Trims spaces from a string ignoring invisible sequences
const stringVisibleTrimSpacesRight = (string)=>{
    const words = string.split(' ');
    let last = words.length;
    while(last > 0){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$string$2d$width$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(words[last - 1]) > 0) {
            break;
        }
        last--;
    }
    if (last === words.length) {
        return string;
    }
    return words.slice(0, last).join(' ') + words.slice(last).join('');
};
// The wrap-ansi module can be invoked in either 'hard' or 'soft' wrap mode.
//
// 'hard' will never allow a string to take up more than columns characters.
//
// 'soft' allows long words to expand past the column length.
const exec = (string, columns, options = {})=>{
    if (options.trim !== false && string.trim() === '') {
        return '';
    }
    let returnValue = '';
    let escapeCode;
    let escapeUrl;
    const lengths = wordLengths(string);
    let rows = [
        ''
    ];
    for (const [index, word] of string.split(' ').entries()){
        if (options.trim !== false) {
            rows[rows.length - 1] = rows.at(-1).trimStart();
        }
        let rowLength = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$string$2d$width$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(rows.at(-1));
        if (index !== 0) {
            if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
                // If we start with a new word but the current row length equals the length of the columns, add a new row
                rows.push('');
                rowLength = 0;
            }
            if (rowLength > 0 || options.trim === false) {
                rows[rows.length - 1] += ' ';
                rowLength++;
            }
        }
        // In 'hard' wrap mode, the length of a line is never allowed to extend past 'columns'
        if (options.hard && lengths[index] > columns) {
            const remainingColumns = columns - rowLength;
            const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
            const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
            if (breaksStartingNextLine < breaksStartingThisLine) {
                rows.push('');
            }
            wrapWord(rows, word, columns);
            continue;
        }
        if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
            if (options.wordWrap === false && rowLength < columns) {
                wrapWord(rows, word, columns);
                continue;
            }
            rows.push('');
        }
        if (rowLength + lengths[index] > columns && options.wordWrap === false) {
            wrapWord(rows, word, columns);
            continue;
        }
        rows[rows.length - 1] += word;
    }
    if (options.trim !== false) {
        rows = rows.map((row)=>stringVisibleTrimSpacesRight(row));
    }
    const preString = rows.join('\n');
    const pre = [
        ...preString
    ];
    // We need to keep a separate index as `String#slice()` works on Unicode code units, while `pre` is an array of codepoints.
    let preStringIndex = 0;
    for (const [index, character] of pre.entries()){
        returnValue += character;
        if (ESCAPES.has(character)) {
            const { groups } = new RegExp(`(?:\\${ANSI_CSI}(?<code>\\d+)m|\\${ANSI_ESCAPE_LINK}(?<uri>.*)${ANSI_ESCAPE_BELL})`).exec(preString.slice(preStringIndex)) || {
                groups: {}
            };
            if (groups.code !== undefined) {
                const code = Number.parseFloat(groups.code);
                escapeCode = code === END_CODE ? undefined : code;
            } else if (groups.uri !== undefined) {
                escapeUrl = groups.uri.length === 0 ? undefined : groups.uri;
            }
        }
        const code = __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$wrap$2d$ansi$2f$node_modules$2f$ansi$2d$styles$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].codes.get(Number(escapeCode));
        if (pre[index + 1] === '\n') {
            if (escapeUrl) {
                returnValue += wrapAnsiHyperlink('');
            }
            if (escapeCode && code) {
                returnValue += wrapAnsiCode(code);
            }
        } else if (character === '\n') {
            if (escapeCode && code) {
                returnValue += wrapAnsiCode(escapeCode);
            }
            if (escapeUrl) {
                returnValue += wrapAnsiHyperlink(escapeUrl);
            }
        }
        preStringIndex += character.length;
    }
    return returnValue;
};
function wrapAnsi(string, columns, options) {
    return String(string).normalize().replaceAll('\r\n', '\n').split('\n').map((line)=>exec(line, columns, options)).join('\n');
}
}),
"[project]/align/node_modules/has-flag/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = (flag, argv = process.argv)=>{
    const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf('--');
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};
}),
"[project]/align/node_modules/supports-color/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
const tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
const hasFlag = __turbopack_context__.r("[project]/align/node_modules/has-flag/index.js [app-route] (ecmascript)");
const { env } = process;
let forceColor;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
    forceColor = 0;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
    forceColor = 1;
}
if ('FORCE_COLOR' in env) {
    if (env.FORCE_COLOR === 'true') {
        forceColor = 1;
    } else if (env.FORCE_COLOR === 'false') {
        forceColor = 0;
    } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
}
function translateLevel(level) {
    if (level === 0) {
        return false;
    }
    return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
    };
}
function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
        return 0;
    }
    if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
        return 3;
    }
    if (hasFlag('color=256')) {
        return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
        return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === 'dumb') {
        return min;
    }
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    if ('CI' in env) {
        if ([
            'TRAVIS',
            'CIRCLECI',
            'APPVEYOR',
            'GITLAB_CI',
            'GITHUB_ACTIONS',
            'BUILDKITE'
        ].some((sign)=>sign in env) || env.CI_NAME === 'codeship') {
            return 1;
        }
        return min;
    }
    if ('TEAMCITY_VERSION' in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === 'truecolor') {
        return 3;
    }
    if ('TERM_PROGRAM' in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
        switch(env.TERM_PROGRAM){
            case 'iTerm.app':
                return version >= 3 ? 3 : 2;
            case 'Apple_Terminal':
                return 2;
        }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
    }
    if ('COLORTERM' in env) {
        return 1;
    }
    return min;
}
function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
}
module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};
}),
"[project]/align/node_modules/jest-get-type/build/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.getType = getType;
exports.isPrimitive = void 0;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // get the type of a value with handling the edge cases like `typeof []`
// and `typeof null`
function getType(value) {
    if (value === undefined) {
        return 'undefined';
    } else if (value === null) {
        return 'null';
    } else if (Array.isArray(value)) {
        return 'array';
    } else if (typeof value === 'boolean') {
        return 'boolean';
    } else if (typeof value === 'function') {
        return 'function';
    } else if (typeof value === 'number') {
        return 'number';
    } else if (typeof value === 'string') {
        return 'string';
    } else if (typeof value === 'bigint') {
        return 'bigint';
    } else if (typeof value === 'object') {
        if (value != null) {
            if (value.constructor === RegExp) {
                return 'regexp';
            } else if (value.constructor === Map) {
                return 'map';
            } else if (value.constructor === Set) {
                return 'set';
            } else if (value.constructor === Date) {
                return 'date';
            }
        }
        return 'object';
    } else if (typeof value === 'symbol') {
        return 'symbol';
    }
    throw new Error(`value of unknown type: ${value}`);
}
const isPrimitive = (value)=>Object(value) !== value;
exports.isPrimitive = isPrimitive;
}),
"[project]/align/node_modules/diff-sequences/build/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.default = diffSequence;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ // This diff-sequences package implements the linear space variation in
// An O(ND) Difference Algorithm and Its Variations by Eugene W. Myers
// Relationship in notation between Myers paper and this package:
// A is a
// N is aLength, aEnd - aStart, and so on
// x is aIndex, aFirst, aLast, and so on
// B is b
// M is bLength, bEnd - bStart, and so on
// y is bIndex, bFirst, bLast, and so on
//  = N - M is negative of baDeltaLength = bLength - aLength
// D is d
// k is kF
// k +  is kF = kR - baDeltaLength
// V is aIndexesF or aIndexesR (see comment below about Indexes type)
// index intervals [1, N] and [1, M] are [0, aLength) and [0, bLength)
// starting point in forward direction (0, 0) is (-1, -1)
// starting point in reverse direction (N + 1, M + 1) is (aLength, bLength)
// The edit graph for sequences a and b corresponds to items:
// in a on the horizontal axis
// in b on the vertical axis
//
// Given a-coordinate of a point in a diagonal, you can compute b-coordinate.
//
// Forward diagonals kF:
// zero diagonal intersects top left corner
// positive diagonals intersect top edge
// negative diagonals insersect left edge
//
// Reverse diagonals kR:
// zero diagonal intersects bottom right corner
// positive diagonals intersect right edge
// negative diagonals intersect bottom edge
// The graph contains a directed acyclic graph of edges:
// horizontal: delete an item from a
// vertical: insert an item from b
// diagonal: common item in a and b
//
// The algorithm solves dual problems in the graph analogy:
// Find longest common subsequence: path with maximum number of diagonal edges
// Find shortest edit script: path with minimum number of non-diagonal edges
// Input callback function compares items at indexes in the sequences.
// Output callback function receives the number of adjacent items
// and starting indexes of each common subsequence.
// Either original functions or wrapped to swap indexes if graph is transposed.
// Indexes in sequence a of last point of forward or reverse paths in graph.
// Myers algorithm indexes by diagonal k which for negative is bad deopt in V8.
// This package indexes by iF and iR which are greater than or equal to zero.
// and also updates the index arrays in place to cut memory in half.
// kF = 2 * iF - d
// kR = d - 2 * iR
// Division of index intervals in sequences a and b at the middle change.
// Invariant: intervals do not have common items at the start or end.
const pkg = 'diff-sequences'; // for error messages
const NOT_YET_SET = 0; // small int instead of undefined to avoid deopt in V8
// Return the number of common items that follow in forward direction.
// The length of what Myers paper calls a snake in a forward path.
const countCommonItemsF = (aIndex, aEnd, bIndex, bEnd, isCommon)=>{
    let nCommon = 0;
    while(aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex)){
        aIndex += 1;
        bIndex += 1;
        nCommon += 1;
    }
    return nCommon;
};
// Return the number of common items that precede in reverse direction.
// The length of what Myers paper calls a snake in a reverse path.
const countCommonItemsR = (aStart, aIndex, bStart, bIndex, isCommon)=>{
    let nCommon = 0;
    while(aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex)){
        aIndex -= 1;
        bIndex -= 1;
        nCommon += 1;
    }
    return nCommon;
};
// A simple function to extend forward paths from (d - 1) to d changes
// when forward and reverse paths cannot yet overlap.
const extendPathsF = (d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF // return the value because optimization might decrease it
)=>{
    // Unroll the first iteration.
    let iF = 0;
    let kF = -d; // kF = 2 * iF - d
    let aFirst = aIndexesF[iF]; // in first iteration always insert
    let aIndexPrev1 = aFirst; // prev value of [iF - 1] in next iteration
    aIndexesF[iF] += countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
    // Optimization: skip diagonals in which paths cannot ever overlap.
    const nF = d < iMaxF ? d : iMaxF;
    // The diagonals kF are odd when d is odd and even when d is even.
    for(iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2){
        // To get first point of path segment, move one change in forward direction
        // from last point of previous path segment in an adjacent diagonal.
        // In last possible iteration when iF === d and kF === d always delete.
        if (iF !== d && aIndexPrev1 < aIndexesF[iF]) {
            aFirst = aIndexesF[iF]; // vertical to insert from b
        } else {
            aFirst = aIndexPrev1 + 1; // horizontal to delete from a
            if (aEnd <= aFirst) {
                // Optimization: delete moved past right of graph.
                return iF - 1;
            }
        }
        // To get last point of path segment, move along diagonal of common items.
        aIndexPrev1 = aIndexesF[iF];
        aIndexesF[iF] = aFirst + countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
    }
    return iMaxF;
};
// A simple function to extend reverse paths from (d - 1) to d changes
// when reverse and forward paths cannot yet overlap.
const extendPathsR = (d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR // return the value because optimization might decrease it
)=>{
    // Unroll the first iteration.
    let iR = 0;
    let kR = d; // kR = d - 2 * iR
    let aFirst = aIndexesR[iR]; // in first iteration always insert
    let aIndexPrev1 = aFirst; // prev value of [iR - 1] in next iteration
    aIndexesR[iR] -= countCommonItemsR(aStart, aFirst - 1, bStart, bR + aFirst - kR - 1, isCommon);
    // Optimization: skip diagonals in which paths cannot ever overlap.
    const nR = d < iMaxR ? d : iMaxR;
    // The diagonals kR are odd when d is odd and even when d is even.
    for(iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2){
        // To get first point of path segment, move one change in reverse direction
        // from last point of previous path segment in an adjacent diagonal.
        // In last possible iteration when iR === d and kR === -d always delete.
        if (iR !== d && aIndexesR[iR] < aIndexPrev1) {
            aFirst = aIndexesR[iR]; // vertical to insert from b
        } else {
            aFirst = aIndexPrev1 - 1; // horizontal to delete from a
            if (aFirst < aStart) {
                // Optimization: delete moved past left of graph.
                return iR - 1;
            }
        }
        // To get last point of path segment, move along diagonal of common items.
        aIndexPrev1 = aIndexesR[iR];
        aIndexesR[iR] = aFirst - countCommonItemsR(aStart, aFirst - 1, bStart, bR + aFirst - kR - 1, isCommon);
    }
    return iMaxR;
};
// A complete function to extend forward paths from (d - 1) to d changes.
// Return true if a path overlaps reverse path of (d - 1) changes in its diagonal.
const extendOverlappablePathsF = (d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division // update prop values if return true
)=>{
    const bF = bStart - aStart; // bIndex = bF + aIndex - kF
    const aLength = aEnd - aStart;
    const bLength = bEnd - bStart;
    const baDeltaLength = bLength - aLength; // kF = kR - baDeltaLength
    // Range of diagonals in which forward and reverse paths might overlap.
    const kMinOverlapF = -baDeltaLength - (d - 1); // -(d - 1) <= kR
    const kMaxOverlapF = -baDeltaLength + (d - 1); // kR <= (d - 1)
    let aIndexPrev1 = NOT_YET_SET; // prev value of [iF - 1] in next iteration
    // Optimization: skip diagonals in which paths cannot ever overlap.
    const nF = d < iMaxF ? d : iMaxF;
    // The diagonals kF = 2 * iF - d are odd when d is odd and even when d is even.
    for(let iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2){
        // To get first point of path segment, move one change in forward direction
        // from last point of previous path segment in an adjacent diagonal.
        // In first iteration when iF === 0 and kF === -d always insert.
        // In last possible iteration when iF === d and kF === d always delete.
        const insert = iF === 0 || iF !== d && aIndexPrev1 < aIndexesF[iF];
        const aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1;
        const aFirst = insert ? aLastPrev // vertical to insert from b
         : aLastPrev + 1; // horizontal to delete from a
        // To get last point of path segment, move along diagonal of common items.
        const bFirst = bF + aFirst - kF;
        const nCommonF = countCommonItemsF(aFirst + 1, aEnd, bFirst + 1, bEnd, isCommon);
        const aLast = aFirst + nCommonF;
        aIndexPrev1 = aIndexesF[iF];
        aIndexesF[iF] = aLast;
        if (kMinOverlapF <= kF && kF <= kMaxOverlapF) {
            // Solve for iR of reverse path with (d - 1) changes in diagonal kF:
            // kR = kF + baDeltaLength
            // kR = (d - 1) - 2 * iR
            const iR = (d - 1 - (kF + baDeltaLength)) / 2;
            // If this forward path overlaps the reverse path in this diagonal,
            // then this is the middle change of the index intervals.
            if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {
                // Unlike the Myers algorithm which finds only the middle snake
                // this package can find two common subsequences per division.
                // Last point of previous path segment is on an adjacent diagonal.
                const bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1);
                // Because of invariant that intervals preceding the middle change
                // cannot have common items at the end,
                // move in reverse direction along a diagonal of common items.
                const nCommonR = countCommonItemsR(aStart, aLastPrev, bStart, bLastPrev, isCommon);
                const aIndexPrevFirst = aLastPrev - nCommonR;
                const bIndexPrevFirst = bLastPrev - nCommonR;
                const aEndPreceding = aIndexPrevFirst + 1;
                const bEndPreceding = bIndexPrevFirst + 1;
                division.nChangePreceding = d - 1;
                if (d - 1 === aEndPreceding + bEndPreceding - aStart - bStart) {
                    // Optimization: number of preceding changes in forward direction
                    // is equal to number of items in preceding interval,
                    // therefore it cannot contain any common items.
                    division.aEndPreceding = aStart;
                    division.bEndPreceding = bStart;
                } else {
                    division.aEndPreceding = aEndPreceding;
                    division.bEndPreceding = bEndPreceding;
                }
                division.nCommonPreceding = nCommonR;
                if (nCommonR !== 0) {
                    division.aCommonPreceding = aEndPreceding;
                    division.bCommonPreceding = bEndPreceding;
                }
                division.nCommonFollowing = nCommonF;
                if (nCommonF !== 0) {
                    division.aCommonFollowing = aFirst + 1;
                    division.bCommonFollowing = bFirst + 1;
                }
                const aStartFollowing = aLast + 1;
                const bStartFollowing = bFirst + nCommonF + 1;
                division.nChangeFollowing = d - 1;
                if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {
                    // Optimization: number of changes in reverse direction
                    // is equal to number of items in following interval,
                    // therefore it cannot contain any common items.
                    division.aStartFollowing = aEnd;
                    division.bStartFollowing = bEnd;
                } else {
                    division.aStartFollowing = aStartFollowing;
                    division.bStartFollowing = bStartFollowing;
                }
                return true;
            }
        }
    }
    return false;
};
// A complete function to extend reverse paths from (d - 1) to d changes.
// Return true if a path overlaps forward path of d changes in its diagonal.
const extendOverlappablePathsR = (d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division // update prop values if return true
)=>{
    const bR = bEnd - aEnd; // bIndex = bR + aIndex - kR
    const aLength = aEnd - aStart;
    const bLength = bEnd - bStart;
    const baDeltaLength = bLength - aLength; // kR = kF + baDeltaLength
    // Range of diagonals in which forward and reverse paths might overlap.
    const kMinOverlapR = baDeltaLength - d; // -d <= kF
    const kMaxOverlapR = baDeltaLength + d; // kF <= d
    let aIndexPrev1 = NOT_YET_SET; // prev value of [iR - 1] in next iteration
    // Optimization: skip diagonals in which paths cannot ever overlap.
    const nR = d < iMaxR ? d : iMaxR;
    // The diagonals kR = d - 2 * iR are odd when d is odd and even when d is even.
    for(let iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2){
        // To get first point of path segment, move one change in reverse direction
        // from last point of previous path segment in an adjacent diagonal.
        // In first iteration when iR === 0 and kR === d always insert.
        // In last possible iteration when iR === d and kR === -d always delete.
        const insert = iR === 0 || iR !== d && aIndexesR[iR] < aIndexPrev1;
        const aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1;
        const aFirst = insert ? aLastPrev // vertical to insert from b
         : aLastPrev - 1; // horizontal to delete from a
        // To get last point of path segment, move along diagonal of common items.
        const bFirst = bR + aFirst - kR;
        const nCommonR = countCommonItemsR(aStart, aFirst - 1, bStart, bFirst - 1, isCommon);
        const aLast = aFirst - nCommonR;
        aIndexPrev1 = aIndexesR[iR];
        aIndexesR[iR] = aLast;
        if (kMinOverlapR <= kR && kR <= kMaxOverlapR) {
            // Solve for iF of forward path with d changes in diagonal kR:
            // kF = kR - baDeltaLength
            // kF = 2 * iF - d
            const iF = (d + (kR - baDeltaLength)) / 2;
            // If this reverse path overlaps the forward path in this diagonal,
            // then this is a middle change of the index intervals.
            if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {
                const bLast = bFirst - nCommonR;
                division.nChangePreceding = d;
                if (d === aLast + bLast - aStart - bStart) {
                    // Optimization: number of changes in reverse direction
                    // is equal to number of items in preceding interval,
                    // therefore it cannot contain any common items.
                    division.aEndPreceding = aStart;
                    division.bEndPreceding = bStart;
                } else {
                    division.aEndPreceding = aLast;
                    division.bEndPreceding = bLast;
                }
                division.nCommonPreceding = nCommonR;
                if (nCommonR !== 0) {
                    // The last point of reverse path segment is start of common subsequence.
                    division.aCommonPreceding = aLast;
                    division.bCommonPreceding = bLast;
                }
                division.nChangeFollowing = d - 1;
                if (d === 1) {
                    // There is no previous path segment.
                    division.nCommonFollowing = 0;
                    division.aStartFollowing = aEnd;
                    division.bStartFollowing = bEnd;
                } else {
                    // Unlike the Myers algorithm which finds only the middle snake
                    // this package can find two common subsequences per division.
                    // Last point of previous path segment is on an adjacent diagonal.
                    const bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1);
                    // Because of invariant that intervals following the middle change
                    // cannot have common items at the start,
                    // move in forward direction along a diagonal of common items.
                    const nCommonF = countCommonItemsF(aLastPrev, aEnd, bLastPrev, bEnd, isCommon);
                    division.nCommonFollowing = nCommonF;
                    if (nCommonF !== 0) {
                        // The last point of reverse path segment is start of common subsequence.
                        division.aCommonFollowing = aLastPrev;
                        division.bCommonFollowing = bLastPrev;
                    }
                    const aStartFollowing = aLastPrev + nCommonF; // aFirstPrev
                    const bStartFollowing = bLastPrev + nCommonF; // bFirstPrev
                    if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {
                        // Optimization: number of changes in forward direction
                        // is equal to number of items in following interval,
                        // therefore it cannot contain any common items.
                        division.aStartFollowing = aEnd;
                        division.bStartFollowing = bEnd;
                    } else {
                        division.aStartFollowing = aStartFollowing;
                        division.bStartFollowing = bStartFollowing;
                    }
                }
                return true;
            }
        }
    }
    return false;
};
// Given index intervals and input function to compare items at indexes,
// divide at the middle change.
//
// DO NOT CALL if start === end, because interval cannot contain common items
// and because this function will throw the no overlap error.
const divide = (nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division // output
)=>{
    const bF = bStart - aStart; // bIndex = bF + aIndex - kF
    const bR = bEnd - aEnd; // bIndex = bR + aIndex - kR
    const aLength = aEnd - aStart;
    const bLength = bEnd - bStart;
    // Because graph has square or portrait orientation,
    // length difference is minimum number of items to insert from b.
    // Corresponding forward and reverse diagonals in graph
    // depend on length difference of the sequences:
    // kF = kR - baDeltaLength
    // kR = kF + baDeltaLength
    const baDeltaLength = bLength - aLength;
    // Optimization: max diagonal in graph intersects corner of shorter side.
    let iMaxF = aLength;
    let iMaxR = aLength;
    // Initialize no changes yet in forward or reverse direction:
    aIndexesF[0] = aStart - 1; // at open start of interval, outside closed start
    aIndexesR[0] = aEnd; // at open end of interval
    if (baDeltaLength % 2 === 0) {
        // The number of changes in paths is 2 * d if length difference is even.
        const dMin = (nChange || baDeltaLength) / 2;
        const dMax = (aLength + bLength) / 2;
        for(let d = 1; d <= dMax; d += 1){
            iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
            if (d < dMin) {
                iMaxR = extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);
            } else if (// If a reverse path overlaps a forward path in the same diagonal,
            // return a division of the index intervals at the middle change.
            extendOverlappablePathsR(d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division)) {
                return;
            }
        }
    } else {
        // The number of changes in paths is 2 * d - 1 if length difference is odd.
        const dMin = ((nChange || baDeltaLength) + 1) / 2;
        const dMax = (aLength + bLength + 1) / 2;
        // Unroll first half iteration so loop extends the relevant pairs of paths.
        // Because of invariant that intervals have no common items at start or end,
        // and limitation not to call divide with empty intervals,
        // therefore it cannot be called if a forward path with one change
        // would overlap a reverse path with no changes, even if dMin === 1.
        let d = 1;
        iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
        for(d += 1; d <= dMax; d += 1){
            iMaxR = extendPathsR(d - 1, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);
            if (d < dMin) {
                iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
            } else if (// If a forward path overlaps a reverse path in the same diagonal,
            // return a division of the index intervals at the middle change.
            extendOverlappablePathsF(d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division)) {
                return;
            }
        }
    }
    /* istanbul ignore next */ throw new Error(`${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`);
};
// Given index intervals and input function to compare items at indexes,
// return by output function the number of adjacent items and starting indexes
// of each common subsequence. Divide and conquer with only linear space.
//
// The index intervals are half open [start, end) like array slice method.
// DO NOT CALL if start === end, because interval cannot contain common items
// and because divide function will throw the no overlap error.
const findSubsequences = (nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division // temporary memory, not input nor output
)=>{
    if (bEnd - bStart < aEnd - aStart) {
        // Transpose graph so it has portrait instead of landscape orientation.
        // Always compare shorter to longer sequence for consistency and optimization.
        transposed = !transposed;
        if (transposed && callbacks.length === 1) {
            // Lazily wrap callback functions to swap args if graph is transposed.
            const { foundSubsequence, isCommon } = callbacks[0];
            callbacks[1] = {
                foundSubsequence: (nCommon, bCommon, aCommon)=>{
                    foundSubsequence(nCommon, aCommon, bCommon);
                },
                isCommon: (bIndex, aIndex)=>isCommon(aIndex, bIndex)
            };
        }
        const tStart = aStart;
        const tEnd = aEnd;
        aStart = bStart;
        aEnd = bEnd;
        bStart = tStart;
        bEnd = tEnd;
    }
    const { foundSubsequence, isCommon } = callbacks[transposed ? 1 : 0];
    // Divide the index intervals at the middle change.
    divide(nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division);
    const { nChangePreceding, aEndPreceding, bEndPreceding, nCommonPreceding, aCommonPreceding, bCommonPreceding, nCommonFollowing, aCommonFollowing, bCommonFollowing, nChangeFollowing, aStartFollowing, bStartFollowing } = division;
    // Unless either index interval is empty, they might contain common items.
    if (aStart < aEndPreceding && bStart < bEndPreceding) {
        // Recursely find and return common subsequences preceding the division.
        findSubsequences(nChangePreceding, aStart, aEndPreceding, bStart, bEndPreceding, transposed, callbacks, aIndexesF, aIndexesR, division);
    }
    // Return common subsequences that are adjacent to the middle change.
    if (nCommonPreceding !== 0) {
        foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding);
    }
    if (nCommonFollowing !== 0) {
        foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing);
    }
    // Unless either index interval is empty, they might contain common items.
    if (aStartFollowing < aEnd && bStartFollowing < bEnd) {
        // Recursely find and return common subsequences following the division.
        findSubsequences(nChangeFollowing, aStartFollowing, aEnd, bStartFollowing, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division);
    }
};
const validateLength = (name, arg)=>{
    if (typeof arg !== 'number') {
        throw new TypeError(`${pkg}: ${name} typeof ${typeof arg} is not a number`);
    }
    if (!Number.isSafeInteger(arg)) {
        throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);
    }
    if (arg < 0) {
        throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);
    }
};
const validateCallback = (name, arg)=>{
    const type = typeof arg;
    if (type !== 'function') {
        throw new TypeError(`${pkg}: ${name} typeof ${type} is not a function`);
    }
};
// Compare items in two sequences to find a longest common subsequence.
// Given lengths of sequences and input function to compare items at indexes,
// return by output function the number of adjacent items and starting indexes
// of each common subsequence.
function diffSequence(aLength, bLength, isCommon, foundSubsequence) {
    validateLength('aLength', aLength);
    validateLength('bLength', bLength);
    validateCallback('isCommon', isCommon);
    validateCallback('foundSubsequence', foundSubsequence);
    // Count common items from the start in the forward direction.
    const nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);
    if (nCommonF !== 0) {
        foundSubsequence(nCommonF, 0, 0);
    }
    // Unless both sequences consist of common items only,
    // find common items in the half-trimmed index intervals.
    if (aLength !== nCommonF || bLength !== nCommonF) {
        // Invariant: intervals do not have common items at the start.
        // The start of an index interval is closed like array slice method.
        const aStart = nCommonF;
        const bStart = nCommonF;
        // Count common items from the end in the reverse direction.
        const nCommonR = countCommonItemsR(aStart, aLength - 1, bStart, bLength - 1, isCommon);
        // Invariant: intervals do not have common items at the end.
        // The end of an index interval is open like array slice method.
        const aEnd = aLength - nCommonR;
        const bEnd = bLength - nCommonR;
        // Unless one sequence consists of common items only,
        // therefore the other trimmed index interval consists of changes only,
        // find common items in the trimmed index intervals.
        const nCommonFR = nCommonF + nCommonR;
        if (aLength !== nCommonFR && bLength !== nCommonFR) {
            const nChange = 0; // number of change items is not yet known
            const transposed = false; // call the original unwrapped functions
            const callbacks = [
                {
                    foundSubsequence,
                    isCommon
                }
            ];
            // Indexes in sequence a of last points in furthest reaching paths
            // from outside the start at top left in the forward direction:
            const aIndexesF = [
                NOT_YET_SET
            ];
            // from the end at bottom right in the reverse direction:
            const aIndexesR = [
                NOT_YET_SET
            ];
            // Initialize one object as output of all calls to divide function.
            const division = {
                aCommonFollowing: NOT_YET_SET,
                aCommonPreceding: NOT_YET_SET,
                aEndPreceding: NOT_YET_SET,
                aStartFollowing: NOT_YET_SET,
                bCommonFollowing: NOT_YET_SET,
                bCommonPreceding: NOT_YET_SET,
                bEndPreceding: NOT_YET_SET,
                bStartFollowing: NOT_YET_SET,
                nChangeFollowing: NOT_YET_SET,
                nChangePreceding: NOT_YET_SET,
                nCommonFollowing: NOT_YET_SET,
                nCommonPreceding: NOT_YET_SET
            };
            // Find and return common subsequences in the trimmed index intervals.
            findSubsequences(nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division);
        }
        if (nCommonR !== 0) {
            foundSubsequence(nCommonR, aEnd, bEnd);
        }
    }
}
}),
"[project]/align/node_modules/fast-deep-equal/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// do not edit .js files directly - edit src/index.jst
module.exports = function equal(a, b) {
    if (a === b) return true;
    if (a && b && typeof a == 'object' && typeof b == 'object') {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
            length = a.length;
            if (length != b.length) return false;
            for(i = length; i-- !== 0;)if (!equal(a[i], b[i])) return false;
            return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for(i = length; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for(i = length; i-- !== 0;){
            var key = keys[i];
            if (!equal(a[key], b[key])) return false;
        }
        return true;
    }
    // true if both NaN, false otherwise
    return a !== a && b !== b;
};
}),
"[project]/align/node_modules/strip-ansi/node_modules/ansi-regex/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>ansiRegex
]);
function ansiRegex({ onlyFirst = false } = {}) {
    // Valid string terminator sequences are BEL, ESC\, and 0x9c
    const ST = '(?:\\u0007|\\u001B\\u005C|\\u009C)';
    // OSC sequences only: ESC ] ... ST (non-greedy until the first ST)
    const osc = `(?:\\u001B\\][\\s\\S]*?${ST})`;
    // CSI and related: ESC/C1, optional intermediates, optional params (supports ; and :) then final byte
    const csi = '[\\u001B\\u009B][[\\]()#;?]*(?:\\d{1,4}(?:[;:]\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]';
    const pattern = `${osc}|${csi}`;
    return new RegExp(pattern, onlyFirst ? undefined : 'g');
}
}),
"[project]/align/node_modules/strip-ansi/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>stripAnsi
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$strip$2d$ansi$2f$node_modules$2f$ansi$2d$regex$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/strip-ansi/node_modules/ansi-regex/index.js [app-route] (ecmascript)");
;
const regex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$strip$2d$ansi$2f$node_modules$2f$ansi$2d$regex$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])();
function stripAnsi(string) {
    if (typeof string !== 'string') {
        throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
    }
    // Even though the regex is global, we don't need to reset the `.lastIndex`
    // because unlike `.exec()` and `.test()`, `.replace()` does it automatically
    // and doing it manually has a performance penalty.
    return string.replace(regex, '');
}
}),
"[project]/align/node_modules/ansi-regex/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = ({ onlyFirst = false } = {})=>{
    const pattern = [
        '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
        '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
    ].join('|');
    return new RegExp(pattern, onlyFirst ? undefined : 'g');
};
}),
"[project]/align/node_modules/ansi-align/node_modules/strip-ansi/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const ansiRegex = __turbopack_context__.r("[project]/align/node_modules/ansi-regex/index.js [app-route] (ecmascript)");
module.exports = (string)=>typeof string === 'string' ? string.replace(ansiRegex(), '') : string;
}),
"[project]/align/node_modules/ansi-align/node_modules/emoji-regex/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function() {
    // https://mths.be/emoji
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
};
}),
"[project]/align/node_modules/ansi-align/node_modules/string-width/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const stripAnsi = __turbopack_context__.r("[project]/align/node_modules/ansi-align/node_modules/strip-ansi/index.js [app-route] (ecmascript)");
const isFullwidthCodePoint = __turbopack_context__.r("[project]/align/node_modules/is-fullwidth-code-point/index.js [app-route] (ecmascript)");
const emojiRegex = __turbopack_context__.r("[project]/align/node_modules/ansi-align/node_modules/emoji-regex/index.js [app-route] (ecmascript)");
const stringWidth = (string)=>{
    if (typeof string !== 'string' || string.length === 0) {
        return 0;
    }
    string = stripAnsi(string);
    if (string.length === 0) {
        return 0;
    }
    string = string.replace(emojiRegex(), '  ');
    let width = 0;
    for(let i = 0; i < string.length; i++){
        const code = string.codePointAt(i);
        // Ignore control characters
        if (code <= 0x1F || code >= 0x7F && code <= 0x9F) {
            continue;
        }
        // Ignore combining characters
        if (code >= 0x300 && code <= 0x36F) {
            continue;
        }
        // Surrogates
        if (code > 0xFFFF) {
            i++;
        }
        width += isFullwidthCodePoint(code) ? 2 : 1;
    }
    return width;
};
module.exports = stringWidth;
// TODO: remove this in the next major version
module.exports.default = stringWidth;
}),
"[project]/align/node_modules/ansi-align/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const stringWidth = __turbopack_context__.r("[project]/align/node_modules/ansi-align/node_modules/string-width/index.js [app-route] (ecmascript)");
function ansiAlign(text, opts) {
    if (!text) return text;
    opts = opts || {};
    const align = opts.align || 'center';
    // short-circuit `align: 'left'` as no-op
    if (align === 'left') return text;
    const split = opts.split || '\n';
    const pad = opts.pad || ' ';
    const widthDiffFn = align !== 'right' ? halfDiff : fullDiff;
    let returnString = false;
    if (!Array.isArray(text)) {
        returnString = true;
        text = String(text).split(split);
    }
    let width;
    let maxWidth = 0;
    text = text.map(function(str) {
        str = String(str);
        width = stringWidth(str);
        maxWidth = Math.max(width, maxWidth);
        return {
            str,
            width
        };
    }).map(function(obj) {
        return new Array(widthDiffFn(maxWidth, obj.width) + 1).join(pad) + obj.str;
    });
    return returnString ? text.join(split) : text;
}
ansiAlign.left = function left(text) {
    return ansiAlign(text, {
        align: 'left'
    });
};
ansiAlign.center = function center(text) {
    return ansiAlign(text, {
        align: 'center'
    });
};
ansiAlign.right = function right(text) {
    return ansiAlign(text, {
        align: 'right'
    });
};
module.exports = ansiAlign;
function halfDiff(maxWidth, curWidth) {
    return Math.floor((maxWidth - curWidth) / 2);
}
function fullDiff(maxWidth, curWidth) {
    return maxWidth - curWidth;
}
}),
"[project]/align/node_modules/get-east-asian-width/lookup.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getCategory",
    ()=>getCategory,
    "isAmbiguous",
    ()=>isAmbiguous,
    "isFullWidth",
    ()=>isFullWidth,
    "isWide",
    ()=>isWide
]);
// Generated code.
function isAmbiguous(x) {
    return x === 0xA1 || x === 0xA4 || x === 0xA7 || x === 0xA8 || x === 0xAA || x === 0xAD || x === 0xAE || x >= 0xB0 && x <= 0xB4 || x >= 0xB6 && x <= 0xBA || x >= 0xBC && x <= 0xBF || x === 0xC6 || x === 0xD0 || x === 0xD7 || x === 0xD8 || x >= 0xDE && x <= 0xE1 || x === 0xE6 || x >= 0xE8 && x <= 0xEA || x === 0xEC || x === 0xED || x === 0xF0 || x === 0xF2 || x === 0xF3 || x >= 0xF7 && x <= 0xFA || x === 0xFC || x === 0xFE || x === 0x101 || x === 0x111 || x === 0x113 || x === 0x11B || x === 0x126 || x === 0x127 || x === 0x12B || x >= 0x131 && x <= 0x133 || x === 0x138 || x >= 0x13F && x <= 0x142 || x === 0x144 || x >= 0x148 && x <= 0x14B || x === 0x14D || x === 0x152 || x === 0x153 || x === 0x166 || x === 0x167 || x === 0x16B || x === 0x1CE || x === 0x1D0 || x === 0x1D2 || x === 0x1D4 || x === 0x1D6 || x === 0x1D8 || x === 0x1DA || x === 0x1DC || x === 0x251 || x === 0x261 || x === 0x2C4 || x === 0x2C7 || x >= 0x2C9 && x <= 0x2CB || x === 0x2CD || x === 0x2D0 || x >= 0x2D8 && x <= 0x2DB || x === 0x2DD || x === 0x2DF || x >= 0x300 && x <= 0x36F || x >= 0x391 && x <= 0x3A1 || x >= 0x3A3 && x <= 0x3A9 || x >= 0x3B1 && x <= 0x3C1 || x >= 0x3C3 && x <= 0x3C9 || x === 0x401 || x >= 0x410 && x <= 0x44F || x === 0x451 || x === 0x2010 || x >= 0x2013 && x <= 0x2016 || x === 0x2018 || x === 0x2019 || x === 0x201C || x === 0x201D || x >= 0x2020 && x <= 0x2022 || x >= 0x2024 && x <= 0x2027 || x === 0x2030 || x === 0x2032 || x === 0x2033 || x === 0x2035 || x === 0x203B || x === 0x203E || x === 0x2074 || x === 0x207F || x >= 0x2081 && x <= 0x2084 || x === 0x20AC || x === 0x2103 || x === 0x2105 || x === 0x2109 || x === 0x2113 || x === 0x2116 || x === 0x2121 || x === 0x2122 || x === 0x2126 || x === 0x212B || x === 0x2153 || x === 0x2154 || x >= 0x215B && x <= 0x215E || x >= 0x2160 && x <= 0x216B || x >= 0x2170 && x <= 0x2179 || x === 0x2189 || x >= 0x2190 && x <= 0x2199 || x === 0x21B8 || x === 0x21B9 || x === 0x21D2 || x === 0x21D4 || x === 0x21E7 || x === 0x2200 || x === 0x2202 || x === 0x2203 || x === 0x2207 || x === 0x2208 || x === 0x220B || x === 0x220F || x === 0x2211 || x === 0x2215 || x === 0x221A || x >= 0x221D && x <= 0x2220 || x === 0x2223 || x === 0x2225 || x >= 0x2227 && x <= 0x222C || x === 0x222E || x >= 0x2234 && x <= 0x2237 || x === 0x223C || x === 0x223D || x === 0x2248 || x === 0x224C || x === 0x2252 || x === 0x2260 || x === 0x2261 || x >= 0x2264 && x <= 0x2267 || x === 0x226A || x === 0x226B || x === 0x226E || x === 0x226F || x === 0x2282 || x === 0x2283 || x === 0x2286 || x === 0x2287 || x === 0x2295 || x === 0x2299 || x === 0x22A5 || x === 0x22BF || x === 0x2312 || x >= 0x2460 && x <= 0x24E9 || x >= 0x24EB && x <= 0x254B || x >= 0x2550 && x <= 0x2573 || x >= 0x2580 && x <= 0x258F || x >= 0x2592 && x <= 0x2595 || x === 0x25A0 || x === 0x25A1 || x >= 0x25A3 && x <= 0x25A9 || x === 0x25B2 || x === 0x25B3 || x === 0x25B6 || x === 0x25B7 || x === 0x25BC || x === 0x25BD || x === 0x25C0 || x === 0x25C1 || x >= 0x25C6 && x <= 0x25C8 || x === 0x25CB || x >= 0x25CE && x <= 0x25D1 || x >= 0x25E2 && x <= 0x25E5 || x === 0x25EF || x === 0x2605 || x === 0x2606 || x === 0x2609 || x === 0x260E || x === 0x260F || x === 0x261C || x === 0x261E || x === 0x2640 || x === 0x2642 || x === 0x2660 || x === 0x2661 || x >= 0x2663 && x <= 0x2665 || x >= 0x2667 && x <= 0x266A || x === 0x266C || x === 0x266D || x === 0x266F || x === 0x269E || x === 0x269F || x === 0x26BF || x >= 0x26C6 && x <= 0x26CD || x >= 0x26CF && x <= 0x26D3 || x >= 0x26D5 && x <= 0x26E1 || x === 0x26E3 || x === 0x26E8 || x === 0x26E9 || x >= 0x26EB && x <= 0x26F1 || x === 0x26F4 || x >= 0x26F6 && x <= 0x26F9 || x === 0x26FB || x === 0x26FC || x === 0x26FE || x === 0x26FF || x === 0x273D || x >= 0x2776 && x <= 0x277F || x >= 0x2B56 && x <= 0x2B59 || x >= 0x3248 && x <= 0x324F || x >= 0xE000 && x <= 0xF8FF || x >= 0xFE00 && x <= 0xFE0F || x === 0xFFFD || x >= 0x1F100 && x <= 0x1F10A || x >= 0x1F110 && x <= 0x1F12D || x >= 0x1F130 && x <= 0x1F169 || x >= 0x1F170 && x <= 0x1F18D || x === 0x1F18F || x === 0x1F190 || x >= 0x1F19B && x <= 0x1F1AC || x >= 0xE0100 && x <= 0xE01EF || x >= 0xF0000 && x <= 0xFFFFD || x >= 0x100000 && x <= 0x10FFFD;
}
function isFullWidth(x) {
    return x === 0x3000 || x >= 0xFF01 && x <= 0xFF60 || x >= 0xFFE0 && x <= 0xFFE6;
}
function isWide(x) {
    return x >= 0x1100 && x <= 0x115F || x === 0x231A || x === 0x231B || x === 0x2329 || x === 0x232A || x >= 0x23E9 && x <= 0x23EC || x === 0x23F0 || x === 0x23F3 || x === 0x25FD || x === 0x25FE || x === 0x2614 || x === 0x2615 || x >= 0x2630 && x <= 0x2637 || x >= 0x2648 && x <= 0x2653 || x === 0x267F || x >= 0x268A && x <= 0x268F || x === 0x2693 || x === 0x26A1 || x === 0x26AA || x === 0x26AB || x === 0x26BD || x === 0x26BE || x === 0x26C4 || x === 0x26C5 || x === 0x26CE || x === 0x26D4 || x === 0x26EA || x === 0x26F2 || x === 0x26F3 || x === 0x26F5 || x === 0x26FA || x === 0x26FD || x === 0x2705 || x === 0x270A || x === 0x270B || x === 0x2728 || x === 0x274C || x === 0x274E || x >= 0x2753 && x <= 0x2755 || x === 0x2757 || x >= 0x2795 && x <= 0x2797 || x === 0x27B0 || x === 0x27BF || x === 0x2B1B || x === 0x2B1C || x === 0x2B50 || x === 0x2B55 || x >= 0x2E80 && x <= 0x2E99 || x >= 0x2E9B && x <= 0x2EF3 || x >= 0x2F00 && x <= 0x2FD5 || x >= 0x2FF0 && x <= 0x2FFF || x >= 0x3001 && x <= 0x303E || x >= 0x3041 && x <= 0x3096 || x >= 0x3099 && x <= 0x30FF || x >= 0x3105 && x <= 0x312F || x >= 0x3131 && x <= 0x318E || x >= 0x3190 && x <= 0x31E5 || x >= 0x31EF && x <= 0x321E || x >= 0x3220 && x <= 0x3247 || x >= 0x3250 && x <= 0xA48C || x >= 0xA490 && x <= 0xA4C6 || x >= 0xA960 && x <= 0xA97C || x >= 0xAC00 && x <= 0xD7A3 || x >= 0xF900 && x <= 0xFAFF || x >= 0xFE10 && x <= 0xFE19 || x >= 0xFE30 && x <= 0xFE52 || x >= 0xFE54 && x <= 0xFE66 || x >= 0xFE68 && x <= 0xFE6B || x >= 0x16FE0 && x <= 0x16FE4 || x >= 0x16FF0 && x <= 0x16FF6 || x >= 0x17000 && x <= 0x18CD5 || x >= 0x18CFF && x <= 0x18D1E || x >= 0x18D80 && x <= 0x18DF2 || x >= 0x1AFF0 && x <= 0x1AFF3 || x >= 0x1AFF5 && x <= 0x1AFFB || x === 0x1AFFD || x === 0x1AFFE || x >= 0x1B000 && x <= 0x1B122 || x === 0x1B132 || x >= 0x1B150 && x <= 0x1B152 || x === 0x1B155 || x >= 0x1B164 && x <= 0x1B167 || x >= 0x1B170 && x <= 0x1B2FB || x >= 0x1D300 && x <= 0x1D356 || x >= 0x1D360 && x <= 0x1D376 || x === 0x1F004 || x === 0x1F0CF || x === 0x1F18E || x >= 0x1F191 && x <= 0x1F19A || x >= 0x1F200 && x <= 0x1F202 || x >= 0x1F210 && x <= 0x1F23B || x >= 0x1F240 && x <= 0x1F248 || x === 0x1F250 || x === 0x1F251 || x >= 0x1F260 && x <= 0x1F265 || x >= 0x1F300 && x <= 0x1F320 || x >= 0x1F32D && x <= 0x1F335 || x >= 0x1F337 && x <= 0x1F37C || x >= 0x1F37E && x <= 0x1F393 || x >= 0x1F3A0 && x <= 0x1F3CA || x >= 0x1F3CF && x <= 0x1F3D3 || x >= 0x1F3E0 && x <= 0x1F3F0 || x === 0x1F3F4 || x >= 0x1F3F8 && x <= 0x1F43E || x === 0x1F440 || x >= 0x1F442 && x <= 0x1F4FC || x >= 0x1F4FF && x <= 0x1F53D || x >= 0x1F54B && x <= 0x1F54E || x >= 0x1F550 && x <= 0x1F567 || x === 0x1F57A || x === 0x1F595 || x === 0x1F596 || x === 0x1F5A4 || x >= 0x1F5FB && x <= 0x1F64F || x >= 0x1F680 && x <= 0x1F6C5 || x === 0x1F6CC || x >= 0x1F6D0 && x <= 0x1F6D2 || x >= 0x1F6D5 && x <= 0x1F6D8 || x >= 0x1F6DC && x <= 0x1F6DF || x === 0x1F6EB || x === 0x1F6EC || x >= 0x1F6F4 && x <= 0x1F6FC || x >= 0x1F7E0 && x <= 0x1F7EB || x === 0x1F7F0 || x >= 0x1F90C && x <= 0x1F93A || x >= 0x1F93C && x <= 0x1F945 || x >= 0x1F947 && x <= 0x1F9FF || x >= 0x1FA70 && x <= 0x1FA7C || x >= 0x1FA80 && x <= 0x1FA8A || x >= 0x1FA8E && x <= 0x1FAC6 || x === 0x1FAC8 || x >= 0x1FACD && x <= 0x1FADC || x >= 0x1FADF && x <= 0x1FAEA || x >= 0x1FAEF && x <= 0x1FAF8 || x >= 0x20000 && x <= 0x2FFFD || x >= 0x30000 && x <= 0x3FFFD;
}
function getCategory(x) {
    if (isAmbiguous(x)) return 'ambiguous';
    if (isFullWidth(x)) return 'fullwidth';
    if (x === 0x20A9 || x >= 0xFF61 && x <= 0xFFBE || x >= 0xFFC2 && x <= 0xFFC7 || x >= 0xFFCA && x <= 0xFFCF || x >= 0xFFD2 && x <= 0xFFD7 || x >= 0xFFDA && x <= 0xFFDC || x >= 0xFFE8 && x <= 0xFFEE) {
        return 'halfwidth';
    }
    if (x >= 0x20 && x <= 0x7E || x === 0xA2 || x === 0xA3 || x === 0xA5 || x === 0xA6 || x === 0xAC || x === 0xAF || x >= 0x27E6 && x <= 0x27ED || x === 0x2985 || x === 0x2986) {
        return 'narrow';
    }
    if (isWide(x)) return 'wide';
    return 'neutral';
}
;
}),
"[project]/align/node_modules/get-east-asian-width/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "eastAsianWidth",
    ()=>eastAsianWidth,
    "eastAsianWidthType",
    ()=>eastAsianWidthType
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$get$2d$east$2d$asian$2d$width$2f$lookup$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/get-east-asian-width/lookup.js [app-route] (ecmascript)");
;
function validate(codePoint) {
    if (!Number.isSafeInteger(codePoint)) {
        throw new TypeError(`Expected a code point, got \`${typeof codePoint}\`.`);
    }
}
function eastAsianWidthType(codePoint) {
    validate(codePoint);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$get$2d$east$2d$asian$2d$width$2f$lookup$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCategory"])(codePoint);
}
function eastAsianWidth(codePoint, { ambiguousAsWide = false } = {}) {
    validate(codePoint);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$get$2d$east$2d$asian$2d$width$2f$lookup$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isFullWidth"])(codePoint) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$get$2d$east$2d$asian$2d$width$2f$lookup$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isWide"])(codePoint) || ambiguousAsWide && (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$get$2d$east$2d$asian$2d$width$2f$lookup$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isAmbiguous"])(codePoint)) {
        return 2;
    }
    return 1;
}
;
}),
"[project]/align/node_modules/string-width/node_modules/emoji-regex/index.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
const __TURBOPACK__default__export__ = ()=>{
    // https://mths.be/emoji
    return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E-\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED8\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])))?))?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3C-\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE8A\uDE8E-\uDEC2\uDEC6\uDEC8\uDECD-\uDEDC\uDEDF-\uDEEA\uDEEF]|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
};
}),
"[project]/align/node_modules/string-width/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>stringWidth
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$strip$2d$ansi$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/strip-ansi/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$get$2d$east$2d$asian$2d$width$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/align/node_modules/get-east-asian-width/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$string$2d$width$2f$node_modules$2f$emoji$2d$regex$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/string-width/node_modules/emoji-regex/index.mjs [app-route] (ecmascript)");
;
;
;
const segmenter = new Intl.Segmenter();
const defaultIgnorableCodePointRegex = /^\p{Default_Ignorable_Code_Point}$/u;
function stringWidth(string, options = {}) {
    if (typeof string !== 'string' || string.length === 0) {
        return 0;
    }
    const { ambiguousIsNarrow = true, countAnsiEscapeCodes = false } = options;
    if (!countAnsiEscapeCodes) {
        string = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$strip$2d$ansi$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(string);
    }
    if (string.length === 0) {
        return 0;
    }
    let width = 0;
    const eastAsianWidthOptions = {
        ambiguousAsWide: !ambiguousIsNarrow
    };
    for (const { segment: character } of segmenter.segment(string)){
        const codePoint = character.codePointAt(0);
        // Ignore control characters
        if (codePoint <= 0x1F || codePoint >= 0x7F && codePoint <= 0x9F) {
            continue;
        }
        // Ignore zero-width characters
        if (codePoint >= 0x20_0B && codePoint <= 0x20_0F || codePoint === 0xFE_FF // Zero-width no-break space
        ) {
            continue;
        }
        // Ignore combining characters
        if (codePoint >= 0x3_00 && codePoint <= 0x3_6F || codePoint >= 0x1A_B0 && codePoint <= 0x1A_FF || codePoint >= 0x1D_C0 && codePoint <= 0x1D_FF || codePoint >= 0x20_D0 && codePoint <= 0x20_FF || codePoint >= 0xFE_20 && codePoint <= 0xFE_2F // Combining half marks
        ) {
            continue;
        }
        // Ignore surrogate pairs
        if (codePoint >= 0xD8_00 && codePoint <= 0xDF_FF) {
            continue;
        }
        // Ignore variation selectors
        if (codePoint >= 0xFE_00 && codePoint <= 0xFE_0F) {
            continue;
        }
        // This covers some of the above cases, but we still keep them for performance reasons.
        if (defaultIgnorableCodePointRegex.test(character)) {
            continue;
        }
        // TODO: Use `/\p{RGI_Emoji}/v` when targeting Node.js 20.
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$string$2d$width$2f$node_modules$2f$emoji$2d$regex$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])().test(character)) {
            width += 2;
            continue;
        }
        width += (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$get$2d$east$2d$asian$2d$width$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["eastAsianWidth"])(codePoint, eastAsianWidthOptions);
    }
    return width;
}
}),
"[project]/align/node_modules/widest-line/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>widestLine
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$string$2d$width$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/string-width/index.js [app-route] (ecmascript)");
;
function widestLine(string) {
    let lineWidth = 0;
    for (const line of string.split('\n')){
        lineWidth = Math.max(lineWidth, (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$string$2d$width$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(line));
    }
    return lineWidth;
}
}),
"[project]/align/node_modules/cli-boxes/boxes.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"single":{"topLeft":"","top":"","topRight":"","right":"","bottomRight":"","bottom":"","bottomLeft":"","left":""},"double":{"topLeft":"","top":"","topRight":"","right":"","bottomRight":"","bottom":"","bottomLeft":"","left":""},"round":{"topLeft":"","top":"","topRight":"","right":"","bottomRight":"","bottom":"","bottomLeft":"","left":""},"bold":{"topLeft":"","top":"","topRight":"","right":"","bottomRight":"","bottom":"","bottomLeft":"","left":""},"singleDouble":{"topLeft":"","top":"","topRight":"","right":"","bottomRight":"","bottom":"","bottomLeft":"","left":""},"doubleSingle":{"topLeft":"","top":"","topRight":"","right":"","bottomRight":"","bottom":"","bottomLeft":"","left":""},"classic":{"topLeft":"+","top":"-","topRight":"+","right":"|","bottomRight":"+","bottom":"-","bottomLeft":"+","left":"|"},"arrow":{"topLeft":"","top":"","topRight":"","right":"","bottomRight":"","bottom":"","bottomLeft":"","left":""}});}),
"[project]/align/node_modules/cli-boxes/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const cliBoxes = __turbopack_context__.r("[project]/align/node_modules/cli-boxes/boxes.json (json)");
module.exports = cliBoxes;
// TODO: Remove this for the next major release
module.exports.default = cliBoxes;
}),
"[project]/align/node_modules/camelcase/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>camelCase
]);
const UPPERCASE = /[\p{Lu}]/u;
const LOWERCASE = /[\p{Ll}]/u;
const LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
const IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
const SEPARATORS = /[_.\- ]+/;
const LEADING_SEPARATORS = new RegExp('^' + SEPARATORS.source);
const SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, 'gu');
const NUMBERS_AND_IDENTIFIER = new RegExp('\\d+' + IDENTIFIER.source, 'gu');
const preserveCamelCase = (string, toLowerCase, toUpperCase, preserveConsecutiveUppercase)=>{
    let isLastCharLower = false;
    let isLastCharUpper = false;
    let isLastLastCharUpper = false;
    let isLastLastCharPreserved = false;
    for(let index = 0; index < string.length; index++){
        const character = string[index];
        isLastLastCharPreserved = index > 2 ? string[index - 3] === '-' : true;
        if (isLastCharLower && UPPERCASE.test(character)) {
            string = string.slice(0, index) + '-' + string.slice(index);
            isLastCharLower = false;
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = true;
            index++;
        } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character) && (!isLastLastCharPreserved || preserveConsecutiveUppercase)) {
            string = string.slice(0, index - 1) + '-' + string.slice(index - 1);
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = false;
            isLastCharLower = true;
        } else {
            isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
        }
    }
    return string;
};
const preserveConsecutiveUppercase = (input, toLowerCase)=>{
    LEADING_CAPITAL.lastIndex = 0;
    return input.replaceAll(LEADING_CAPITAL, (match)=>toLowerCase(match));
};
const postProcess = (input, toUpperCase)=>{
    SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
    NUMBERS_AND_IDENTIFIER.lastIndex = 0;
    return input.replaceAll(NUMBERS_AND_IDENTIFIER, (match, pattern, offset)=>[
            '_',
            '-'
        ].includes(input.charAt(offset + match.length)) ? match : toUpperCase(match)).replaceAll(SEPARATORS_AND_IDENTIFIER, (_, identifier)=>toUpperCase(identifier));
};
function camelCase(input, options) {
    if (!(typeof input === 'string' || Array.isArray(input))) {
        throw new TypeError('Expected the input to be `string | string[]`');
    }
    options = {
        pascalCase: false,
        preserveConsecutiveUppercase: false,
        ...options
    };
    if (Array.isArray(input)) {
        input = input.map((x)=>x.trim()).filter((x)=>x.length).join('-');
    } else {
        input = input.trim();
    }
    if (input.length === 0) {
        return '';
    }
    const toLowerCase = options.locale === false ? (string)=>string.toLowerCase() : (string)=>string.toLocaleLowerCase(options.locale);
    const toUpperCase = options.locale === false ? (string)=>string.toUpperCase() : (string)=>string.toLocaleUpperCase(options.locale);
    if (input.length === 1) {
        if (SEPARATORS.test(input)) {
            return '';
        }
        return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
    }
    const hasUpperCase = input !== toLowerCase(input);
    if (hasUpperCase) {
        input = preserveCamelCase(input, toLowerCase, toUpperCase, options.preserveConsecutiveUppercase);
    }
    input = input.replace(LEADING_SEPARATORS, '');
    input = options.preserveConsecutiveUppercase ? preserveConsecutiveUppercase(input, toLowerCase) : toLowerCase(input);
    if (options.pascalCase) {
        input = toUpperCase(input.charAt(0)) + input.slice(1);
    }
    return postProcess(input, toUpperCase);
}
}),
"[project]/align/node_modules/is-fullwidth-code-point/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint-disable yoda */ const isFullwidthCodePoint = (codePoint)=>{
    if (Number.isNaN(codePoint)) {
        return false;
    }
    // Code points are derived from:
    // http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt
    if (codePoint >= 0x1100 && (codePoint <= 0x115F || // Hangul Jamo
    codePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET
    codePoint === 0x232A || 0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F || 0x3250 <= codePoint && codePoint <= 0x4DBF || 0x4E00 <= codePoint && codePoint <= 0xA4C6 || 0xA960 <= codePoint && codePoint <= 0xA97C || 0xAC00 <= codePoint && codePoint <= 0xD7A3 || 0xF900 <= codePoint && codePoint <= 0xFAFF || 0xFE10 <= codePoint && codePoint <= 0xFE19 || 0xFE30 <= codePoint && codePoint <= 0xFE6B || 0xFF01 <= codePoint && codePoint <= 0xFF60 || 0xFFE0 <= codePoint && codePoint <= 0xFFE6 || 0x1B000 <= codePoint && codePoint <= 0x1B001 || 0x1F200 <= codePoint && codePoint <= 0x1F251 || 0x20000 <= codePoint && codePoint <= 0x3FFFD)) {
        return true;
    }
    return false;
};
module.exports = isFullwidthCodePoint;
module.exports.default = isFullwidthCodePoint;
}),
"[project]/align/node_modules/mimic-function/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>mimicFunction
]);
const copyProperty = (to, from, property, ignoreNonConfigurable)=>{
    // `Function#length` should reflect the parameters of `to` not `from` since we keep its body.
    // `Function#prototype` is non-writable and non-configurable so can never be modified.
    if (property === 'length' || property === 'prototype') {
        return;
    }
    // `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.
    if (property === 'arguments' || property === 'caller') {
        return;
    }
    const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
    const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
    if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
        return;
    }
    Object.defineProperty(to, property, fromDescriptor);
};
// `Object.defineProperty()` throws if the property exists, is not configurable and either:
// - one its descriptors is changed
// - it is non-writable and its value is changed
const canCopyProperty = function(toDescriptor, fromDescriptor) {
    return toDescriptor === undefined || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
const changePrototype = (to, from)=>{
    const fromPrototype = Object.getPrototypeOf(from);
    if (fromPrototype === Object.getPrototypeOf(to)) {
        return;
    }
    Object.setPrototypeOf(to, fromPrototype);
};
const wrappedToString = (withName, fromBody)=>`/* Wrapped ${withName}*/\n${fromBody}`;
const toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');
const toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');
// We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.
// We use `bind()` instead of a closure for the same reason.
// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.
const changeToString = (to, from, name)=>{
    const withName = name === '' ? '' : `with ${name.trim()}() `;
    const newToString = wrappedToString.bind(null, withName, from.toString());
    // Ensure `to.toString.toString` is non-enumerable and has the same `same`
    Object.defineProperty(newToString, 'name', toStringName);
    const { writable, enumerable, configurable } = toStringDescriptor; // We destructue to avoid a potential `get` descriptor.
    Object.defineProperty(to, 'toString', {
        value: newToString,
        writable,
        enumerable,
        configurable
    });
};
function mimicFunction(to, from, { ignoreNonConfigurable = false } = {}) {
    const { name } = to;
    for (const property of Reflect.ownKeys(from)){
        copyProperty(to, from, property, ignoreNonConfigurable);
    }
    changePrototype(to, from);
    changeToString(to, from, name);
    return to;
}
}),
"[project]/align/node_modules/onetime/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$mimic$2d$function$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/mimic-function/index.js [app-route] (ecmascript)");
;
const calledFunctions = new WeakMap();
const onetime = (function_, options = {})=>{
    if (typeof function_ !== 'function') {
        throw new TypeError('Expected a function');
    }
    let returnValue;
    let callCount = 0;
    const functionName = function_.displayName || function_.name || '<anonymous>';
    const onetime = function(...arguments_) {
        calledFunctions.set(onetime, ++callCount);
        if (callCount === 1) {
            returnValue = function_.apply(this, arguments_);
            function_ = undefined;
        } else if (options.throw === true) {
            throw new Error(`Function \`${functionName}\` can only be called once`);
        }
        return returnValue;
    };
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$mimic$2d$function$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(onetime, function_);
    calledFunctions.set(onetime, callCount);
    return onetime;
};
onetime.callCount = (function_)=>{
    if (!calledFunctions.has(function_)) {
        throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
    }
    return calledFunctions.get(function_);
};
const __TURBOPACK__default__export__ = onetime;
}),
"[project]/align/node_modules/signal-exit/dist/mjs/signals.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * This is not the set of all possible signals.
 *
 * It IS, however, the set of all signals that trigger
 * an exit on either Linux or BSD systems.  Linux is a
 * superset of the signal names supported on BSD, and
 * the unknown signals just fail to register, so we can
 * catch that easily enough.
 *
 * Windows signals are a different set, since there are
 * signals that terminate Windows processes, but don't
 * terminate (or don't even exist) on Posix systems.
 *
 * Don't bother with SIGKILL.  It's uncatchable, which
 * means that we can't fire any callbacks anyway.
 *
 * If a user does happen to register a handler on a non-
 * fatal signal like SIGWINCH or something, and then
 * exit, it'll end up firing `process.emit('exit')`, so
 * the handler will be fired anyway.
 *
 * SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
 * artificially, inherently leave the process in a
 * state from which it is not safe to try and enter JS
 * listeners.
 */ __turbopack_context__.s([
    "signals",
    ()=>signals
]);
const signals = [];
signals.push('SIGHUP', 'SIGINT', 'SIGTERM');
if ("TURBOPACK compile-time truthy", 1) {
    signals.push('SIGALRM', 'SIGABRT', 'SIGVTALRM', 'SIGXCPU', 'SIGXFSZ', 'SIGUSR2', 'SIGTRAP', 'SIGSYS', 'SIGQUIT', 'SIGIOT');
}
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
 //# sourceMappingURL=signals.js.map
}),
"[project]/align/node_modules/signal-exit/dist/mjs/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "load",
    ()=>load,
    "onExit",
    ()=>onExit,
    "unload",
    ()=>unload
]);
// Note: since nyc uses this module to output coverage, any lines
// that are in the direct sync flow of nyc's outputCoverage are
// ignored, since we can never get coverage for them.
// grab a reference to node's real process object right away
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$signal$2d$exit$2f$dist$2f$mjs$2f$signals$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/signal-exit/dist/mjs/signals.js [app-route] (ecmascript)");
;
;
const processOk = (process)=>!!process && typeof process === 'object' && typeof process.removeListener === 'function' && typeof process.emit === 'function' && typeof process.reallyExit === 'function' && typeof process.listeners === 'function' && typeof process.kill === 'function' && typeof process.pid === 'number' && typeof process.on === 'function';
const kExitEmitter = Symbol.for('signal-exit emitter');
const global = globalThis;
const ObjectDefineProperty = Object.defineProperty.bind(Object);
// teeny special purpose ee
class Emitter {
    emitted = {
        afterExit: false,
        exit: false
    };
    listeners = {
        afterExit: [],
        exit: []
    };
    count = 0;
    id = Math.random();
    constructor(){
        if (global[kExitEmitter]) {
            return global[kExitEmitter];
        }
        ObjectDefineProperty(global, kExitEmitter, {
            value: this,
            writable: false,
            enumerable: false,
            configurable: false
        });
    }
    on(ev, fn) {
        this.listeners[ev].push(fn);
    }
    removeListener(ev, fn) {
        const list = this.listeners[ev];
        const i = list.indexOf(fn);
        /* c8 ignore start */ if (i === -1) {
            return;
        }
        /* c8 ignore stop */ if (i === 0 && list.length === 1) {
            list.length = 0;
        } else {
            list.splice(i, 1);
        }
    }
    emit(ev, code, signal) {
        if (this.emitted[ev]) {
            return false;
        }
        this.emitted[ev] = true;
        let ret = false;
        for (const fn of this.listeners[ev]){
            ret = fn(code, signal) === true || ret;
        }
        if (ev === 'exit') {
            ret = this.emit('afterExit', code, signal) || ret;
        }
        return ret;
    }
}
class SignalExitBase {
}
const signalExitWrap = (handler)=>{
    return {
        onExit (cb, opts) {
            return handler.onExit(cb, opts);
        },
        load () {
            return handler.load();
        },
        unload () {
            return handler.unload();
        }
    };
};
class SignalExitFallback extends SignalExitBase {
    onExit() {
        return ()=>{};
    }
    load() {}
    unload() {}
}
class SignalExit extends SignalExitBase {
    // "SIGHUP" throws an `ENOSYS` error on Windows,
    // so use a supported signal instead
    /* c8 ignore start */ #hupSig = process.platform === 'win32' ? 'SIGINT' : 'SIGHUP';
    /* c8 ignore stop */ #emitter = new Emitter();
    #process;
    #originalProcessEmit;
    #originalProcessReallyExit;
    #sigListeners = {};
    #loaded = false;
    constructor(process){
        super();
        this.#process = process;
        // { <signal>: <listener fn>, ... }
        this.#sigListeners = {};
        for (const sig of __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$signal$2d$exit$2f$dist$2f$mjs$2f$signals$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["signals"]){
            this.#sigListeners[sig] = ()=>{
                // If there are no other listeners, an exit is coming!
                // Simplest way: remove us and then re-send the signal.
                // We know that this will kill the process, so we can
                // safely emit now.
                const listeners = this.#process.listeners(sig);
                let { count } = this.#emitter;
                // This is a workaround for the fact that signal-exit v3 and signal
                // exit v4 are not aware of each other, and each will attempt to let
                // the other handle it, so neither of them do. To correct this, we
                // detect if we're the only handler *except* for previous versions
                // of signal-exit, and increment by the count of listeners it has
                // created.
                /* c8 ignore start */ const p = process;
                if (typeof p.__signal_exit_emitter__ === 'object' && typeof p.__signal_exit_emitter__.count === 'number') {
                    count += p.__signal_exit_emitter__.count;
                }
                /* c8 ignore stop */ if (listeners.length === count) {
                    this.unload();
                    const ret = this.#emitter.emit('exit', null, sig);
                    /* c8 ignore start */ const s = sig === 'SIGHUP' ? this.#hupSig : sig;
                    if (!ret) process.kill(process.pid, s);
                /* c8 ignore stop */ }
            };
        }
        this.#originalProcessReallyExit = process.reallyExit;
        this.#originalProcessEmit = process.emit;
    }
    onExit(cb, opts) {
        /* c8 ignore start */ if (!processOk(this.#process)) {
            return ()=>{};
        }
        /* c8 ignore stop */ if (this.#loaded === false) {
            this.load();
        }
        const ev = opts?.alwaysLast ? 'afterExit' : 'exit';
        this.#emitter.on(ev, cb);
        return ()=>{
            this.#emitter.removeListener(ev, cb);
            if (this.#emitter.listeners['exit'].length === 0 && this.#emitter.listeners['afterExit'].length === 0) {
                this.unload();
            }
        };
    }
    load() {
        if (this.#loaded) {
            return;
        }
        this.#loaded = true;
        // This is the number of onSignalExit's that are in play.
        // It's important so that we can count the correct number of
        // listeners on signals, and don't wait for the other one to
        // handle it instead of us.
        this.#emitter.count += 1;
        for (const sig of __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$signal$2d$exit$2f$dist$2f$mjs$2f$signals$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["signals"]){
            try {
                const fn = this.#sigListeners[sig];
                if (fn) this.#process.on(sig, fn);
            } catch (_) {}
        }
        this.#process.emit = (ev, ...a)=>{
            return this.#processEmit(ev, ...a);
        };
        this.#process.reallyExit = (code)=>{
            return this.#processReallyExit(code);
        };
    }
    unload() {
        if (!this.#loaded) {
            return;
        }
        this.#loaded = false;
        __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$signal$2d$exit$2f$dist$2f$mjs$2f$signals$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["signals"].forEach((sig)=>{
            const listener = this.#sigListeners[sig];
            /* c8 ignore start */ if (!listener) {
                throw new Error('Listener not defined for signal: ' + sig);
            }
            /* c8 ignore stop */ try {
                this.#process.removeListener(sig, listener);
            /* c8 ignore start */ } catch (_) {}
        /* c8 ignore stop */ });
        this.#process.emit = this.#originalProcessEmit;
        this.#process.reallyExit = this.#originalProcessReallyExit;
        this.#emitter.count -= 1;
    }
    #processReallyExit(code) {
        /* c8 ignore start */ if (!processOk(this.#process)) {
            return 0;
        }
        this.#process.exitCode = code || 0;
        /* c8 ignore stop */ this.#emitter.emit('exit', this.#process.exitCode, null);
        return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
    }
    #processEmit(ev, ...args) {
        const og = this.#originalProcessEmit;
        if (ev === 'exit' && processOk(this.#process)) {
            if (typeof args[0] === 'number') {
                this.#process.exitCode = args[0];
            /* c8 ignore start */ }
            /* c8 ignore start */ const ret = og.call(this.#process, ev, ...args);
            /* c8 ignore start */ this.#emitter.emit('exit', this.#process.exitCode, null);
            /* c8 ignore stop */ return ret;
        } else {
            return og.call(this.#process, ev, ...args);
        }
    }
}
const process = globalThis.process;
const { /**
 * Called when the process is exiting, whether via signal, explicit
 * exit, or running out of stuff to do.
 *
 * If the global process object is not suitable for instrumentation,
 * then this will be a no-op.
 *
 * Returns a function that may be used to unload signal-exit.
 */ onExit, /**
 * Load the listeners.  Likely you never need to call this, unless
 * doing a rather deep integration with signal-exit functionality.
 * Mostly exposed for the benefit of testing.
 *
 * @internal
 */ load, /**
 * Unload the listeners.  Likely you never need to call this, unless
 * doing a rather deep integration with signal-exit functionality.
 * Mostly exposed for the benefit of testing.
 *
 * @internal
 */ unload } = signalExitWrap(processOk(process) ? new SignalExit(process) : new SignalExitFallback()); //# sourceMappingURL=index.js.map
}),
"[project]/align/node_modules/restore-cursor/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$onetime$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/onetime/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$signal$2d$exit$2f$dist$2f$mjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/align/node_modules/signal-exit/dist/mjs/index.js [app-route] (ecmascript) <locals>");
;
;
;
const terminal = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stderr.isTTY ? __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stderr : __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stdout.isTTY ? __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stdout : undefined;
const restoreCursor = terminal ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$onetime$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(()=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$signal$2d$exit$2f$dist$2f$mjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["onExit"])(()=>{
        terminal.write('\u001B[?25h');
    }, {
        alwaysLast: true
    });
}) : ()=>{};
const __TURBOPACK__default__export__ = restoreCursor;
}),
"[project]/align/node_modules/cli-cursor/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$restore$2d$cursor$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/restore-cursor/index.js [app-route] (ecmascript)");
;
;
let isHidden = false;
const cliCursor = {};
cliCursor.show = (writableStream = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stderr)=>{
    if (!writableStream.isTTY) {
        return;
    }
    isHidden = false;
    writableStream.write('\u001B[?25h');
};
cliCursor.hide = (writableStream = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stderr)=>{
    if (!writableStream.isTTY) {
        return;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$restore$2d$cursor$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])();
    isHidden = true;
    writableStream.write('\u001B[?25l');
};
cliCursor.toggle = (force, writableStream)=>{
    if (force !== undefined) {
        isHidden = force;
    }
    if (isHidden) {
        cliCursor.show(writableStream);
    } else {
        cliCursor.hide(writableStream);
    }
};
const __TURBOPACK__default__export__ = cliCursor;
}),
"[project]/align/node_modules/cli-spinners/spinners.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v(JSON.parse("{\"dots\":{\"interval\":80,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]},\"dots2\":{\"interval\":80,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]},\"dots3\":{\"interval\":80,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]},\"dots4\":{\"interval\":80,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]},\"dots5\":{\"interval\":80,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]},\"dots6\":{\"interval\":80,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]},\"dots7\":{\"interval\":80,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]},\"dots8\":{\"interval\":80,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]},\"dots9\":{\"interval\":80,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]},\"dots10\":{\"interval\":80,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\"]},\"dots11\":{\"interval\":100,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]},\"dots12\":{\"interval\":80,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]},\"dots13\":{\"interval\":80,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]},\"dots8Bit\":{\"interval\":80,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]},\"sand\":{\"interval\":80,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]},\"line\":{\"interval\":130,\"frames\":[\"-\",\"\\\\\",\"|\",\"/\"]},\"line2\":{\"interval\":100,\"frames\":[\"\",\"-\",\"\",\"\",\"\",\"-\"]},\"pipe\":{\"interval\":100,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]},\"simpleDots\":{\"interval\":400,\"frames\":[\".  \",\".. \",\"...\",\"   \"]},\"simpleDotsScrolling\":{\"interval\":200,\"frames\":[\".  \",\".. \",\"...\",\" ..\",\"  .\",\"   \"]},\"star\":{\"interval\":70,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\"]},\"star2\":{\"interval\":80,\"frames\":[\"+\",\"x\",\"*\"]},\"flip\":{\"interval\":70,\"frames\":[\"_\",\"_\",\"_\",\"-\",\"`\",\"`\",\"'\",\"\",\"-\",\"_\",\"_\",\"_\"]},\"hamburger\":{\"interval\":100,\"frames\":[\"\",\"\",\"\"]},\"growVertical\":{\"interval\":120,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]},\"growHorizontal\":{\"interval\":120,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]},\"balloon\":{\"interval\":140,\"frames\":[\" \",\".\",\"o\",\"O\",\"@\",\"*\",\" \"]},\"balloon2\":{\"interval\":120,\"frames\":[\".\",\"o\",\"O\",\"\",\"O\",\"o\",\".\"]},\"noise\":{\"interval\":100,\"frames\":[\"\",\"\",\"\"]},\"bounce\":{\"interval\":120,\"frames\":[\"\",\"\",\"\",\"\"]},\"boxBounce\":{\"interval\":120,\"frames\":[\"\",\"\",\"\",\"\"]},\"boxBounce2\":{\"interval\":100,\"frames\":[\"\",\"\",\"\",\"\"]},\"triangle\":{\"interval\":50,\"frames\":[\"\",\"\",\"\",\"\"]},\"binary\":{\"interval\":80,\"frames\":[\"010010\",\"001100\",\"100101\",\"111010\",\"111101\",\"010111\",\"101011\",\"111000\",\"110011\",\"110101\"]},\"arc\":{\"interval\":100,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\"]},\"circle\":{\"interval\":120,\"frames\":[\"\",\"\",\"\"]},\"squareCorners\":{\"interval\":180,\"frames\":[\"\",\"\",\"\",\"\"]},\"circleQuarters\":{\"interval\":120,\"frames\":[\"\",\"\",\"\",\"\"]},\"circleHalves\":{\"interval\":50,\"frames\":[\"\",\"\",\"\",\"\"]},\"squish\":{\"interval\":100,\"frames\":[\"\",\"\"]},\"toggle\":{\"interval\":250,\"frames\":[\"\",\"\"]},\"toggle2\":{\"interval\":80,\"frames\":[\"\",\"\"]},\"toggle3\":{\"interval\":120,\"frames\":[\"\",\"\"]},\"toggle4\":{\"interval\":100,\"frames\":[\"\",\"\",\"\",\"\"]},\"toggle5\":{\"interval\":100,\"frames\":[\"\",\"\"]},\"toggle6\":{\"interval\":300,\"frames\":[\"\",\"\"]},\"toggle7\":{\"interval\":80,\"frames\":[\"\",\"\"]},\"toggle8\":{\"interval\":100,\"frames\":[\"\",\"\"]},\"toggle9\":{\"interval\":100,\"frames\":[\"\",\"\"]},\"toggle10\":{\"interval\":100,\"frames\":[\"\",\"\",\"\"]},\"toggle11\":{\"interval\":50,\"frames\":[\"\",\"\"]},\"toggle12\":{\"interval\":120,\"frames\":[\"\",\"\"]},\"toggle13\":{\"interval\":80,\"frames\":[\"=\",\"*\",\"-\"]},\"arrow\":{\"interval\":100,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]},\"arrow2\":{\"interval\":80,\"frames\":[\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"]},\"arrow3\":{\"interval\":120,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\"]},\"bouncingBar\":{\"interval\":80,\"frames\":[\"[    ]\",\"[=   ]\",\"[==  ]\",\"[=== ]\",\"[====]\",\"[ ===]\",\"[  ==]\",\"[   =]\",\"[    ]\",\"[   =]\",\"[  ==]\",\"[ ===]\",\"[====]\",\"[=== ]\",\"[==  ]\",\"[=   ]\"]},\"bouncingBall\":{\"interval\":80,\"frames\":[\"(     )\",\"(     )\",\"(     )\",\"(     )\",\"(     )\",\"(     )\",\"(     )\",\"(     )\",\"(     )\",\"(     )\"]},\"smiley\":{\"interval\":200,\"frames\":[\" \",\" \"]},\"monkey\":{\"interval\":300,\"frames\":[\" \",\" \",\" \",\" \"]},\"hearts\":{\"interval\":100,\"frames\":[\" \",\" \",\" \",\" \",\" \"]},\"clock\":{\"interval\":100,\"frames\":[\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"]},\"earth\":{\"interval\":180,\"frames\":[\" \",\" \",\" \"]},\"material\":{\"interval\":17,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]},\"moon\":{\"interval\":80,\"frames\":[\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"]},\"runner\":{\"interval\":140,\"frames\":[\" \",\" \"]},\"pong\":{\"interval\":80,\"frames\":[\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \"]},\"shark\":{\"interval\":120,\"frames\":[\"|\\\\____________\",\"_|\\\\___________\",\"__|\\\\__________\",\"___|\\\\_________\",\"____|\\\\________\",\"_____|\\\\_______\",\"______|\\\\______\",\"_______|\\\\_____\",\"________|\\\\____\",\"_________|\\\\___\",\"__________|\\\\__\",\"___________|\\\\_\",\"____________|\\\\\",\"____________/|\",\"___________/|_\",\"__________/|__\",\"_________/|___\",\"________/|____\",\"_______/|_____\",\"______/|______\",\"_____/|_______\",\"____/|________\",\"___/|_________\",\"__/|__________\",\"_/|___________\",\"/|____________\"]},\"dqpb\":{\"interval\":100,\"frames\":[\"d\",\"q\",\"p\",\"b\"]},\"weather\":{\"interval\":100,\"frames\":[\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"]},\"christmas\":{\"interval\":400,\"frames\":[\"\",\"\"]},\"grenade\":{\"interval\":80,\"frames\":[\"  \",\"  \",\"  \",\"  \",\"  \",\"  \",\"  |\",\"  \",\"  \",\"  \",\"  \",\"   \",\"   \",\"   \"]},\"point\":{\"interval\":125,\"frames\":[\"\",\"\",\"\",\"\",\"\"]},\"layer\":{\"interval\":150,\"frames\":[\"-\",\"=\",\"\"]},\"betaWave\":{\"interval\":80,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\"]},\"fingerDance\":{\"interval\":160,\"frames\":[\" \",\" \",\" \",\" \",\" \",\" \"]},\"fistBump\":{\"interval\":80,\"frames\":[\" \",\" \",\" \",\" \",\" \",\" \",\" \"]},\"soccerHeader\":{\"interval\":80,\"frames\":[\"         \",\"         \",\"         \",\"         \",\"         \",\"         \",\"         \",\"         \",\"         \",\"         \",\"         \",\"         \"]},\"mindblown\":{\"interval\":160,\"frames\":[\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"]},\"speaker\":{\"interval\":160,\"frames\":[\" \",\" \",\" \",\" \"]},\"orangePulse\":{\"interval\":100,\"frames\":[\" \",\" \",\" \",\" \",\" \"]},\"bluePulse\":{\"interval\":100,\"frames\":[\" \",\" \",\" \",\" \",\" \"]},\"orangeBluePulse\":{\"interval\":100,\"frames\":[\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"]},\"timeTravel\":{\"interval\":100,\"frames\":[\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"]},\"aesthetic\":{\"interval\":80,\"frames\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]},\"dwarfFortress\":{\"interval\":80,\"frames\":[\"   \",\"  \",\"  \",\"  \",\"  \",\"  \",\"  \",\"  \",\"  \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\"   \",\"    \",\"    \",\"    \",\"    \",\"    \",\"    \",\"    \",\"    \",\"    \",\"     \",\"     \",\"     \",\"     \",\"     \",\"     \",\"     \",\"     \",\"     \",\"      \",\"      \",\"      \",\"      \",\"      \",\"      \",\"      \",\"      \",\"      \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"       \",\"        \",\"        \",\"        \",\"        \",\"        \",\"        \",\"        \",\"        \",\"        \",\"         \",\"         \",\"         \",\"         \",\"         \",\"         \",\"         \",\"         \",\"         \",\"          \",\"          \",\"          \",\"          \",\"          \",\"          \",\"          \",\"          \",\"          \",\"           \",\"          &\",\"         &\",\"         &\",\"         &\",\"        & \",\"         & \",\"        &  \",\"        &  \",\"       &   \",\"       &   \",\"      &    \",\"      &    \",\"      &     \",\"      &     \",\"     &     \",\"     &     \",\"    &      \",\"    &      \",\"   &      \",\"   &      \",\"  &       \",\"  &       \",\" &       \",\" &       \",\"&        \",\"&        \",\"        \",\"        \",\"        \",\"        \",\"       \",\"       \",\"       \",\"       \",\"      \",\"      \",\"      \",\"      \",\"     \",\"     \",\"     \",\"     \",\"    \",\"    \",\"    \",\"    \",\"   \",\"   \",\"   \",\"   \",\"   \"]}}"));}),
"[project]/align/node_modules/cli-spinners/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const spinners = Object.assign({}, __turbopack_context__.r("[project]/align/node_modules/cli-spinners/spinners.json (json)")); // eslint-disable-line import/extensions
const spinnersList = Object.keys(spinners);
Object.defineProperty(spinners, 'random', {
    get () {
        const randomIndex = Math.floor(Math.random() * spinnersList.length);
        const spinnerName = spinnersList[randomIndex];
        return spinners[spinnerName];
    }
});
module.exports = spinners;
}),
"[project]/align/node_modules/is-unicode-supported/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>isUnicodeSupported
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
;
function isUnicodeSupported() {
    const { env } = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"];
    const { TERM, TERM_PROGRAM } = env;
    if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].platform !== 'win32') {
        return TERM !== 'linux'; // Linux console (kernel)
    }
    return Boolean(env.WT_SESSION) // Windows Terminal
     || Boolean(env.TERMINUS_SUBLIME) // Terminus (<0.2.27)
     || env.ConEmuTask === '{cmd::Cmder}' // ConEmu and cmder
     || TERM_PROGRAM === 'Terminus-Sublime' || TERM_PROGRAM === 'vscode' || TERM === 'xterm-256color' || TERM === 'alacritty' || TERM === 'rxvt-unicode' || TERM === 'rxvt-unicode-256color' || env.TERMINAL_EMULATOR === 'JetBrains-JediTerm';
}
}),
"[project]/align/node_modules/is-interactive/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>isInteractive
]);
function isInteractive({ stream = process.stdout } = {}) {
    return Boolean(stream && stream.isTTY && process.env.TERM !== 'dumb' && !('CI' in process.env));
}
}),
"[project]/align/node_modules/stdin-discarder/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
;
const ASCII_ETX_CODE = 0x03; // Ctrl+C emits this code
class StdinDiscarder {
    #activeCount = 0;
    start() {
        this.#activeCount++;
        if (this.#activeCount === 1) {
            this.#realStart();
        }
    }
    stop() {
        if (this.#activeCount <= 0) {
            throw new Error('`stop` called more times than `start`');
        }
        this.#activeCount--;
        if (this.#activeCount === 0) {
            this.#realStop();
        }
    }
    #realStart() {
        // No known way to make it work reliably on Windows.
        if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].platform === 'win32' || !__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stdin.isTTY) {
            return;
        }
        __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stdin.setRawMode(true);
        __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stdin.on('data', this.#handleInput);
        __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stdin.resume();
    }
    #realStop() {
        if (!__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stdin.isTTY) {
            return;
        }
        __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stdin.off('data', this.#handleInput);
        __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stdin.pause();
        __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stdin.setRawMode(false);
    }
    #handleInput(chunk) {
        // Allow Ctrl+C to gracefully exit.
        if (chunk[0] === ASCII_ETX_CODE) {
            __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].emit('SIGINT');
        }
    }
}
const stdinDiscarder = new StdinDiscarder();
const __TURBOPACK__default__export__ = stdinDiscarder;
}),
"[project]/align/node_modules/eventsource-parser/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ParseError",
    ()=>ParseError,
    "createParser",
    ()=>createParser
]);
class ParseError extends Error {
    constructor(message, options){
        super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
    }
}
function noop(_arg) {}
function createParser(callbacks) {
    if (typeof callbacks == "function") throw new TypeError("`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?");
    const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
    let incompleteLine = "", isFirstChunk = !0, id, data = "", eventType = "";
    function feed(newChunk) {
        const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
        for (const line of complete)parseLine(line);
        incompleteLine = incomplete, isFirstChunk = !1;
    }
    function parseLine(line) {
        if (line === "") {
            dispatchEvent();
            return;
        }
        if (line.startsWith(":")) {
            onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
            return;
        }
        const fieldSeparatorIndex = line.indexOf(":");
        if (fieldSeparatorIndex !== -1) {
            const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
            processField(field, value, line);
            return;
        }
        processField(line, "", line);
    }
    function processField(field, value, line) {
        switch(field){
            case "event":
                eventType = value;
                break;
            case "data":
                data = `${data}${value}
`;
                break;
            case "id":
                id = value.includes("\0") ? void 0 : value;
                break;
            case "retry":
                /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(new ParseError(`Invalid \`retry\` value: "${value}"`, {
                    type: "invalid-retry",
                    value,
                    line
                }));
                break;
            default:
                onError(new ParseError(`Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`, {
                    type: "unknown-field",
                    field,
                    value,
                    line
                }));
                break;
        }
    }
    function dispatchEvent() {
        data.length > 0 && onEvent({
            id,
            event: eventType || void 0,
            // If the data buffer's last character is a U+000A LINE FEED (LF) character,
            // then remove the last character from the data buffer.
            data: data.endsWith(`
`) ? data.slice(0, -1) : data
        }), id = void 0, data = "", eventType = "";
    }
    function reset(options = {}) {
        incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = !0, id = void 0, data = "", eventType = "", incompleteLine = "";
    }
    return {
        feed,
        reset
    };
}
function splitLines(chunk) {
    const lines = [];
    let incompleteLine = "", searchIndex = 0;
    for(; searchIndex < chunk.length;){
        const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
        let lineEnd = -1;
        if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
            incompleteLine = chunk.slice(searchIndex);
            break;
        } else {
            const line = chunk.slice(searchIndex, lineEnd);
            lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
        }
    }
    return [
        lines,
        incompleteLine
    ];
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/align/node_modules/eventsource-parser/dist/stream.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "EventSourceParserStream",
    ()=>EventSourceParserStream
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$eventsource$2d$parser$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/align/node_modules/eventsource-parser/dist/index.js [app-route] (ecmascript)");
;
;
class EventSourceParserStream extends TransformStream {
    constructor({ onError, onRetry, onComment } = {}){
        let parser;
        super({
            start (controller) {
                parser = (0, __TURBOPACK__imported__module__$5b$project$5d2f$align$2f$node_modules$2f$eventsource$2d$parser$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createParser"])({
                    onEvent: (event)=>{
                        controller.enqueue(event);
                    },
                    onError (error) {
                        onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
                    },
                    onRetry,
                    onComment
                });
            },
            transform (chunk) {
                parser.feed(chunk);
            }
        });
    }
}
;
 //# sourceMappingURL=stream.js.map
}),
"[project]/align/node_modules/@vercel/oidc/dist/get-context.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var get_context_exports = {};
__export(get_context_exports, {
    SYMBOL_FOR_REQ_CONTEXT: ()=>SYMBOL_FOR_REQ_CONTEXT,
    getContext: ()=>getContext
});
module.exports = __toCommonJS(get_context_exports);
const SYMBOL_FOR_REQ_CONTEXT = Symbol.for("@vercel/request-context");
function getContext() {
    const fromSymbol = globalThis;
    return fromSymbol[SYMBOL_FOR_REQ_CONTEXT]?.get?.() ?? {};
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    SYMBOL_FOR_REQ_CONTEXT,
    getContext
});
}),
"[project]/align/node_modules/@vercel/oidc/dist/token-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var token_error_exports = {};
__export(token_error_exports, {
    VercelOidcTokenError: ()=>VercelOidcTokenError
});
module.exports = __toCommonJS(token_error_exports);
class VercelOidcTokenError extends Error {
    constructor(message, cause){
        super(message);
        this.name = "VercelOidcTokenError";
        this.cause = cause;
    }
    toString() {
        if (this.cause) {
            return `${this.name}: ${this.message}: ${this.cause}`;
        }
        return `${this.name}: ${this.message}`;
    }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    VercelOidcTokenError
});
}),
"[project]/align/node_modules/@vercel/oidc/dist/get-vercel-oidc-token.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var get_vercel_oidc_token_exports = {};
__export(get_vercel_oidc_token_exports, {
    getVercelOidcToken: ()=>getVercelOidcToken,
    getVercelOidcTokenSync: ()=>getVercelOidcTokenSync
});
module.exports = __toCommonJS(get_vercel_oidc_token_exports);
var import_get_context = __turbopack_context__.r("[project]/align/node_modules/@vercel/oidc/dist/get-context.js [app-route] (ecmascript)");
var import_token_error = __turbopack_context__.r("[project]/align/node_modules/@vercel/oidc/dist/token-error.js [app-route] (ecmascript)");
async function getVercelOidcToken() {
    let token = "";
    let err;
    try {
        token = getVercelOidcTokenSync();
    } catch (error) {
        err = error;
    }
    try {
        const [{ getTokenPayload, isExpired }, { refreshToken }] = await Promise.all([
            await __turbopack_context__.A("[project]/align/node_modules/@vercel/oidc/dist/token-util.js [app-route] (ecmascript, async loader)"),
            await __turbopack_context__.A("[project]/align/node_modules/@vercel/oidc/dist/token.js [app-route] (ecmascript, async loader)")
        ]);
        if (!token || isExpired(getTokenPayload(token))) {
            await refreshToken();
            token = getVercelOidcTokenSync();
        }
    } catch (error) {
        let message = err instanceof Error ? err.message : "";
        if (error instanceof Error) {
            message = `${message}
${error.message}`;
        }
        if (message) {
            throw new import_token_error.VercelOidcTokenError(message);
        }
        throw error;
    }
    return token;
}
function getVercelOidcTokenSync() {
    const token = (0, import_get_context.getContext)().headers?.["x-vercel-oidc-token"] ?? process.env.VERCEL_OIDC_TOKEN;
    if (!token) {
        throw new Error(`The 'x-vercel-oidc-token' header is missing from the request. Do you have the OIDC option enabled in the Vercel project settings?`);
    }
    return token;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    getVercelOidcToken,
    getVercelOidcTokenSync
});
}),
"[project]/align/node_modules/@vercel/oidc/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var src_exports = {};
__export(src_exports, {
    getContext: ()=>import_get_context.getContext,
    getVercelOidcToken: ()=>import_get_vercel_oidc_token.getVercelOidcToken,
    getVercelOidcTokenSync: ()=>import_get_vercel_oidc_token.getVercelOidcTokenSync
});
module.exports = __toCommonJS(src_exports);
var import_get_vercel_oidc_token = __turbopack_context__.r("[project]/align/node_modules/@vercel/oidc/dist/get-vercel-oidc-token.js [app-route] (ecmascript)");
var import_get_context = __turbopack_context__.r("[project]/align/node_modules/@vercel/oidc/dist/get-context.js [app-route] (ecmascript)");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    getContext,
    getVercelOidcToken,
    getVercelOidcTokenSync
});
}),
];

//# sourceMappingURL=00561_27a1f506._.js.map