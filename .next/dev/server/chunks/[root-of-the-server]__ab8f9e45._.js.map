{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 54, "column": 0}, "map": {"version":3,"sources":["file:///Users/ayobami/align/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\nimport { PrismaPg } from '@prisma/adapter-pg'\nimport pg from 'pg'\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\nfunction createPrismaClient() {\n  const connectionString = process.env.DATABASE_URL\n  if (!connectionString) {\n    throw new Error('DATABASE_URL environment variable is not set')\n  }\n\n  const pool = new pg.Pool({ connectionString })\n  const adapter = new PrismaPg(pool)\n  \n  return new PrismaClient({ adapter })\n}\n\nexport const prisma = globalForPrisma.prisma ?? createPrismaClient()\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;;;;;;AAEA,MAAM,kBAAkB;AAIxB,SAAS;IACP,MAAM,mBAAmB,QAAQ,GAAG,CAAC,YAAY;IACjD,IAAI,CAAC,kBAAkB;QACrB,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,OAAO,IAAI,iKAAE,CAAC,IAAI,CAAC;QAAE;IAAiB;IAC5C,MAAM,UAAU,IAAI,kLAAQ,CAAC;IAE7B,OAAO,IAAI,+MAAY,CAAC;QAAE;IAAQ;AACpC;AAEO,MAAM,SAAS,gBAAgB,MAAM,IAAI;AAEhD,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 92, "column": 0}, "map": {"version":3,"sources":["file:///Users/ayobami/align/lib/auth.ts"],"sourcesContent":["import NextAuth from \"next-auth\";\nimport Google from \"next-auth/providers/google\";\nimport { PrismaAdapter } from \"@auth/prisma-adapter\";\nimport { prisma } from \"./prisma\";\n\nexport const { handlers, signIn, signOut, auth } = NextAuth({\n  adapter: PrismaAdapter(prisma),\n  providers: [\n    Google({\n      clientId: process.env.GOOGLE_CLIENT_ID!,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n      authorization: {\n        params: {\n          prompt: \"consent\",\n          access_type: \"offline\",\n          response_type: \"code\",\n        },\n      },\n    }),\n  ],\n  session: {\n    strategy: \"database\",\n  },\n  pages: {\n    signIn: \"/login\",\n    error: \"/login\", // Redirect errors to login page\n  },\n  callbacks: {\n    async session({ session, user }) {\n      if (session.user) {\n        session.user.id = user.id;\n      }\n      return session;\n    },\n  },\n  debug: process.env.NODE_ENV === \"development\", // Enable debug logs in development\n});\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AAAA;AACA;AACA;;;;;;;;;AAEO,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,IAAA,2KAAQ,EAAC;IAC1D,SAAS,IAAA,gLAAa,EAAC,kIAAM;IAC7B,WAAW;QACT,IAAA,2KAAM,EAAC;YACL,UAAU,QAAQ,GAAG,CAAC,gBAAgB;YACtC,cAAc,QAAQ,GAAG,CAAC,oBAAoB;YAC9C,eAAe;gBACb,QAAQ;oBACN,QAAQ;oBACR,aAAa;oBACb,eAAe;gBACjB;YACF;QACF;KACD;IACD,SAAS;QACP,UAAU;IACZ;IACA,OAAO;QACL,QAAQ;QACR,OAAO;IACT;IACA,WAAW;QACT,MAAM,SAAQ,EAAE,OAAO,EAAE,IAAI,EAAE;YAC7B,IAAI,QAAQ,IAAI,EAAE;gBAChB,QAAQ,IAAI,CAAC,EAAE,GAAG,KAAK,EAAE;YAC3B;YACA,OAAO;QACT;IACF;IACA,OAAO,oDAAyB;AAClC"}},
    {"offset": {"line": 224, "column": 0}, "map": {"version":3,"sources":["file:///Users/ayobami/align/lib/opik.ts"],"sourcesContent":["/**\n * Opik Tracking Integration\n * Tracks AI model performance and decisions for demo purposes\n * Requirements: 13.1, 13.2, 13.3\n */\n\nimport { Opik } from 'opik';\n\nlet opikClient: Opik | null = null;\n\n/**\n * Initialize Opik client\n * Requirements: 13.1\n */\nexport function getOpikClient(): Opik | null {\n  // Only initialize if API key is provided\n  if (!process.env.OPIK_API_KEY) {\n    console.warn('OPIK_API_KEY not set - tracking disabled');\n    return null;\n  }\n\n  if (!opikClient) {\n    try {\n      opikClient = new Opik({\n        apiKey: process.env.OPIK_API_KEY,\n        projectName: process.env.OPIK_PROJECT_NAME || 'adaptive-productivity-agent',\n      });\n      console.log('Opik client initialized successfully');\n    } catch (error) {\n      console.error('Failed to initialize Opik client:', error);\n      return null;\n    }\n  }\n\n  return opikClient;\n}\n\n/**\n * Log Gemini AI request and response\n * Requirements: 13.1, 13.2\n */\nexport async function logAIRequest(data: {\n  userId: string;\n  capacityScore: number;\n  mode: string;\n  taskCount: number;\n  prompt: string;\n  response: string;\n  reasoning: string;\n  duration: number;\n  timestamp: Date;\n}): Promise<void> {\n  const client = getOpikClient();\n  if (!client) return;\n\n  try {\n    await client.log({\n      projectName: 'adaptive-productivity-agent',\n      name: 'gemini_plan_generation',\n      input: {\n        userId: data.userId,\n        capacityScore: data.capacityScore,\n        mode: data.mode,\n        taskCount: data.taskCount,\n        prompt: data.prompt,\n      },\n      output: {\n        response: data.response,\n        reasoning: data.reasoning,\n      },\n      metadata: {\n        model: 'gemini-1.5-flash',\n        duration_ms: data.duration,\n        timestamp: data.timestamp.toISOString(),\n      },\n      tags: ['ai-planning', 'gemini', data.mode],\n    });\n\n    console.log('AI request logged to Opik');\n  } catch (error) {\n    console.error('Failed to log AI request to Opik:', error);\n  }\n}\n\n/**\n * Track capacity score accuracy\n * Requirements: 13.3\n */\nexport async function trackCapacityAccuracy(data: {\n  userId: string;\n  predictedCapacity: number;\n  actualCompletionRate: number;\n  date: Date;\n  mode: string;\n}): Promise<void> {\n  const client = getOpikClient();\n  if (!client) return;\n\n  try {\n    // Calculate accuracy score (how well capacity predicted completion)\n    const expectedCompletion = data.predictedCapacity;\n    const actualCompletion = data.actualCompletionRate;\n    const accuracyScore = 100 - Math.abs(expectedCompletion - actualCompletion);\n\n    await client.log({\n      projectName: 'adaptive-productivity-agent',\n      name: 'capacity_accuracy',\n      input: {\n        userId: data.userId,\n        predictedCapacity: data.predictedCapacity,\n        mode: data.mode,\n        date: data.date.toISOString(),\n      },\n      output: {\n        actualCompletionRate: data.actualCompletionRate,\n        accuracyScore,\n      },\n      metadata: {\n        error: Math.abs(expectedCompletion - actualCompletion),\n        timestamp: new Date().toISOString(),\n      },\n      tags: ['capacity-tracking', data.mode],\n      feedbackScores: [\n        {\n          name: 'accuracy',\n          value: accuracyScore / 100,\n          reason: `Predicted ${expectedCompletion}%, actual ${actualCompletion}%`,\n        },\n      ],\n    });\n\n    console.log('Capacity accuracy tracked in Opik');\n  } catch (error) {\n    console.error('Failed to track capacity accuracy in Opik:', error);\n  }\n}\n\n/**\n * Track reasoning chain quality\n * Requirements: 13.2\n */\nexport async function trackReasoningQuality(data: {\n  userId: string;\n  reasoning: string;\n  taskCount: number;\n  userFeedback?: 'helpful' | 'not_helpful';\n  completionRate?: number;\n}): Promise<void> {\n  const client = getOpikClient();\n  if (!client) return;\n\n  try {\n    const qualityScore = calculateReasoningQuality(data.reasoning);\n\n    await client.log({\n      projectName: 'adaptive-productivity-agent',\n      name: 'reasoning_quality',\n      input: {\n        userId: data.userId,\n        taskCount: data.taskCount,\n        reasoningLength: data.reasoning.length,\n      },\n      output: {\n        reasoning: data.reasoning,\n        qualityScore,\n      },\n      metadata: {\n        userFeedback: data.userFeedback,\n        completionRate: data.completionRate,\n        timestamp: new Date().toISOString(),\n      },\n      tags: ['reasoning-quality', 'gemini'],\n      feedbackScores: data.userFeedback\n        ? [\n            {\n              name: 'user_satisfaction',\n              value: data.userFeedback === 'helpful' ? 1 : 0,\n            },\n          ]\n        : undefined,\n    });\n\n    console.log('Reasoning quality tracked in Opik');\n  } catch (error) {\n    console.error('Failed to track reasoning quality in Opik:', error);\n  }\n}\n\n/**\n * Calculate reasoning quality score based on heuristics\n */\nfunction calculateReasoningQuality(reasoning: string): number {\n  let score = 50; // Base score\n\n  // Check for key elements of good reasoning\n  if (reasoning.includes('capacity')) score += 10;\n  if (reasoning.includes('priority') || reasoning.includes('prioritize'))\n    score += 10;\n  if (reasoning.includes('energy') || reasoning.includes('focus')) score += 10;\n  if (reasoning.includes('balance') || reasoning.includes('recovery'))\n    score += 10;\n  if (reasoning.length > 100) score += 10; // Detailed explanation\n\n  return Math.min(100, score);\n}\n\n/**\n * Get Opik dashboard URL for viewing metrics\n * Requirements: 13.4\n */\nexport function getOpikDashboardUrl(): string {\n  const projectName =\n    process.env.OPIK_PROJECT_NAME || 'adaptive-productivity-agent';\n  return `https://www.comet.com/opik/projects/${projectName}`;\n}\n\n/**\n * Export Opik data for analysis\n * Requirements: 13.5\n */\nexport async function exportOpikData(\n  userId: string,\n  startDate: Date,\n  endDate: Date\n): Promise<any[]> {\n  const client = getOpikClient();\n  if (!client) {\n    console.warn('Opik client not available for export');\n    return [];\n  }\n\n  try {\n    // In a real implementation, this would query Opik's API\n    // For now, return a placeholder\n    console.log('Exporting Opik data for user:', userId);\n    return [];\n  } catch (error) {\n    console.error('Failed to export Opik data:', error);\n    return [];\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 415, "column": 0}, "map": {"version":3,"sources":["file:///Users/ayobami/align/lib/gemini.ts"],"sourcesContent":["import { GoogleGenerativeAI } from '@google/generative-ai';\nimport { logAIRequest, trackReasoningQuality } from './opik';\n\nexport interface PlanningContext {\n  capacityScore: number;\n  mode: 'recovery' | 'balanced' | 'deep_work';\n  tasks: Array<{\n    id: string;\n    title: string;\n    description?: string;\n    priority: number;\n    estimatedMinutes: number;\n    dueDate?: Date;\n    project?: string;\n  }>;\n  history: Array<{\n    date: Date;\n    capacityScore: number;\n    completedTasks: number;\n    totalTasks: number;\n  }>;\n  goals?: Array<{\n    title: string;\n    category: string;\n  }>;\n}\n\nexport interface PlanningResponse {\n  orderedTasks: Array<{\n    taskId: string;\n    scheduledStart: Date;\n    scheduledEnd: Date;\n    reasoning: string;\n  }>;\n  overallReasoning: string;\n  modeRecommendation?: string;\n}\n\n/**\n * Gemini AI client for intelligent planning\n */\nexport class GeminiClient {\n  private genAI: GoogleGenerativeAI;\n  private model: any;\n\n  constructor(apiKey?: string) {\n    const key = apiKey || process.env.GEMINI_API_KEY;\n    if (!key) {\n      throw new Error('GEMINI_API_KEY not configured');\n    }\n    this.genAI = new GoogleGenerativeAI(key);\n    this.model = this.genAI.getGenerativeModel({ model: 'gemini-pro' });\n  }\n\n  /**\n   * Generate an intelligent daily plan based on capacity and context\n   */\n  async generateDailyPlan(\n    context: PlanningContext,\n    startTime: Date = new Date(),\n    userId?: string\n  ): Promise<PlanningResponse> {\n    const prompt = this.buildPlanningPrompt(context, startTime);\n    const startTimestamp = Date.now();\n\n    try {\n      const result = await this.model.generateContent(prompt);\n      const response = await result.response;\n      const text = response.text();\n      const duration = Date.now() - startTimestamp;\n\n      const planningResponse = this.parsePlanningResponse(text, context.tasks, startTime);\n\n      // Track AI request in Opik (if userId provided)\n      if (userId) {\n        await logAIRequest({\n          userId,\n          capacityScore: context.capacityScore,\n          mode: context.mode,\n          taskCount: context.tasks.length,\n          prompt,\n          response: text,\n          reasoning: planningResponse.overallReasoning,\n          duration,\n          timestamp: new Date(),\n        }).catch((err) => console.error('Opik logging failed:', err));\n\n        // Track reasoning quality\n        await trackReasoningQuality({\n          userId,\n          reasoning: planningResponse.overallReasoning,\n          taskCount: context.tasks.length,\n        }).catch((err) => console.error('Opik reasoning tracking failed:', err));\n      }\n\n      return planningResponse;\n    } catch (error) {\n      console.error('Gemini AI error:', error);\n      throw new Error(\n        `Failed to generate plan: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Build the prompt for daily planning\n   */\n  private buildPlanningPrompt(context: PlanningContext, startTime: Date): string {\n    const { capacityScore, mode, tasks, history, goals } = context;\n\n    // Format history\n    const historyText = history\n      .map(\n        (h) =>\n          `- ${h.date.toLocaleDateString()}: Capacity ${h.capacityScore.toFixed(0)}, Completed ${h.completedTasks}/${h.totalTasks} tasks`\n      )\n      .join('\\n');\n\n    // Format tasks\n    const tasksText = tasks\n      .map(\n        (t) =>\n          `- [${t.id}] ${t.title} (Priority: ${t.priority}, Est: ${t.estimatedMinutes}min${t.dueDate ? `, Due: ${t.dueDate.toLocaleDateString()}` : ''})`\n      )\n      .join('\\n');\n\n    // Format goals\n    const goalsText = goals\n      ? goals.map((g) => `- ${g.title} (${g.category})`).join('\\n')\n      : 'No goals set';\n\n    const prompt = `You are an AI productivity assistant helping a user plan their day based on their current capacity and goals.\n\n**Current Context:**\n- Date: ${startTime.toLocaleDateString()}\n- Time: ${startTime.toLocaleTimeString()}\n- Capacity Score: ${capacityScore.toFixed(0)}/100\n- Mode: ${mode.toUpperCase()}\n\n**Mode Guidelines:**\n- RECOVERY (score < 40): Prioritize rest, light tasks, and self-care. Limit work to 2-3 hours max.\n- BALANCED (score 40-69): Mix of focused work and breaks. Standard 4-6 hour workday.\n- DEEP_WORK (score â‰¥ 70): Tackle demanding tasks. Can handle 6-8 hours of focused work.\n\n**Recent History (Last 7 Days):**\n${historyText || 'No history available'}\n\n**User's Goals:**\n${goalsText}\n\n**Available Tasks:**\n${tasksText}\n\n**Instructions:**\n1. Analyze the user's capacity score and recent patterns\n2. Consider their goals and how today's work contributes to them\n3. Prioritize tasks based on:\n   - Current capacity and mode\n   - Task priority and due dates\n   - Recent completion patterns\n   - Goal alignment\n4. Schedule tasks with realistic time blocks\n5. Include breaks and recovery time based on capacity\n6. Provide clear reasoning for your decisions\n\n**Output Format (JSON):**\n{\n  \"overallReasoning\": \"Brief explanation of your planning strategy for today\",\n  \"modeRecommendation\": \"Any suggestions about the current mode or capacity\",\n  \"tasks\": [\n    {\n      \"taskId\": \"task-id\",\n      \"startTime\": \"HH:MM\",\n      \"duration\": minutes,\n      \"reasoning\": \"Why this task at this time\"\n    }\n  ]\n}\n\nGenerate the plan now:`;\n\n    return prompt;\n  }\n\n  /**\n   * Parse Gemini's response into structured format\n   */\n  private parsePlanningResponse(\n    text: string,\n    tasks: PlanningContext['tasks'],\n    startTime: Date\n  ): PlanningResponse {\n    try {\n      // Extract JSON from response (Gemini sometimes wraps it in markdown)\n      const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n      if (!jsonMatch) {\n        throw new Error('No JSON found in response');\n      }\n\n      const parsed = JSON.parse(jsonMatch[0]);\n\n      // Convert to our format\n      const orderedTasks = parsed.tasks.map((t: any) => {\n        const task = tasks.find((task) => task.id === t.taskId);\n        if (!task) {\n          throw new Error(`Task ${t.taskId} not found`);\n        }\n\n        // Parse start time\n        const [hours, minutes] = t.startTime.split(':').map(Number);\n        const scheduledStart = new Date(startTime);\n        scheduledStart.setHours(hours, minutes, 0, 0);\n\n        // Calculate end time\n        const scheduledEnd = new Date(scheduledStart);\n        scheduledEnd.setMinutes(scheduledEnd.getMinutes() + t.duration);\n\n        return {\n          taskId: t.taskId,\n          scheduledStart,\n          scheduledEnd,\n          reasoning: t.reasoning,\n        };\n      });\n\n      return {\n        orderedTasks,\n        overallReasoning: parsed.overallReasoning,\n        modeRecommendation: parsed.modeRecommendation,\n      };\n    } catch (error) {\n      console.error('Failed to parse Gemini response:', error);\n      console.error('Raw response:', text);\n\n      // Fallback: simple priority-based ordering\n      return this.fallbackPlanning(tasks, startTime);\n    }\n  }\n\n  /**\n   * Fallback planning when AI fails\n   */\n  private fallbackPlanning(\n    tasks: PlanningContext['tasks'],\n    startTime: Date\n  ): PlanningResponse {\n    console.warn('Using fallback planning due to AI parsing error');\n\n    // Sort by priority and due date\n    const sortedTasks = [...tasks].sort((a, b) => {\n      if (a.priority !== b.priority) {\n        return a.priority - b.priority; // Lower number = higher priority\n      }\n      if (a.dueDate && b.dueDate) {\n        return a.dueDate.getTime() - b.dueDate.getTime();\n      }\n      if (a.dueDate) return -1;\n      if (b.dueDate) return 1;\n      return 0;\n    });\n\n    // Schedule tasks sequentially\n    let currentTime = new Date(startTime);\n    const orderedTasks = sortedTasks.map((task) => {\n      const scheduledStart = new Date(currentTime);\n      const scheduledEnd = new Date(currentTime);\n      scheduledEnd.setMinutes(scheduledEnd.getMinutes() + task.estimatedMinutes);\n\n      currentTime = new Date(scheduledEnd);\n      currentTime.setMinutes(currentTime.getMinutes() + 15); // 15 min break\n\n      return {\n        taskId: task.id,\n        scheduledStart,\n        scheduledEnd,\n        reasoning: `Priority ${task.priority} task${task.dueDate ? ' with upcoming due date' : ''}`,\n      };\n    });\n\n    return {\n      orderedTasks,\n      overallReasoning:\n        'Using simple priority-based scheduling (AI planning temporarily unavailable)',\n      modeRecommendation: undefined,\n    };\n  }\n\n  /**\n   * Get AI suggestions for capacity adjustment\n   */\n  async getCapacityInsights(\n    currentScore: number,\n    history: Array<{ date: Date; capacityScore: number }>\n  ): Promise<string> {\n    const historyText = history\n      .map((h) => `${h.date.toLocaleDateString()}: ${h.capacityScore.toFixed(0)}`)\n      .join(', ');\n\n    const prompt = `Analyze this user's capacity trend and provide brief insights:\n\nCurrent capacity score: ${currentScore.toFixed(0)}/100\nRecent history: ${historyText}\n\nProvide 2-3 sentences of insight about their capacity trend and any recommendations.`;\n\n    try {\n      const result = await this.model.generateContent(prompt);\n      const response = await result.response;\n      return response.text();\n    } catch (error) {\n      console.error('Gemini insights error:', error);\n      return 'Unable to generate insights at this time.';\n    }\n  }\n}\n\n/**\n * Singleton instance\n */\nlet geminiClient: GeminiClient | null = null;\n\nexport function getGeminiClient(): GeminiClient {\n  if (!geminiClient) {\n    geminiClient = new GeminiClient();\n  }\n  return geminiClient;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 650, "column": 0}, "map": {"version":3,"sources":["file:///Users/ayobami/align/lib/encryption.ts"],"sourcesContent":["import crypto from 'crypto';\n\n// Encryption key from environment (should be 32 bytes for AES-256)\nconst ENCRYPTION_KEY = process.env.ENCRYPTION_KEY || process.env.NEXTAUTH_SECRET || 'default-key-change-in-production';\nconst ALGORITHM = 'aes-256-cbc';\n\n/**\n * Encrypt a token using AES-256-CBC\n * @param token - The token to encrypt\n * @returns Encrypted token in format: iv:encryptedData\n */\nexport function encryptToken(token: string): string {\n  const key = crypto.scryptSync(ENCRYPTION_KEY, 'salt', 32);\n  const iv = crypto.randomBytes(16);\n  const cipher = crypto.createCipheriv(ALGORITHM, key, iv);\n  \n  let encrypted = cipher.update(token, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  \n  // Return IV + encrypted data\n  return iv.toString('hex') + ':' + encrypted;\n}\n\n/**\n * Decrypt a token using AES-256-CBC\n * @param encryptedToken - The encrypted token in format: iv:encryptedData\n * @returns Decrypted token\n */\nexport function decryptToken(encryptedToken: string): string {\n  const key = crypto.scryptSync(ENCRYPTION_KEY, 'salt', 32);\n  const parts = encryptedToken.split(':');\n  \n  if (parts.length !== 2) {\n    throw new Error('Invalid encrypted token format');\n  }\n  \n  const iv = Buffer.from(parts[0], 'hex');\n  const encrypted = parts[1];\n  \n  const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);\n  \n  let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  \n  return decrypted;\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,mEAAmE;AACnE,MAAM,iBAAiB,QAAQ,GAAG,CAAC,cAAc,IAAI,QAAQ,GAAG,CAAC,eAAe,IAAI;AACpF,MAAM,YAAY;AAOX,SAAS,aAAa,KAAa;IACxC,MAAM,MAAM,gHAAM,CAAC,UAAU,CAAC,gBAAgB,QAAQ;IACtD,MAAM,KAAK,gHAAM,CAAC,WAAW,CAAC;IAC9B,MAAM,SAAS,gHAAM,CAAC,cAAc,CAAC,WAAW,KAAK;IAErD,IAAI,YAAY,OAAO,MAAM,CAAC,OAAO,QAAQ;IAC7C,aAAa,OAAO,KAAK,CAAC;IAE1B,6BAA6B;IAC7B,OAAO,GAAG,QAAQ,CAAC,SAAS,MAAM;AACpC;AAOO,SAAS,aAAa,cAAsB;IACjD,MAAM,MAAM,gHAAM,CAAC,UAAU,CAAC,gBAAgB,QAAQ;IACtD,MAAM,QAAQ,eAAe,KAAK,CAAC;IAEnC,IAAI,MAAM,MAAM,KAAK,GAAG;QACtB,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,KAAK,OAAO,IAAI,CAAC,KAAK,CAAC,EAAE,EAAE;IACjC,MAAM,YAAY,KAAK,CAAC,EAAE;IAE1B,MAAM,WAAW,gHAAM,CAAC,gBAAgB,CAAC,WAAW,KAAK;IAEzD,IAAI,YAAY,SAAS,MAAM,CAAC,WAAW,OAAO;IAClD,aAAa,SAAS,KAAK,CAAC;IAE5B,OAAO;AACT"}},
    {"offset": {"line": 687, "column": 0}, "map": {"version":3,"sources":["file:///Users/ayobami/align/lib/google-calendar.ts"],"sourcesContent":["import { decryptToken } from './encryption';\n\nexport interface CalendarEvent {\n  id?: string;\n  summary: string;\n  description?: string;\n  start: {\n    dateTime: string;\n    timeZone?: string;\n  };\n  end: {\n    dateTime: string;\n    timeZone?: string;\n  };\n  colorId?: string;\n}\n\nexport interface CalendarEventResponse {\n  id: string;\n  summary: string;\n  description?: string;\n  start: {\n    dateTime: string;\n    timeZone?: string;\n  };\n  end: {\n    dateTime: string;\n    timeZone?: string;\n  };\n  htmlLink: string;\n}\n\n/**\n * Google Calendar API client\n */\nexport class GoogleCalendarClient {\n  private accessToken: string;\n  private refreshToken?: string;\n  private baseUrl = 'https://www.googleapis.com/calendar/v3';\n\n  constructor(encryptedAccessToken: string, encryptedRefreshToken?: string) {\n    this.accessToken = decryptToken(encryptedAccessToken);\n    if (encryptedRefreshToken) {\n      this.refreshToken = decryptToken(encryptedRefreshToken);\n    }\n  }\n\n  /**\n   * Create a calendar event\n   */\n  async createEvent(\n    calendarId: string = 'primary',\n    event: CalendarEvent\n  ): Promise<CalendarEventResponse> {\n    const response = await fetch(\n      `${this.baseUrl}/calendars/${calendarId}/events`,\n      {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${this.accessToken}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(event),\n      }\n    );\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(\n        `Google Calendar API error: ${response.status} ${response.statusText} - ${errorText}`\n      );\n    }\n\n    return response.json();\n  }\n\n  /**\n   * Update a calendar event\n   */\n  async updateEvent(\n    eventId: string,\n    event: CalendarEvent,\n    calendarId: string = 'primary'\n  ): Promise<CalendarEventResponse> {\n    const response = await fetch(\n      `${this.baseUrl}/calendars/${calendarId}/events/${eventId}`,\n      {\n        method: 'PUT',\n        headers: {\n          Authorization: `Bearer ${this.accessToken}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(event),\n      }\n    );\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(\n        `Google Calendar API error: ${response.status} ${response.statusText} - ${errorText}`\n      );\n    }\n\n    return response.json();\n  }\n\n  /**\n   * Delete a calendar event\n   */\n  async deleteEvent(\n    eventId: string,\n    calendarId: string = 'primary'\n  ): Promise<void> {\n    const response = await fetch(\n      `${this.baseUrl}/calendars/${calendarId}/events/${eventId}`,\n      {\n        method: 'DELETE',\n        headers: {\n          Authorization: `Bearer ${this.accessToken}`,\n        },\n      }\n    );\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(\n        `Google Calendar API error: ${response.status} ${response.statusText} - ${errorText}`\n      );\n    }\n  }\n\n  /**\n   * List events in a time range\n   */\n  async listEvents(\n    timeMin: Date,\n    timeMax: Date,\n    calendarId: string = 'primary'\n  ): Promise<CalendarEventResponse[]> {\n    const url = new URL(`${this.baseUrl}/calendars/${calendarId}/events`);\n    url.searchParams.set('timeMin', timeMin.toISOString());\n    url.searchParams.set('timeMax', timeMax.toISOString());\n    url.searchParams.set('singleEvents', 'true');\n    url.searchParams.set('orderBy', 'startTime');\n\n    const response = await fetch(url.toString(), {\n      headers: {\n        Authorization: `Bearer ${this.accessToken}`,\n      },\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(\n        `Google Calendar API error: ${response.status} ${response.statusText} - ${errorText}`\n      );\n    }\n\n    const data = await response.json();\n    return data.items || [];\n  }\n\n  /**\n   * Check for scheduling conflicts\n   */\n  async hasConflict(\n    startTime: Date,\n    endTime: Date,\n    calendarId: string = 'primary'\n  ): Promise<boolean> {\n    const events = await this.listEvents(startTime, endTime, calendarId);\n    return events.length > 0;\n  }\n}\n\n/**\n * Refresh Google OAuth access token\n */\nexport async function refreshGoogleToken(refreshToken: string): Promise<{\n  access_token: string;\n  expires_in: number;\n}> {\n  const clientId = process.env.GOOGLE_CLIENT_ID;\n  const clientSecret = process.env.GOOGLE_CLIENT_SECRET;\n\n  if (!clientId || !clientSecret) {\n    throw new Error('Google OAuth credentials not configured');\n  }\n\n  const response = await fetch('https://oauth2.googleapis.com/token', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n    body: new URLSearchParams({\n      client_id: clientId,\n      client_secret: clientSecret,\n      refresh_token: refreshToken,\n      grant_type: 'refresh_token',\n    }),\n  });\n\n  if (!response.ok) {\n    const errorText = await response.text();\n    throw new Error(`Token refresh failed: ${response.status} - ${errorText}`);\n  }\n\n  return response.json();\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 810, "column": 0}, "map": {"version":3,"sources":["file:///Users/ayobami/align/lib/calendar-sync.ts"],"sourcesContent":["import { prisma } from './prisma';\nimport { GoogleCalendarClient, refreshGoogleToken } from './google-calendar';\nimport { encryptToken } from './encryption';\n\nexport interface TaskSchedule {\n  taskId: string;\n  title: string;\n  description?: string;\n  startTime: Date;\n  endTime: Date;\n  priority: number;\n}\n\n/**\n * Sync a daily plan's tasks to Google Calendar\n */\nexport async function syncPlanToCalendar(\n  userId: string,\n  tasks: TaskSchedule[],\n  timeZone: string = 'UTC'\n): Promise<{\n  success: boolean;\n  createdEvents: number;\n  errors: string[];\n}> {\n  const errors: string[] = [];\n  let createdEvents = 0;\n\n  try {\n    // Get Google Calendar integration\n    const integration = await prisma.integration.findUnique({\n      where: {\n        userId_platform: {\n          userId,\n          platform: 'google_calendar',\n        },\n      },\n    });\n\n    if (!integration) {\n      return {\n        success: false,\n        createdEvents: 0,\n        errors: ['Google Calendar not connected'],\n      };\n    }\n\n    // Check if token needs refresh\n    let accessToken = integration.accessToken;\n    if (integration.expiresAt && integration.expiresAt < new Date()) {\n      if (!integration.refreshToken) {\n        return {\n          success: false,\n          createdEvents: 0,\n          errors: ['Token expired and no refresh token available'],\n        };\n      }\n\n      // Refresh the token\n      const tokenData = await refreshGoogleToken(integration.refreshToken);\n      accessToken = encryptToken(tokenData.access_token);\n\n      // Update the integration with new token\n      await prisma.integration.update({\n        where: { id: integration.id },\n        data: {\n          accessToken,\n          expiresAt: new Date(Date.now() + tokenData.expires_in * 1000),\n        },\n      });\n    }\n\n    // Create calendar client\n    const client = new GoogleCalendarClient(accessToken);\n\n    // Create events for each task\n    for (const task of tasks) {\n      try {\n        // Check for conflicts\n        const hasConflict = await client.hasConflict(task.startTime, task.endTime);\n\n        if (hasConflict) {\n          errors.push(\n            `Conflict detected for task \"${task.title}\" at ${task.startTime.toISOString()}`\n          );\n          continue;\n        }\n\n        // Create the event\n        const event = await client.createEvent('primary', {\n          summary: task.title,\n          description: task.description,\n          start: {\n            dateTime: task.startTime.toISOString(),\n            timeZone,\n          },\n          end: {\n            dateTime: task.endTime.toISOString(),\n            timeZone,\n          },\n          colorId: getPriorityColor(task.priority),\n        });\n\n        // Update the task with the calendar event ID\n        await prisma.planTask.update({\n          where: { id: task.taskId },\n          data: {\n            externalId: event.id,\n          },\n        });\n\n        createdEvents++;\n      } catch (error) {\n        console.error(`Error creating event for task ${task.taskId}:`, error);\n        errors.push(\n          `Failed to create event for task \"${task.title}\": ${\n            error instanceof Error ? error.message : 'Unknown error'\n          }`\n        );\n      }\n    }\n\n    return {\n      success: errors.length === 0,\n      createdEvents,\n      errors,\n    };\n  } catch (error) {\n    console.error('Calendar sync error:', error);\n    return {\n      success: false,\n      createdEvents,\n      errors: [\n        `Calendar sync failed: ${\n          error instanceof Error ? error.message : 'Unknown error'\n        }`,\n      ],\n    };\n  }\n}\n\n/**\n * Update a calendar event when a task is rescheduled\n */\nexport async function updateCalendarEvent(\n  userId: string,\n  taskId: string,\n  newStartTime: Date,\n  newEndTime: Date,\n  timeZone: string = 'UTC'\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    // Get the task with its calendar event ID\n    const task = await prisma.planTask.findUnique({\n      where: { id: taskId },\n    });\n\n    if (!task || !task.externalId) {\n      return {\n        success: false,\n        error: 'Task not found or not synced to calendar',\n      };\n    }\n\n    // Get Google Calendar integration\n    const integration = await prisma.integration.findUnique({\n      where: {\n        userId_platform: {\n          userId,\n          platform: 'google_calendar',\n        },\n      },\n    });\n\n    if (!integration) {\n      return {\n        success: false,\n        error: 'Google Calendar not connected',\n      };\n    }\n\n    // Check if token needs refresh\n    let accessToken = integration.accessToken;\n    if (integration.expiresAt && integration.expiresAt < new Date()) {\n      if (!integration.refreshToken) {\n        return {\n          success: false,\n          error: 'Token expired and no refresh token available',\n        };\n      }\n\n      // Refresh the token\n      const tokenData = await refreshGoogleToken(integration.refreshToken);\n      accessToken = encryptToken(tokenData.access_token);\n\n      // Update the integration with new token\n      await prisma.integration.update({\n        where: { id: integration.id },\n        data: {\n          accessToken,\n          expiresAt: new Date(Date.now() + tokenData.expires_in * 1000),\n        },\n      });\n    }\n\n    // Create calendar client\n    const client = new GoogleCalendarClient(accessToken);\n\n    // Update the event\n    await client.updateEvent(task.externalId, {\n      summary: task.title,\n      description: task.description || undefined,\n      start: {\n        dateTime: newStartTime.toISOString(),\n        timeZone,\n      },\n      end: {\n        dateTime: newEndTime.toISOString(),\n        timeZone,\n      },\n      colorId: getPriorityColor(task.priority),\n    });\n\n    // Update the task's scheduled times\n    await prisma.planTask.update({\n      where: { id: taskId },\n      data: {\n        scheduledStart: newStartTime,\n        scheduledEnd: newEndTime,\n      },\n    });\n\n    return { success: true };\n  } catch (error) {\n    console.error('Calendar event update error:', error);\n    return {\n      success: false,\n      error:\n        error instanceof Error ? error.message : 'Failed to update calendar event',\n    };\n  }\n}\n\n/**\n * Delete a calendar event when a task is removed\n */\nexport async function deleteCalendarEvent(\n  userId: string,\n  taskId: string\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    // Get the task with its calendar event ID\n    const task = await prisma.planTask.findUnique({\n      where: { id: taskId },\n    });\n\n    if (!task || !task.externalId) {\n      return {\n        success: true, // Already not in calendar\n      };\n    }\n\n    // Get Google Calendar integration\n    const integration = await prisma.integration.findUnique({\n      where: {\n        userId_platform: {\n          userId,\n          platform: 'google_calendar',\n        },\n      },\n    });\n\n    if (!integration) {\n      return {\n        success: false,\n        error: 'Google Calendar not connected',\n      };\n    }\n\n    // Check if token needs refresh\n    let accessToken = integration.accessToken;\n    if (integration.expiresAt && integration.expiresAt < new Date()) {\n      if (!integration.refreshToken) {\n        return {\n          success: false,\n          error: 'Token expired and no refresh token available',\n        };\n      }\n\n      // Refresh the token\n      const tokenData = await refreshGoogleToken(integration.refreshToken);\n      accessToken = encryptToken(tokenData.access_token);\n\n      // Update the integration with new token\n      await prisma.integration.update({\n        where: { id: integration.id },\n        data: {\n          accessToken,\n          expiresAt: new Date(Date.now() + tokenData.expires_in * 1000),\n        },\n      });\n    }\n\n    // Create calendar client\n    const client = new GoogleCalendarClient(accessToken);\n\n    // Delete the event\n    await client.deleteEvent(task.externalId);\n\n    // Clear the external ID from the task\n    await prisma.planTask.update({\n      where: { id: taskId },\n      data: {\n        externalId: null,\n      },\n    });\n\n    return { success: true };\n  } catch (error) {\n    console.error('Calendar event deletion error:', error);\n    return {\n      success: false,\n      error:\n        error instanceof Error ? error.message : 'Failed to delete calendar event',\n    };\n  }\n}\n\n/**\n * Get Google Calendar color ID based on task priority\n * Priority 1 (highest) = Red (11)\n * Priority 2 = Orange (6)\n * Priority 3 = Yellow (5)\n * Priority 4 (lowest) = Blue (9)\n */\nfunction getPriorityColor(priority: number): string {\n  const colorMap: Record<number, string> = {\n    1: '11', // Red\n    2: '6',  // Orange\n    3: '5',  // Yellow\n    4: '9',  // Blue\n  };\n  return colorMap[priority] || '9'; // Default to blue\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1118, "column": 0}, "map": {"version":3,"sources":["file:///Users/ayobami/align/app/api/plan/generate/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { auth } from '@/lib/auth';\nimport { prisma } from '@/lib/prisma';\nimport { getGeminiClient, PlanningContext } from '@/lib/gemini';\nimport { syncPlanToCalendar } from '@/lib/calendar-sync';\n\n// POST /api/plan/generate - Generate AI-powered daily plan\nexport async function POST(request: NextRequest) {\n  try {\n    const session = await auth();\n\n    if (!session || !session.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const body = await request.json();\n    const { date, syncToCalendar = false } = body;\n\n    // Get user from database\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n    });\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 });\n    }\n\n    // Get today's check-in\n    const planDate = date ? new Date(date) : new Date();\n    planDate.setHours(0, 0, 0, 0);\n\n    const checkIn = await prisma.checkIn.findFirst({\n      where: {\n        userId: user.id,\n        date: {\n          gte: planDate,\n          lt: new Date(planDate.getTime() + 24 * 60 * 60 * 1000),\n        },\n      },\n      orderBy: { date: 'desc' },\n    });\n\n    if (!checkIn) {\n      return NextResponse.json(\n        { error: 'No check-in found for today. Please complete your check-in first.' },\n        { status: 400 }\n      );\n    }\n\n    // Get 7-day history\n    const sevenDaysAgo = new Date(planDate);\n    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);\n\n    const history = await prisma.checkIn.findMany({\n      where: {\n        userId: user.id,\n        date: {\n          gte: sevenDaysAgo,\n          lt: planDate,\n        },\n      },\n      orderBy: { date: 'desc' },\n      take: 7,\n    });\n\n    // Get user's goals\n    const goals = await prisma.goal.findMany({\n      where: { userId: user.id },\n      select: {\n        title: true,\n        category: true,\n      },\n    });\n\n    // Get tasks from Todoist integration\n    const todoistIntegration = await prisma.integration.findUnique({\n      where: {\n        userId_platform: {\n          userId: user.id,\n          platform: 'todoist',\n        },\n      },\n    });\n\n    let tasks: PlanningContext['tasks'] = [];\n\n    if (todoistIntegration) {\n      // Fetch tasks from Todoist\n      const todoistResponse = await fetch(\n        `${request.nextUrl.origin}/api/integrations/todoist/tasks`,\n        {\n          headers: {\n            Cookie: request.headers.get('cookie') || '',\n          },\n        }\n      );\n\n      if (todoistResponse.ok) {\n        const todoistTasks = await todoistResponse.json();\n        tasks = todoistTasks.tasks.map((t: any) => ({\n          id: t.id,\n          title: t.content,\n          description: t.description,\n          priority: t.priority,\n          estimatedMinutes: t.estimatedMinutes || 45,\n          dueDate: t.due?.date ? new Date(t.due.date) : undefined,\n          project: t.project_id,\n        }));\n      }\n    }\n\n    // If no tasks from integrations, check for existing plan tasks\n    if (tasks.length === 0) {\n      const existingPlan = await prisma.dailyPlan.findFirst({\n        where: {\n          userId: user.id,\n          date: planDate,\n        },\n        include: {\n          tasks: true,\n        },\n      });\n\n      if (existingPlan) {\n        tasks = existingPlan.tasks.map((t) => ({\n          id: t.id,\n          title: t.title,\n          description: t.description || undefined,\n          priority: t.priority,\n          estimatedMinutes: t.estimatedMinutes,\n        }));\n      }\n    }\n\n    // If still no tasks, return error\n    if (tasks.length === 0) {\n      return NextResponse.json(\n        {\n          error:\n            'No tasks available. Please connect Todoist or add tasks manually.',\n        },\n        { status: 400 }\n      );\n    }\n\n    // Build planning context\n    const context: PlanningContext = {\n      capacityScore: checkIn.capacityScore,\n      mode: checkIn.mode as 'recovery' | 'balanced' | 'deep_work',\n      tasks,\n      history: history.map((h) => ({\n        date: h.date,\n        capacityScore: h.capacityScore,\n        completedTasks: 0, // TODO: Track this\n        totalTasks: 0, // TODO: Track this\n      })),\n      goals: goals.length > 0 ? goals : undefined,\n    };\n\n    // Generate plan using Gemini AI\n    const gemini = getGeminiClient();\n    const planningResponse = await gemini.generateDailyPlan(context, new Date(), user.id);\n\n    // Save plan to database\n    const plan = await prisma.dailyPlan.create({\n      data: {\n        userId: user.id,\n        date: planDate,\n        capacityScore: checkIn.capacityScore,\n        mode: checkIn.mode,\n        geminiReasoning: planningResponse.overallReasoning,\n        tasks: {\n          create: planningResponse.orderedTasks.map((t) => {\n            const task = tasks.find((task) => task.id === t.taskId);\n            return {\n              externalId: t.taskId,\n              title: task?.title || 'Unknown Task',\n              description: task?.description,\n              priority: task?.priority || 3,\n              estimatedMinutes: task?.estimatedMinutes || 45,\n              scheduledStart: t.scheduledStart,\n              scheduledEnd: t.scheduledEnd,\n            };\n          }),\n        },\n      },\n      include: {\n        tasks: true,\n      },\n    });\n\n    // Sync to Google Calendar if requested\n    let calendarSyncResult;\n    if (syncToCalendar) {\n      const taskSchedules = plan.tasks.map((t) => ({\n        taskId: t.id,\n        title: t.title,\n        description: t.description || undefined,\n        startTime: t.scheduledStart!,\n        endTime: t.scheduledEnd!,\n        priority: t.priority,\n      }));\n\n      calendarSyncResult = await syncPlanToCalendar(\n        user.id,\n        taskSchedules,\n        Intl.DateTimeFormat().resolvedOptions().timeZone\n      );\n    }\n\n    return NextResponse.json(\n      {\n        message: 'Daily plan generated successfully',\n        plan: {\n          id: plan.id,\n          date: plan.date,\n          capacityScore: plan.capacityScore,\n          mode: plan.mode,\n          reasoning: plan.geminiReasoning,\n          modeRecommendation: planningResponse.modeRecommendation,\n          tasks: plan.tasks.map((t) => ({\n            id: t.id,\n            title: t.title,\n            description: t.description,\n            priority: t.priority,\n            estimatedMinutes: t.estimatedMinutes,\n            scheduledStart: t.scheduledStart,\n            scheduledEnd: t.scheduledEnd,\n            completed: t.completed,\n          })),\n        },\n        calendarSync: calendarSyncResult,\n      },\n      { status: 201 }\n    );\n  } catch (error) {\n    console.error('Plan generation error:', error);\n    return NextResponse.json(\n      {\n        error: 'Failed to generate plan',\n        details: error instanceof Error ? error.message : 'Unknown error',\n      },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAGO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,UAAU,MAAM,IAAA,8HAAI;QAE1B,IAAI,CAAC,WAAW,CAAC,QAAQ,IAAI,EAAE,OAAO;YACpC,OAAO,yJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACpE;QAEA,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,IAAI,EAAE,iBAAiB,KAAK,EAAE,GAAG;QAEzC,yBAAyB;QACzB,MAAM,OAAO,MAAM,kIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YACxC,OAAO;gBAAE,OAAO,QAAQ,IAAI,CAAC,KAAK;YAAC;QACrC;QAEA,IAAI,CAAC,MAAM;YACT,OAAO,yJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAiB,GAAG;gBAAE,QAAQ;YAAI;QACtE;QAEA,uBAAuB;QACvB,MAAM,WAAW,OAAO,IAAI,KAAK,QAAQ,IAAI;QAC7C,SAAS,QAAQ,CAAC,GAAG,GAAG,GAAG;QAE3B,MAAM,UAAU,MAAM,kIAAM,CAAC,OAAO,CAAC,SAAS,CAAC;YAC7C,OAAO;gBACL,QAAQ,KAAK,EAAE;gBACf,MAAM;oBACJ,KAAK;oBACL,IAAI,IAAI,KAAK,SAAS,OAAO,KAAK,KAAK,KAAK,KAAK;gBACnD;YACF;YACA,SAAS;gBAAE,MAAM;YAAO;QAC1B;QAEA,IAAI,CAAC,SAAS;YACZ,OAAO,yJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAoE,GAC7E;gBAAE,QAAQ;YAAI;QAElB;QAEA,oBAAoB;QACpB,MAAM,eAAe,IAAI,KAAK;QAC9B,aAAa,OAAO,CAAC,aAAa,OAAO,KAAK;QAE9C,MAAM,UAAU,MAAM,kIAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;YAC5C,OAAO;gBACL,QAAQ,KAAK,EAAE;gBACf,MAAM;oBACJ,KAAK;oBACL,IAAI;gBACN;YACF;YACA,SAAS;gBAAE,MAAM;YAAO;YACxB,MAAM;QACR;QAEA,mBAAmB;QACnB,MAAM,QAAQ,MAAM,kIAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;YACvC,OAAO;gBAAE,QAAQ,KAAK,EAAE;YAAC;YACzB,QAAQ;gBACN,OAAO;gBACP,UAAU;YACZ;QACF;QAEA,qCAAqC;QACrC,MAAM,qBAAqB,MAAM,kIAAM,CAAC,WAAW,CAAC,UAAU,CAAC;YAC7D,OAAO;gBACL,iBAAiB;oBACf,QAAQ,KAAK,EAAE;oBACf,UAAU;gBACZ;YACF;QACF;QAEA,IAAI,QAAkC,EAAE;QAExC,IAAI,oBAAoB;YACtB,2BAA2B;YAC3B,MAAM,kBAAkB,MAAM,MAC5B,GAAG,QAAQ,OAAO,CAAC,MAAM,CAAC,+BAA+B,CAAC,EAC1D;gBACE,SAAS;oBACP,QAAQ,QAAQ,OAAO,CAAC,GAAG,CAAC,aAAa;gBAC3C;YACF;YAGF,IAAI,gBAAgB,EAAE,EAAE;gBACtB,MAAM,eAAe,MAAM,gBAAgB,IAAI;gBAC/C,QAAQ,aAAa,KAAK,CAAC,GAAG,CAAC,CAAC,IAAW,CAAC;wBAC1C,IAAI,EAAE,EAAE;wBACR,OAAO,EAAE,OAAO;wBAChB,aAAa,EAAE,WAAW;wBAC1B,UAAU,EAAE,QAAQ;wBACpB,kBAAkB,EAAE,gBAAgB,IAAI;wBACxC,SAAS,EAAE,GAAG,EAAE,OAAO,IAAI,KAAK,EAAE,GAAG,CAAC,IAAI,IAAI;wBAC9C,SAAS,EAAE,UAAU;oBACvB,CAAC;YACH;QACF;QAEA,+DAA+D;QAC/D,IAAI,MAAM,MAAM,KAAK,GAAG;YACtB,MAAM,eAAe,MAAM,kIAAM,CAAC,SAAS,CAAC,SAAS,CAAC;gBACpD,OAAO;oBACL,QAAQ,KAAK,EAAE;oBACf,MAAM;gBACR;gBACA,SAAS;oBACP,OAAO;gBACT;YACF;YAEA,IAAI,cAAc;gBAChB,QAAQ,aAAa,KAAK,CAAC,GAAG,CAAC,CAAC,IAAM,CAAC;wBACrC,IAAI,EAAE,EAAE;wBACR,OAAO,EAAE,KAAK;wBACd,aAAa,EAAE,WAAW,IAAI;wBAC9B,UAAU,EAAE,QAAQ;wBACpB,kBAAkB,EAAE,gBAAgB;oBACtC,CAAC;YACH;QACF;QAEA,kCAAkC;QAClC,IAAI,MAAM,MAAM,KAAK,GAAG;YACtB,OAAO,yJAAY,CAAC,IAAI,CACtB;gBACE,OACE;YACJ,GACA;gBAAE,QAAQ;YAAI;QAElB;QAEA,yBAAyB;QACzB,MAAM,UAA2B;YAC/B,eAAe,QAAQ,aAAa;YACpC,MAAM,QAAQ,IAAI;YAClB;YACA,SAAS,QAAQ,GAAG,CAAC,CAAC,IAAM,CAAC;oBAC3B,MAAM,EAAE,IAAI;oBACZ,eAAe,EAAE,aAAa;oBAC9B,gBAAgB;oBAChB,YAAY;gBACd,CAAC;YACD,OAAO,MAAM,MAAM,GAAG,IAAI,QAAQ;QACpC;QAEA,gCAAgC;QAChC,MAAM,SAAS,IAAA,2IAAe;QAC9B,MAAM,mBAAmB,MAAM,OAAO,iBAAiB,CAAC,SAAS,IAAI,QAAQ,KAAK,EAAE;QAEpF,wBAAwB;QACxB,MAAM,OAAO,MAAM,kIAAM,CAAC,SAAS,CAAC,MAAM,CAAC;YACzC,MAAM;gBACJ,QAAQ,KAAK,EAAE;gBACf,MAAM;gBACN,eAAe,QAAQ,aAAa;gBACpC,MAAM,QAAQ,IAAI;gBAClB,iBAAiB,iBAAiB,gBAAgB;gBAClD,OAAO;oBACL,QAAQ,iBAAiB,YAAY,CAAC,GAAG,CAAC,CAAC;wBACzC,MAAM,OAAO,MAAM,IAAI,CAAC,CAAC,OAAS,KAAK,EAAE,KAAK,EAAE,MAAM;wBACtD,OAAO;4BACL,YAAY,EAAE,MAAM;4BACpB,OAAO,MAAM,SAAS;4BACtB,aAAa,MAAM;4BACnB,UAAU,MAAM,YAAY;4BAC5B,kBAAkB,MAAM,oBAAoB;4BAC5C,gBAAgB,EAAE,cAAc;4BAChC,cAAc,EAAE,YAAY;wBAC9B;oBACF;gBACF;YACF;YACA,SAAS;gBACP,OAAO;YACT;QACF;QAEA,uCAAuC;QACvC,IAAI;QACJ,IAAI,gBAAgB;YAClB,MAAM,gBAAgB,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC,IAAM,CAAC;oBAC3C,QAAQ,EAAE,EAAE;oBACZ,OAAO,EAAE,KAAK;oBACd,aAAa,EAAE,WAAW,IAAI;oBAC9B,WAAW,EAAE,cAAc;oBAC3B,SAAS,EAAE,YAAY;oBACvB,UAAU,EAAE,QAAQ;gBACtB,CAAC;YAED,qBAAqB,MAAM,IAAA,wJAAkB,EAC3C,KAAK,EAAE,EACP,eACA,KAAK,cAAc,GAAG,eAAe,GAAG,QAAQ;QAEpD;QAEA,OAAO,yJAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,MAAM;gBACJ,IAAI,KAAK,EAAE;gBACX,MAAM,KAAK,IAAI;gBACf,eAAe,KAAK,aAAa;gBACjC,MAAM,KAAK,IAAI;gBACf,WAAW,KAAK,eAAe;gBAC/B,oBAAoB,iBAAiB,kBAAkB;gBACvD,OAAO,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC,IAAM,CAAC;wBAC5B,IAAI,EAAE,EAAE;wBACR,OAAO,EAAE,KAAK;wBACd,aAAa,EAAE,WAAW;wBAC1B,UAAU,EAAE,QAAQ;wBACpB,kBAAkB,EAAE,gBAAgB;wBACpC,gBAAgB,EAAE,cAAc;wBAChC,cAAc,EAAE,YAAY;wBAC5B,WAAW,EAAE,SAAS;oBACxB,CAAC;YACH;YACA,cAAc;QAChB,GACA;YAAE,QAAQ;QAAI;IAElB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0BAA0B;QACxC,OAAO,yJAAY,CAAC,IAAI,CACtB;YACE,OAAO;YACP,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QACpD,GACA;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}