{"version":3,"sources":["../../../../align/lib/encryption.ts","../../../../align/node_modules/%40vercel/oidc/dist/token-error.js","../../../../align/lib/google-calendar.ts","../../../../align/lib/calendar-sync.ts"],"sourcesContent":["import crypto from 'crypto';\n\n// Encryption key from environment (should be 32 bytes for AES-256)\nconst ENCRYPTION_KEY = process.env.ENCRYPTION_KEY || process.env.NEXTAUTH_SECRET || 'default-key-change-in-production';\nconst ALGORITHM = 'aes-256-cbc';\n\n/**\n * Encrypt a token using AES-256-CBC\n * @param token - The token to encrypt\n * @returns Encrypted token in format: iv:encryptedData\n */\nexport function encryptToken(token: string): string {\n  const key = crypto.scryptSync(ENCRYPTION_KEY, 'salt', 32);\n  const iv = crypto.randomBytes(16);\n  const cipher = crypto.createCipheriv(ALGORITHM, key, iv);\n  \n  let encrypted = cipher.update(token, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  \n  // Return IV + encrypted data\n  return iv.toString('hex') + ':' + encrypted;\n}\n\n/**\n * Decrypt a token using AES-256-CBC\n * @param encryptedToken - The encrypted token in format: iv:encryptedData\n * @returns Decrypted token\n */\nexport function decryptToken(encryptedToken: string): string {\n  const key = crypto.scryptSync(ENCRYPTION_KEY, 'salt', 32);\n  const parts = encryptedToken.split(':');\n  \n  if (parts.length !== 2) {\n    throw new Error('Invalid encrypted token format');\n  }\n  \n  const iv = Buffer.from(parts[0], 'hex');\n  const encrypted = parts[1];\n  \n  const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);\n  \n  let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  \n  return decrypted;\n}\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar token_error_exports = {};\n__export(token_error_exports, {\n  VercelOidcTokenError: () => VercelOidcTokenError\n});\nmodule.exports = __toCommonJS(token_error_exports);\nclass VercelOidcTokenError extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.name = \"VercelOidcTokenError\";\n    this.cause = cause;\n  }\n  toString() {\n    if (this.cause) {\n      return `${this.name}: ${this.message}: ${this.cause}`;\n    }\n    return `${this.name}: ${this.message}`;\n  }\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  VercelOidcTokenError\n});\n","import { decryptToken } from './encryption';\n\nexport interface CalendarEvent {\n  id?: string;\n  summary: string;\n  description?: string;\n  start: {\n    dateTime: string;\n    timeZone?: string;\n  };\n  end: {\n    dateTime: string;\n    timeZone?: string;\n  };\n  colorId?: string;\n}\n\nexport interface CalendarEventResponse {\n  id: string;\n  summary: string;\n  description?: string;\n  start: {\n    dateTime: string;\n    timeZone?: string;\n  };\n  end: {\n    dateTime: string;\n    timeZone?: string;\n  };\n  htmlLink: string;\n}\n\n/**\n * Google Calendar API client\n */\nexport class GoogleCalendarClient {\n  private accessToken: string;\n  private refreshToken?: string;\n  private baseUrl = 'https://www.googleapis.com/calendar/v3';\n\n  constructor(encryptedAccessToken: string, encryptedRefreshToken?: string) {\n    this.accessToken = decryptToken(encryptedAccessToken);\n    if (encryptedRefreshToken) {\n      this.refreshToken = decryptToken(encryptedRefreshToken);\n    }\n  }\n\n  /**\n   * Create a calendar event\n   */\n  async createEvent(\n    calendarId: string = 'primary',\n    event: CalendarEvent\n  ): Promise<CalendarEventResponse> {\n    const response = await fetch(\n      `${this.baseUrl}/calendars/${calendarId}/events`,\n      {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${this.accessToken}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(event),\n      }\n    );\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(\n        `Google Calendar API error: ${response.status} ${response.statusText} - ${errorText}`\n      );\n    }\n\n    return response.json();\n  }\n\n  /**\n   * Update a calendar event\n   */\n  async updateEvent(\n    eventId: string,\n    event: CalendarEvent,\n    calendarId: string = 'primary'\n  ): Promise<CalendarEventResponse> {\n    const response = await fetch(\n      `${this.baseUrl}/calendars/${calendarId}/events/${eventId}`,\n      {\n        method: 'PUT',\n        headers: {\n          Authorization: `Bearer ${this.accessToken}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(event),\n      }\n    );\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(\n        `Google Calendar API error: ${response.status} ${response.statusText} - ${errorText}`\n      );\n    }\n\n    return response.json();\n  }\n\n  /**\n   * Delete a calendar event\n   */\n  async deleteEvent(\n    eventId: string,\n    calendarId: string = 'primary'\n  ): Promise<void> {\n    const response = await fetch(\n      `${this.baseUrl}/calendars/${calendarId}/events/${eventId}`,\n      {\n        method: 'DELETE',\n        headers: {\n          Authorization: `Bearer ${this.accessToken}`,\n        },\n      }\n    );\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(\n        `Google Calendar API error: ${response.status} ${response.statusText} - ${errorText}`\n      );\n    }\n  }\n\n  /**\n   * List events in a time range\n   */\n  async listEvents(\n    timeMin: Date,\n    timeMax: Date,\n    calendarId: string = 'primary'\n  ): Promise<CalendarEventResponse[]> {\n    const url = new URL(`${this.baseUrl}/calendars/${calendarId}/events`);\n    url.searchParams.set('timeMin', timeMin.toISOString());\n    url.searchParams.set('timeMax', timeMax.toISOString());\n    url.searchParams.set('singleEvents', 'true');\n    url.searchParams.set('orderBy', 'startTime');\n\n    const response = await fetch(url.toString(), {\n      headers: {\n        Authorization: `Bearer ${this.accessToken}`,\n      },\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(\n        `Google Calendar API error: ${response.status} ${response.statusText} - ${errorText}`\n      );\n    }\n\n    const data = await response.json();\n    return data.items || [];\n  }\n\n  /**\n   * Check for scheduling conflicts\n   */\n  async hasConflict(\n    startTime: Date,\n    endTime: Date,\n    calendarId: string = 'primary'\n  ): Promise<boolean> {\n    const events = await this.listEvents(startTime, endTime, calendarId);\n    return events.length > 0;\n  }\n}\n\n/**\n * Refresh Google OAuth access token\n */\nexport async function refreshGoogleToken(refreshToken: string): Promise<{\n  access_token: string;\n  expires_in: number;\n}> {\n  const clientId = process.env.GOOGLE_CLIENT_ID;\n  const clientSecret = process.env.GOOGLE_CLIENT_SECRET;\n\n  if (!clientId || !clientSecret) {\n    throw new Error('Google OAuth credentials not configured');\n  }\n\n  const response = await fetch('https://oauth2.googleapis.com/token', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n    body: new URLSearchParams({\n      client_id: clientId,\n      client_secret: clientSecret,\n      refresh_token: refreshToken,\n      grant_type: 'refresh_token',\n    }),\n  });\n\n  if (!response.ok) {\n    const errorText = await response.text();\n    throw new Error(`Token refresh failed: ${response.status} - ${errorText}`);\n  }\n\n  return response.json();\n}\n","import { prisma } from './prisma';\nimport { GoogleCalendarClient, refreshGoogleToken } from './google-calendar';\nimport { encryptToken } from './encryption';\n\nexport interface TaskSchedule {\n  taskId: string;\n  title: string;\n  description?: string;\n  startTime: Date;\n  endTime: Date;\n  priority: number;\n}\n\n/**\n * Sync a daily plan's tasks to Google Calendar\n */\nexport async function syncPlanToCalendar(\n  userId: string,\n  tasks: TaskSchedule[],\n  timeZone: string = 'UTC'\n): Promise<{\n  success: boolean;\n  createdEvents: number;\n  errors: string[];\n}> {\n  const errors: string[] = [];\n  let createdEvents = 0;\n\n  try {\n    // Get Google Calendar integration\n    const integration = await prisma.integration.findUnique({\n      where: {\n        userId_platform: {\n          userId,\n          platform: 'google_calendar',\n        },\n      },\n    });\n\n    if (!integration) {\n      return {\n        success: false,\n        createdEvents: 0,\n        errors: ['Google Calendar not connected'],\n      };\n    }\n\n    // Check if token needs refresh\n    let accessToken = integration.accessToken;\n    if (integration.expiresAt && integration.expiresAt < new Date()) {\n      if (!integration.refreshToken) {\n        return {\n          success: false,\n          createdEvents: 0,\n          errors: ['Token expired and no refresh token available'],\n        };\n      }\n\n      // Refresh the token\n      const tokenData = await refreshGoogleToken(integration.refreshToken);\n      accessToken = encryptToken(tokenData.access_token);\n\n      // Update the integration with new token\n      await prisma.integration.update({\n        where: { id: integration.id },\n        data: {\n          accessToken,\n          expiresAt: new Date(Date.now() + tokenData.expires_in * 1000),\n        },\n      });\n    }\n\n    // Create calendar client\n    const client = new GoogleCalendarClient(accessToken);\n\n    // Create events for each task\n    for (const task of tasks) {\n      try {\n        // Check for conflicts\n        const hasConflict = await client.hasConflict(task.startTime, task.endTime);\n\n        if (hasConflict) {\n          errors.push(\n            `Conflict detected for task \"${task.title}\" at ${task.startTime.toISOString()}`\n          );\n          continue;\n        }\n\n        // Create the event\n        const event = await client.createEvent('primary', {\n          summary: task.title,\n          description: task.description,\n          start: {\n            dateTime: task.startTime.toISOString(),\n            timeZone,\n          },\n          end: {\n            dateTime: task.endTime.toISOString(),\n            timeZone,\n          },\n          colorId: getPriorityColor(task.priority),\n        });\n\n        // Update the task with the calendar event ID\n        await prisma.planTask.update({\n          where: { id: task.taskId },\n          data: {\n            externalId: event.id,\n          },\n        });\n\n        createdEvents++;\n      } catch (error) {\n        console.error(`Error creating event for task ${task.taskId}:`, error);\n        errors.push(\n          `Failed to create event for task \"${task.title}\": ${\n            error instanceof Error ? error.message : 'Unknown error'\n          }`\n        );\n      }\n    }\n\n    return {\n      success: errors.length === 0,\n      createdEvents,\n      errors,\n    };\n  } catch (error) {\n    console.error('Calendar sync error:', error);\n    return {\n      success: false,\n      createdEvents,\n      errors: [\n        `Calendar sync failed: ${\n          error instanceof Error ? error.message : 'Unknown error'\n        }`,\n      ],\n    };\n  }\n}\n\n/**\n * Update a calendar event when a task is rescheduled\n */\nexport async function updateCalendarEvent(\n  userId: string,\n  taskId: string,\n  newStartTime: Date,\n  newEndTime: Date,\n  timeZone: string = 'UTC'\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    // Get the task with its calendar event ID\n    const task = await prisma.planTask.findUnique({\n      where: { id: taskId },\n    });\n\n    if (!task || !task.externalId) {\n      return {\n        success: false,\n        error: 'Task not found or not synced to calendar',\n      };\n    }\n\n    // Get Google Calendar integration\n    const integration = await prisma.integration.findUnique({\n      where: {\n        userId_platform: {\n          userId,\n          platform: 'google_calendar',\n        },\n      },\n    });\n\n    if (!integration) {\n      return {\n        success: false,\n        error: 'Google Calendar not connected',\n      };\n    }\n\n    // Check if token needs refresh\n    let accessToken = integration.accessToken;\n    if (integration.expiresAt && integration.expiresAt < new Date()) {\n      if (!integration.refreshToken) {\n        return {\n          success: false,\n          error: 'Token expired and no refresh token available',\n        };\n      }\n\n      // Refresh the token\n      const tokenData = await refreshGoogleToken(integration.refreshToken);\n      accessToken = encryptToken(tokenData.access_token);\n\n      // Update the integration with new token\n      await prisma.integration.update({\n        where: { id: integration.id },\n        data: {\n          accessToken,\n          expiresAt: new Date(Date.now() + tokenData.expires_in * 1000),\n        },\n      });\n    }\n\n    // Create calendar client\n    const client = new GoogleCalendarClient(accessToken);\n\n    // Update the event\n    await client.updateEvent(task.externalId, {\n      summary: task.title,\n      description: task.description || undefined,\n      start: {\n        dateTime: newStartTime.toISOString(),\n        timeZone,\n      },\n      end: {\n        dateTime: newEndTime.toISOString(),\n        timeZone,\n      },\n      colorId: getPriorityColor(task.priority),\n    });\n\n    // Update the task's scheduled times\n    await prisma.planTask.update({\n      where: { id: taskId },\n      data: {\n        scheduledStart: newStartTime,\n        scheduledEnd: newEndTime,\n      },\n    });\n\n    return { success: true };\n  } catch (error) {\n    console.error('Calendar event update error:', error);\n    return {\n      success: false,\n      error:\n        error instanceof Error ? error.message : 'Failed to update calendar event',\n    };\n  }\n}\n\n/**\n * Delete a calendar event when a task is removed\n */\nexport async function deleteCalendarEvent(\n  userId: string,\n  taskId: string\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    // Get the task with its calendar event ID\n    const task = await prisma.planTask.findUnique({\n      where: { id: taskId },\n    });\n\n    if (!task || !task.externalId) {\n      return {\n        success: true, // Already not in calendar\n      };\n    }\n\n    // Get Google Calendar integration\n    const integration = await prisma.integration.findUnique({\n      where: {\n        userId_platform: {\n          userId,\n          platform: 'google_calendar',\n        },\n      },\n    });\n\n    if (!integration) {\n      return {\n        success: false,\n        error: 'Google Calendar not connected',\n      };\n    }\n\n    // Check if token needs refresh\n    let accessToken = integration.accessToken;\n    if (integration.expiresAt && integration.expiresAt < new Date()) {\n      if (!integration.refreshToken) {\n        return {\n          success: false,\n          error: 'Token expired and no refresh token available',\n        };\n      }\n\n      // Refresh the token\n      const tokenData = await refreshGoogleToken(integration.refreshToken);\n      accessToken = encryptToken(tokenData.access_token);\n\n      // Update the integration with new token\n      await prisma.integration.update({\n        where: { id: integration.id },\n        data: {\n          accessToken,\n          expiresAt: new Date(Date.now() + tokenData.expires_in * 1000),\n        },\n      });\n    }\n\n    // Create calendar client\n    const client = new GoogleCalendarClient(accessToken);\n\n    // Delete the event\n    await client.deleteEvent(task.externalId);\n\n    // Clear the external ID from the task\n    await prisma.planTask.update({\n      where: { id: taskId },\n      data: {\n        externalId: null,\n      },\n    });\n\n    return { success: true };\n  } catch (error) {\n    console.error('Calendar event deletion error:', error);\n    return {\n      success: false,\n      error:\n        error instanceof Error ? error.message : 'Failed to delete calendar event',\n    };\n  }\n}\n\n/**\n * Get Google Calendar color ID based on task priority\n * Priority 1 (highest) = Red (11)\n * Priority 2 = Orange (6)\n * Priority 3 = Yellow (5)\n * Priority 4 (lowest) = Blue (9)\n */\nfunction getPriorityColor(priority: number): string {\n  const colorMap: Record<number, string> = {\n    1: '11', // Red\n    2: '6',  // Orange\n    3: '5',  // Yellow\n    4: '9',  // Blue\n  };\n  return colorMap[priority] || '9'; // Default to blue\n}\n"],"names":[],"mappings":"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","ignoreList":[1]}